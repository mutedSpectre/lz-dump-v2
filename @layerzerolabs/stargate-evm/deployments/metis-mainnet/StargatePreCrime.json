{
  "address": "0xD7D4A5095272f7963A5c8287b416f2fCFB436eeC",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "_localChainId",
          "type": "uint16"
        },
        {
          "internalType": "address",
          "name": "_stargateRouter",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_poolView",
          "type": "address"
        },
        {
          "internalType": "uint64",
          "name": "_maxBatchSizeForSimulate",
          "type": "uint64"
        },
        {
          "internalType": "uint16[]",
          "name": "_remoteChainIds",
          "type": "uint16[]"
        },
        {
          "internalType": "bytes32[]",
          "name": "_remotePrecrimeAddresses",
          "type": "bytes32[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "CODE_MISS_SIMULATE_RESULT",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "CODE_PACKETS_OVERSIZE",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "CODE_PACKETS_UNSORTED",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "CODE_PRECRIME_FAILURE",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "CODE_SUCCESS",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "CONFIG_VERSION",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "PRECRIME_VERSION",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint16",
              "name": "srcChainId",
              "type": "uint16"
            },
            {
              "internalType": "bytes32",
              "name": "srcAddress",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "nonce",
              "type": "uint64"
            },
            {
              "internalType": "bytes",
              "name": "payload",
              "type": "bytes"
            }
          ],
          "internalType": "struct IPreCrime.Packet[]",
          "name": "_packets",
          "type": "tuple[]"
        }
      ],
      "name": "_simulateAndRevert",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint16",
              "name": "srcChainId",
              "type": "uint16"
            },
            {
              "internalType": "bytes32",
              "name": "srcAddress",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "nonce",
              "type": "uint64"
            },
            {
              "internalType": "bytes",
              "name": "payload",
              "type": "bytes"
            }
          ],
          "internalType": "struct IPreCrime.Packet[]",
          "name": "_packets",
          "type": "tuple[]"
        }
      ],
      "name": "getConfig",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "inflightBuffer",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "localChainId",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "maxBatchSize",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "poolView",
      "outputs": [
        {
          "internalType": "contract PoolView",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint16",
              "name": "srcChainId",
              "type": "uint16"
            },
            {
              "internalType": "bytes32",
              "name": "srcAddress",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "nonce",
              "type": "uint64"
            },
            {
              "internalType": "bytes",
              "name": "payload",
              "type": "bytes"
            }
          ],
          "internalType": "struct IPreCrime.Packet[]",
          "name": "_packets",
          "type": "tuple[]"
        },
        {
          "internalType": "bytes[]",
          "name": "_simulation",
          "type": "bytes[]"
        }
      ],
      "name": "precrime",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "code",
          "type": "uint16"
        },
        {
          "internalType": "bytes",
          "name": "reason",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "remoteChainIds",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "remotePrecrimeAddresses",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_inflightBuffer",
          "type": "uint256"
        }
      ],
      "name": "setInflightBuffer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "_size",
          "type": "uint64"
        }
      ],
      "name": "setMaxBatchSize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_poolView",
          "type": "address"
        }
      ],
      "name": "setPoolView",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16[]",
          "name": "_remoteChainIds",
          "type": "uint16[]"
        },
        {
          "internalType": "bytes32[]",
          "name": "_remotePrecrimeAddresses",
          "type": "bytes32[]"
        }
      ],
      "name": "setRemotePrecrimeAddresses",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_stargateRouter",
          "type": "address"
        }
      ],
      "name": "setStargateRouter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint16",
              "name": "srcChainId",
              "type": "uint16"
            },
            {
              "internalType": "bytes32",
              "name": "srcAddress",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "nonce",
              "type": "uint64"
            },
            {
              "internalType": "bytes",
              "name": "payload",
              "type": "bytes"
            }
          ],
          "internalType": "struct IPreCrime.Packet[]",
          "name": "_packets",
          "type": "tuple[]"
        }
      ],
      "name": "simulate",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "code",
          "type": "uint16"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "stargateRouter",
      "outputs": [
        {
          "internalType": "contract Router",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "version",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "",
          "type": "uint16"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x2e086572e6972d54a1972e768439e3d48bc9b5ea1477aab372e2acd05edb4a99",
  "receipt": {
    "to": null,
    "from": "0xc13b65f7c53Cd6db2EA205a4b574b4a0858720A6",
    "contractAddress": "0xD7D4A5095272f7963A5c8287b416f2fCFB436eeC",
    "transactionIndex": 0,
    "gasUsed": "3787353",
    "logsBloom": "0x00040000000000000000000000000000000000000000000000800000000040000000000000000000000000000000000000000000000000000000020000000000000400000000000000000000000000000001000000000000000000000000000000000000030000000000000000000800000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000020000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xa392aae4784bec34f1f45c4a9205a3e5d663021cf394fca40ddfc85082f918cc",
    "transactionHash": "0x2e086572e6972d54a1972e768439e3d48bc9b5ea1477aab372e2acd05edb4a99",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 5901669,
        "transactionHash": "0x2e086572e6972d54a1972e768439e3d48bc9b5ea1477aab372e2acd05edb4a99",
        "address": "0xD7D4A5095272f7963A5c8287b416f2fCFB436eeC",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000c13b65f7c53cd6db2ea205a4b574b4a0858720a6"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0xa392aae4784bec34f1f45c4a9205a3e5d663021cf394fca40ddfc85082f918cc"
      }
    ],
    "blockNumber": 5901669,
    "cumulativeGasUsed": "3787353",
    "status": 1,
    "byzantium": true
  },
  "args": [
    151,
    "0x2F6F07CDcf3588944Bf4C42aC74ff24bF56e7590",
    "0x4d97186cD94047E285B7cb78fa63C93E69e7AaD0",
    50,
    [],
    []
  ],
  "numDeployments": 1,
  "solcInputHash": "c740851f1544f0c8f3bb51a95642bd99",
  "metadata": "{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_localChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_stargateRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_poolView\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_maxBatchSizeForSimulate\",\"type\":\"uint64\"},{\"internalType\":\"uint16[]\",\"name\":\"_remoteChainIds\",\"type\":\"uint16[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_remotePrecrimeAddresses\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CODE_MISS_SIMULATE_RESULT\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CODE_PACKETS_OVERSIZE\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CODE_PACKETS_UNSORTED\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CODE_PRECRIME_FAILURE\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CODE_SUCCESS\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONFIG_VERSION\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRECRIME_VERSION\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"srcAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct IPreCrime.Packet[]\",\"name\":\"_packets\",\"type\":\"tuple[]\"}],\"name\":\"_simulateAndRevert\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"srcAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct IPreCrime.Packet[]\",\"name\":\"_packets\",\"type\":\"tuple[]\"}],\"name\":\"getConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inflightBuffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"localChainId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBatchSize\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolView\",\"outputs\":[{\"internalType\":\"contract PoolView\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"srcAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct IPreCrime.Packet[]\",\"name\":\"_packets\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_simulation\",\"type\":\"bytes[]\"}],\"name\":\"precrime\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"code\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"reason\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"remoteChainIds\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"remotePrecrimeAddresses\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_inflightBuffer\",\"type\":\"uint256\"}],\"name\":\"setInflightBuffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_size\",\"type\":\"uint64\"}],\"name\":\"setMaxBatchSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolView\",\"type\":\"address\"}],\"name\":\"setPoolView\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"_remoteChainIds\",\"type\":\"uint16[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_remotePrecrimeAddresses\",\"type\":\"bytes32[]\"}],\"name\":\"setRemotePrecrimeAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stargateRouter\",\"type\":\"address\"}],\"name\":\"setStargateRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"srcAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct IPreCrime.Packet[]\",\"name\":\"_packets\",\"type\":\"tuple[]\"}],\"name\":\"simulate\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"code\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stargateRouter\",\"outputs\":[{\"internalType\":\"contract Router\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"_simulateAndRevert((uint16,bytes32,uint64,bytes)[])\":{\"details\":\"internal function, no one should call\",\"params\":{\"_packets\":\"packets\"}},\"getConfig((uint16,bytes32,uint64,bytes)[])\":{\"details\":\"get precrime config,\",\"params\":{\"_packets\":\"packets\"},\"returns\":{\"_0\":\"configation bytes\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"precrime((uint16,bytes32,uint64,bytes)[],bytes[])\":{\"details\":\"@param _simulation all simulation results from difference chains\",\"returns\":{\"code\":\"    precrime result code; check out the error code defination\",\"reason\":\"  error reason\"}},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"simulate((uint16,bytes32,uint64,bytes)[])\":{\"details\":\"simulate run cross chain packets and get a simulation result for precrime later\",\"params\":{\"_packets\":\"packets, the packets item should group by srcChainId, srcAddress, then sort by nonce\"},\"returns\":{\"code\":\"  simulation result code; see the error code defination\",\"data\":\"the result is use for precrime params\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"},\"version()\":{\"details\":\"protocol version\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/precrime/stargate/StargatePreCrime.sol\":\"StargatePreCrime\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@layerzerolabs/layerzero-core/contracts/interfaces/ILayerZeroEndpoint.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.5.0;\\n\\nimport \\\"./ILayerZeroUserApplicationConfig.sol\\\";\\n\\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\\n    // @param _dstChainId - the destination chain identifier\\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\\n    // @param _payload - a custom bytes payload to send to the destination contract\\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\\n\\n    // @notice used by the messaging library to publish verified payload\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source contract (as bytes) at the source chain\\n    // @param _dstAddress - the address on destination chain\\n    // @param _nonce - the unbound message ordering nonce\\n    // @param _gasLimit - the gas limit for external contract execution\\n    // @param _payload - verified payload to send to the destination contract\\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\\n\\n    // @notice get the inboundNonce of a receiver from a source chain which could be EVM or non-EVM chain\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\\n\\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\\n    // @param _srcAddress - the source chain contract address\\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\\n\\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\\n    // @param _dstChainId - the destination chain identifier\\n    // @param _userApplication - the user app address on this EVM chain\\n    // @param _payload - the custom message to send over LayerZero\\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\\n\\n    // @notice get this Endpoint's immutable source identifier\\n    function getChainId() external view returns (uint16);\\n\\n    // @notice the interface to retry failed message on this Endpoint destination\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    // @param _payload - the payload to be retried\\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\\n\\n    // @notice query if any STORED payload (message blocking) at the endpoint.\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\\n\\n    // @notice query if the _libraryAddress is valid for sending msgs.\\n    // @param _userApplication - the user app address on this EVM chain\\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\\n\\n    // @notice query if the _libraryAddress is valid for receiving msgs.\\n    // @param _userApplication - the user app address on this EVM chain\\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\\n\\n    // @notice query if the non-reentrancy guard for send() is on\\n    // @return true if the guard is on. false otherwise\\n    function isSendingPayload() external view returns (bool);\\n\\n    // @notice query if the non-reentrancy guard for receive() is on\\n    // @return true if the guard is on. false otherwise\\n    function isReceivingPayload() external view returns (bool);\\n\\n    // @notice get the configuration of the LayerZero messaging library of the specified version\\n    // @param _version - messaging library version\\n    // @param _chainId - the chainId for the pending config change\\n    // @param _userApplication - the contract address of the user application\\n    // @param _configType - type of configuration. every messaging library has its own convention.\\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\\n\\n    // @notice get the send() LayerZero messaging library version\\n    // @param _userApplication - the contract address of the user application\\n    function getSendVersion(address _userApplication) external view returns (uint16);\\n\\n    // @notice get the lzReceive() LayerZero messaging library version\\n    // @param _userApplication - the contract address of the user application\\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\\n}\\n\",\"keccak256\":\"0xbc2e0022d4d53d136830aa90037be2ed7a0966f5fd1b409bf5986185984c495f\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/layerzero-core/contracts/interfaces/ILayerZeroReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.5.0;\\n\\ninterface ILayerZeroReceiver {\\n    // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\\n    // @param _srcChainId - the source endpoint identifier\\n    // @param _srcAddress - the source sending contract address from the source chain\\n    // @param _nonce - the ordered message nonce\\n    // @param _payload - the signed payload is the UA bytes has encoded to be sent\\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\\n}\\n\",\"keccak256\":\"0xd1617e455d90d41556bba636bc440627d301ec481de16ff04fbd520333c3c6f3\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/layerzero-core/contracts/interfaces/ILayerZeroUserApplicationConfig.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.5.0;\\n\\ninterface ILayerZeroUserApplicationConfig {\\n    // @notice set the configuration of the LayerZero messaging library of the specified version\\n    // @param _version - messaging library version\\n    // @param _chainId - the chainId for the pending config change\\n    // @param _configType - type of configuration. every messaging library has its own convention.\\n    // @param _config - configuration in the bytes. can encode arbitrary content.\\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\\n\\n    // @notice set the send() LayerZero messaging library version to _version\\n    // @param _version - new messaging library version\\n    function setSendVersion(uint16 _version) external;\\n\\n    // @notice set the lzReceive() LayerZero messaging library version to _version\\n    // @param _version - new messaging library version\\n    function setReceiveVersion(uint16 _version) external;\\n\\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\\n    // @param _srcChainId - the chainId of the source chain\\n    // @param _srcAddress - the contract address of the source contract at the source chain\\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\\n}\\n\",\"keccak256\":\"0xdc7e072cf3064081a8edf4a286ca43ddecc24330f2923d96f416f9d3f6538447\",\"license\":\"BUSL-1.1\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\",\"keccak256\":\"0x549c5343ad9f7e3f38aa4c4761854403502574bbc15b822db2ce892ff9b79da7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xe22a1fc7400ae196eba2ad1562d0386462b00a6363b742d55a2fd2021a58586f\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xbd74f587ab9b9711801baf667db1426e4a03fd2d7f15af33e0e0d0394e7cef76\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf89f005a3d98f7768cdee2583707db0ac725cf567d455751af32ee68132f3db3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x8d3cb350f04ff49cfb10aef08d87f19dcbaecc8027b0bed12f3275cd12f38cf0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0x1153f6dd334c01566417b8c551122450542a2b75a2bbb379d59a8c320ed6da28\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        uint256 index = digits - 1;\\n        temp = value;\\n        while (temp != 0) {\\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\\n            temp /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\",\"keccak256\":\"0x08e38e034333372aea8cb1b8846085b7fbab42c6b77a0af464d2c6827827c4f0\",\"license\":\"MIT\"},\"contracts/Bridge.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\n// imports\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"./Pool.sol\\\";\\nimport \\\"./Router.sol\\\";\\n// interfaces\\nimport \\\"@layerzerolabs/layerzero-core/contracts/interfaces/ILayerZeroReceiver.sol\\\";\\nimport \\\"@layerzerolabs/layerzero-core/contracts/interfaces/ILayerZeroEndpoint.sol\\\";\\nimport \\\"@layerzerolabs/layerzero-core/contracts/interfaces/ILayerZeroUserApplicationConfig.sol\\\";\\n\\n// libraries\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\ncontract Bridge is Ownable, ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\\n    using SafeMath for uint256;\\n\\n    //---------------------------------------------------------------------------\\n    // CONSTANTS\\n    uint8 internal constant TYPE_SWAP_REMOTE = 1;\\n    uint8 internal constant TYPE_ADD_LIQUIDITY = 2;\\n    uint8 internal constant TYPE_REDEEM_LOCAL_CALL_BACK = 3;\\n    uint8 internal constant TYPE_WITHDRAW_REMOTE = 4;\\n\\n    //---------------------------------------------------------------------------\\n    // VARIABLES\\n    ILayerZeroEndpoint public immutable layerZeroEndpoint;\\n    mapping(uint16 => bytes) public bridgeLookup;\\n    mapping(uint16 => mapping(uint8 => uint256)) public gasLookup;\\n    Router public immutable router;\\n    bool public useLayerZeroToken;\\n\\n    //---------------------------------------------------------------------------\\n    // EVENTS\\n    event SendMsg(uint8 msgType, uint64 nonce);\\n\\n    //---------------------------------------------------------------------------\\n    // MODIFIERS\\n    modifier onlyRouter() {\\n        require(msg.sender == address(router), \\\"Stargate: caller must be Router.\\\");\\n        _;\\n    }\\n\\n    constructor(address _layerZeroEndpoint, address _router) {\\n        require(_layerZeroEndpoint != address(0x0), \\\"Stargate: _layerZeroEndpoint cannot be 0x0\\\");\\n        require(_router != address(0x0), \\\"Stargate: _router cannot be 0x0\\\");\\n        layerZeroEndpoint = ILayerZeroEndpoint(_layerZeroEndpoint);\\n        router = Router(_router);\\n    }\\n\\n    //---------------------------------------------------------------------------\\n    // EXTERNAL functions\\n\\n    function lzReceive(\\n        uint16 _srcChainId,\\n        bytes memory _srcAddress,\\n        uint64 _nonce,\\n        bytes memory _payload\\n    ) external override {\\n        require(msg.sender == address(layerZeroEndpoint), \\\"Stargate: only LayerZero endpoint can call lzReceive\\\");\\n        require(\\n            _srcAddress.length == bridgeLookup[_srcChainId].length && keccak256(_srcAddress) == keccak256(bridgeLookup[_srcChainId]),\\n            \\\"Stargate: bridge does not match\\\"\\n        );\\n\\n        uint8 functionType;\\n        assembly {\\n            functionType := mload(add(_payload, 32))\\n        }\\n\\n        if (functionType == TYPE_SWAP_REMOTE) {\\n            (\\n                ,\\n                uint256 srcPoolId,\\n                uint256 dstPoolId,\\n                uint256 dstGasForCall,\\n                Pool.CreditObj memory c,\\n                Pool.SwapObj memory s,\\n                bytes memory to,\\n                bytes memory payload\\n            ) = abi.decode(_payload, (uint8, uint256, uint256, uint256, Pool.CreditObj, Pool.SwapObj, bytes, bytes));\\n            address toAddress;\\n            assembly {\\n                toAddress := mload(add(to, 20))\\n            }\\n            router.creditChainPath(_srcChainId, srcPoolId, dstPoolId, c);\\n            router.swapRemote(_srcChainId, _srcAddress, _nonce, srcPoolId, dstPoolId, dstGasForCall, toAddress, s, payload);\\n        } else if (functionType == TYPE_ADD_LIQUIDITY) {\\n            (, uint256 srcPoolId, uint256 dstPoolId, Pool.CreditObj memory c) = abi.decode(_payload, (uint8, uint256, uint256, Pool.CreditObj));\\n            router.creditChainPath(_srcChainId, srcPoolId, dstPoolId, c);\\n        } else if (functionType == TYPE_REDEEM_LOCAL_CALL_BACK) {\\n            (, uint256 srcPoolId, uint256 dstPoolId, Pool.CreditObj memory c, uint256 amountSD, uint256 mintAmountSD, bytes memory to) = abi\\n                .decode(_payload, (uint8, uint256, uint256, Pool.CreditObj, uint256, uint256, bytes));\\n            address toAddress;\\n            assembly {\\n                toAddress := mload(add(to, 20))\\n            }\\n            router.creditChainPath(_srcChainId, srcPoolId, dstPoolId, c);\\n            router.redeemLocalCallback(_srcChainId, _srcAddress, _nonce, srcPoolId, dstPoolId, toAddress, amountSD, mintAmountSD);\\n        } else if (functionType == TYPE_WITHDRAW_REMOTE) {\\n            (, uint256 srcPoolId, uint256 dstPoolId, Pool.CreditObj memory c, uint256 amountSD, bytes memory to) = abi.decode(\\n                _payload,\\n                (uint8, uint256, uint256, Pool.CreditObj, uint256, bytes)\\n            );\\n            router.creditChainPath(_srcChainId, srcPoolId, dstPoolId, c);\\n            router.redeemLocalCheckOnRemote(_srcChainId, _srcAddress, _nonce, srcPoolId, dstPoolId, amountSD, to);\\n        }\\n    }\\n\\n    //---------------------------------------------------------------------------\\n    // LOCAL CHAIN FUNCTIONS\\n    function swap(\\n        uint16 _chainId,\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        address payable _refundAddress,\\n        Pool.CreditObj memory _c,\\n        Pool.SwapObj memory _s,\\n        IStargateRouter.lzTxObj memory _lzTxParams,\\n        bytes calldata _to,\\n        bytes calldata _payload\\n    ) external payable onlyRouter {\\n        bytes memory payload = abi.encode(TYPE_SWAP_REMOTE, _srcPoolId, _dstPoolId, _lzTxParams.dstGasForCall, _c, _s, _to, _payload);\\n        _call(_chainId, TYPE_SWAP_REMOTE, _refundAddress, _lzTxParams, payload);\\n    }\\n\\n    function redeemLocalCallback(\\n        uint16 _chainId,\\n        address payable _refundAddress,\\n        Pool.CreditObj memory _c,\\n        IStargateRouter.lzTxObj memory _lzTxParams,\\n        bytes memory _payload\\n    ) external payable onlyRouter {\\n        bytes memory payload;\\n\\n        {\\n            (, uint256 srcPoolId, uint256 dstPoolId, uint256 amountSD, uint256 mintAmountSD, bytes memory to) = abi.decode(\\n                _payload,\\n                (uint8, uint256, uint256, uint256, uint256, bytes)\\n            );\\n\\n            // swap dst and src because we are headed back\\n            payload = abi.encode(TYPE_REDEEM_LOCAL_CALL_BACK, dstPoolId, srcPoolId, _c, amountSD, mintAmountSD, to);\\n        }\\n\\n        _call(_chainId, TYPE_REDEEM_LOCAL_CALL_BACK, _refundAddress, _lzTxParams, payload);\\n    }\\n\\n    function redeemLocal(\\n        uint16 _chainId,\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        address payable _refundAddress,\\n        Pool.CreditObj memory _c,\\n        uint256 _amountSD,\\n        bytes calldata _to,\\n        IStargateRouter.lzTxObj memory _lzTxParams\\n    ) external payable onlyRouter {\\n        bytes memory payload = abi.encode(TYPE_WITHDRAW_REMOTE, _srcPoolId, _dstPoolId, _c, _amountSD, _to);\\n        _call(_chainId, TYPE_WITHDRAW_REMOTE, _refundAddress, _lzTxParams, payload);\\n    }\\n\\n    function sendCredits(\\n        uint16 _chainId,\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        address payable _refundAddress,\\n        Pool.CreditObj memory _c\\n    ) external payable onlyRouter {\\n        bytes memory payload = abi.encode(TYPE_ADD_LIQUIDITY, _srcPoolId, _dstPoolId, _c);\\n        IStargateRouter.lzTxObj memory lzTxObj = IStargateRouter.lzTxObj(0, 0, \\\"0x\\\");\\n        _call(_chainId, TYPE_ADD_LIQUIDITY, _refundAddress, lzTxObj, payload);\\n    }\\n\\n    function quoteLayerZeroFee(\\n        uint16 _chainId,\\n        uint8 _functionType,\\n        bytes calldata _toAddress,\\n        bytes calldata _transferAndCallPayload,\\n        IStargateRouter.lzTxObj memory _lzTxParams\\n    ) external view returns (uint256, uint256) {\\n        bytes memory payload = \\\"\\\";\\n        Pool.CreditObj memory c = Pool.CreditObj(1, 1);\\n        if (_functionType == TYPE_SWAP_REMOTE) {\\n            Pool.SwapObj memory s = Pool.SwapObj(1, 1, 1, 1, 1, 1);\\n            payload = abi.encode(TYPE_SWAP_REMOTE, 0, 0, 0, c, s, _toAddress, _transferAndCallPayload);\\n        } else if (_functionType == TYPE_ADD_LIQUIDITY) {\\n            payload = abi.encode(TYPE_ADD_LIQUIDITY, 0, 0, c);\\n        } else if (_functionType == TYPE_REDEEM_LOCAL_CALL_BACK) {\\n            payload = abi.encode(TYPE_REDEEM_LOCAL_CALL_BACK, 0, 0, c, 0, 0, _toAddress);\\n        } else if (_functionType == TYPE_WITHDRAW_REMOTE) {\\n            payload = abi.encode(TYPE_WITHDRAW_REMOTE, 0, 0, c, 0, _toAddress);\\n        } else {\\n            revert(\\\"Stargate: unsupported function type\\\");\\n        }\\n\\n        bytes memory lzTxParamBuilt = _txParamBuilder(_chainId, _functionType, _lzTxParams);\\n        return layerZeroEndpoint.estimateFees(_chainId, address(this), payload, useLayerZeroToken, lzTxParamBuilt);\\n    }\\n\\n    //---------------------------------------------------------------------------\\n    // dao functions\\n    function setBridge(uint16 _chainId, bytes calldata _bridgeAddress) external onlyOwner {\\n        require(bridgeLookup[_chainId].length == 0, \\\"Stargate: Bridge already set!\\\");\\n        bridgeLookup[_chainId] = _bridgeAddress;\\n    }\\n\\n    function setGasAmount(\\n        uint16 _chainId,\\n        uint8 _functionType,\\n        uint256 _gasAmount\\n    ) external onlyOwner {\\n        require(_functionType >= 1 && _functionType <= 4, \\\"Stargate: invalid _functionType\\\");\\n        gasLookup[_chainId][_functionType] = _gasAmount;\\n    }\\n\\n    function approveTokenSpender(\\n        address token,\\n        address spender,\\n        uint256 amount\\n    ) external onlyOwner {\\n        IERC20(token).approve(spender, amount);\\n    }\\n\\n    function setUseLayerZeroToken(bool enable) external onlyOwner {\\n        useLayerZeroToken = enable;\\n    }\\n\\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\\n        layerZeroEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\\n    }\\n\\n    //---------------------------------------------------------------------------\\n    // generic config for user Application\\n    function setConfig(\\n        uint16 _version,\\n        uint16 _chainId,\\n        uint256 _configType,\\n        bytes calldata _config\\n    ) external override onlyOwner {\\n        layerZeroEndpoint.setConfig(_version, _chainId, _configType, _config);\\n    }\\n\\n    function setSendVersion(uint16 version) external override onlyOwner {\\n        layerZeroEndpoint.setSendVersion(version);\\n    }\\n\\n    function setReceiveVersion(uint16 version) external override onlyOwner {\\n        layerZeroEndpoint.setReceiveVersion(version);\\n    }\\n\\n    //---------------------------------------------------------------------------\\n    // INTERNAL functions\\n    function txParamBuilderType1(uint256 _gasAmount) internal pure returns (bytes memory) {\\n        uint16 txType = 1;\\n        return abi.encodePacked(txType, _gasAmount);\\n    }\\n\\n    function txParamBuilderType2(\\n        uint256 _gasAmount,\\n        uint256 _dstNativeAmount,\\n        bytes memory _dstNativeAddr\\n    ) internal pure returns (bytes memory) {\\n        uint16 txType = 2;\\n        return abi.encodePacked(txType, _gasAmount, _dstNativeAmount, _dstNativeAddr);\\n    }\\n\\n    function _txParamBuilder(\\n        uint16 _chainId,\\n        uint8 _type,\\n        IStargateRouter.lzTxObj memory _lzTxParams\\n    ) internal view returns (bytes memory) {\\n        bytes memory lzTxParam;\\n        address dstNativeAddr;\\n        {\\n            bytes memory dstNativeAddrBytes = _lzTxParams.dstNativeAddr;\\n            assembly {\\n                dstNativeAddr := mload(add(dstNativeAddrBytes, 20))\\n            }\\n        }\\n\\n        uint256 totalGas = gasLookup[_chainId][_type].add(_lzTxParams.dstGasForCall);\\n        if (_lzTxParams.dstNativeAmount > 0 && dstNativeAddr != address(0x0)) {\\n            lzTxParam = txParamBuilderType2(totalGas, _lzTxParams.dstNativeAmount, _lzTxParams.dstNativeAddr);\\n        } else {\\n            lzTxParam = txParamBuilderType1(totalGas);\\n        }\\n\\n        return lzTxParam;\\n    }\\n\\n    function _call(\\n        uint16 _chainId,\\n        uint8 _type,\\n        address payable _refundAddress,\\n        IStargateRouter.lzTxObj memory _lzTxParams,\\n        bytes memory _payload\\n    ) internal {\\n        bytes memory lzTxParamBuilt = _txParamBuilder(_chainId, _type, _lzTxParams);\\n        uint64 nextNonce = layerZeroEndpoint.getOutboundNonce(_chainId, address(this)) + 1;\\n        layerZeroEndpoint.send{value: msg.value}(_chainId, bridgeLookup[_chainId], _payload, _refundAddress, address(this), lzTxParamBuilt);\\n        emit SendMsg(_type, nextNonce);\\n    }\\n\\n    function renounceOwnership() public override onlyOwner {}\\n}\\n\",\"keccak256\":\"0x2ab58a7be8e59dac9a52faedd1645b65f917078d3b10e8b88521e90e8ce4deef\",\"license\":\"BUSL-1.1\"},\"contracts/Factory.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./Pool.sol\\\";\\n\\ncontract Factory is Ownable {\\n    using SafeMath for uint256;\\n\\n    //---------------------------------------------------------------------------\\n    // VARIABLES\\n    mapping(uint256 => Pool) public getPool; // poolId -> PoolInfo\\n    address[] public allPools;\\n    address public immutable router;\\n    address public defaultFeeLibrary; // address for retrieving fee params for swaps\\n\\n    //---------------------------------------------------------------------------\\n    // MODIFIERS\\n    modifier onlyRouter() {\\n        require(msg.sender == router, \\\"Stargate: caller must be Router.\\\");\\n        _;\\n    }\\n\\n    constructor(address _router) {\\n        require(_router != address(0x0), \\\"Stargate: _router cant be 0x0\\\"); // 1 time only\\n        router = _router;\\n    }\\n\\n    function setDefaultFeeLibrary(address _defaultFeeLibrary) external onlyOwner {\\n        require(_defaultFeeLibrary != address(0x0), \\\"Stargate: fee library cant be 0x0\\\");\\n        defaultFeeLibrary = _defaultFeeLibrary;\\n    }\\n\\n    function allPoolsLength() external view returns (uint256) {\\n        return allPools.length;\\n    }\\n\\n    function createPool(\\n        uint256 _poolId,\\n        address _token,\\n        uint8 _sharedDecimals,\\n        uint8 _localDecimals,\\n        string memory _name,\\n        string memory _symbol\\n    ) public onlyRouter returns (address poolAddress) {\\n        require(address(getPool[_poolId]) == address(0x0), \\\"Stargate: Pool already created\\\");\\n\\n        Pool pool = new Pool(_poolId, router, _token, _sharedDecimals, _localDecimals, defaultFeeLibrary, _name, _symbol);\\n        getPool[_poolId] = pool;\\n        poolAddress = address(pool);\\n        allPools.push(poolAddress);\\n    }\\n\\n    function renounceOwnership() public override onlyOwner {}\\n}\\n\",\"keccak256\":\"0x90afcaeaf0f8e3e44d25a4596705f792a03f15524e400d0c1c131b291e01c4e9\",\"license\":\"BUSL-1.1\"},\"contracts/LPTokenERC20.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.7.6;\\n\\n// libraries\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\ncontract LPTokenERC20 {\\n    using SafeMath for uint256;\\n\\n    //---------------------------------------------------------------------------\\n    // CONSTANTS\\n    string public name;\\n    string public symbol;\\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n    // set in constructor\\n    bytes32 public DOMAIN_SEPARATOR;\\n\\n    //---------------------------------------------------------------------------\\n    // VARIABLES\\n    uint256 public decimals;\\n    uint256 public totalSupply;\\n    mapping(address => uint256) public balanceOf;\\n    mapping(address => mapping(address => uint256)) public allowance;\\n    mapping(address => uint256) public nonces;\\n\\n    //---------------------------------------------------------------------------\\n    // EVENTS\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                keccak256(bytes(name)),\\n                keccak256(bytes(\\\"1\\\")),\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function _mint(address to, uint256 value) internal {\\n        totalSupply = totalSupply.add(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint256 value) internal {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        totalSupply = totalSupply.sub(value);\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 value\\n    ) private {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) private {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function approve(address spender, uint256 value) external returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 value) external returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool) {\\n        if (allowance[from][msg.sender] != uint256(-1)) {\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(msg.sender, spender, allowance[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(msg.sender, spender, allowance[msg.sender][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        require(deadline >= block.timestamp, \\\"Bridge: EXPIRED\\\");\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n            )\\n        );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"Bridge: INVALID_SIGNATURE\\\");\\n        _approve(owner, spender, value);\\n    }\\n}\\n\",\"keccak256\":\"0xd0ac7dd3767cd0223a26075c43d10bd3866c226f3a43ebc5f5c4b8bc3d21a77e\",\"license\":\"BUSL-1.1\"},\"contracts/Pool.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\n// imports\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"./LPTokenERC20.sol\\\";\\nimport \\\"./interfaces/IStargateFeeLibrary.sol\\\";\\n\\n// libraries\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\n/// Pool contracts on other chains and managed by the Stargate protocol.\\ncontract Pool is LPTokenERC20, ReentrancyGuard {\\n    using SafeMath for uint256;\\n\\n    //---------------------------------------------------------------------------\\n    // CONSTANTS\\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes(\\\"transfer(address,uint256)\\\")));\\n    uint256 public constant BP_DENOMINATOR = 10000;\\n\\n    //---------------------------------------------------------------------------\\n    // STRUCTS\\n    struct ChainPath {\\n        bool ready; // indicate if the counter chainPath has been created.\\n        uint16 dstChainId;\\n        uint256 dstPoolId;\\n        uint256 weight;\\n        uint256 balance;\\n        uint256 lkb;\\n        uint256 credits;\\n        uint256 idealBalance;\\n    }\\n\\n    struct SwapObj {\\n        uint256 amount;\\n        uint256 eqFee;\\n        uint256 eqReward;\\n        uint256 lpFee;\\n        uint256 protocolFee;\\n        uint256 lkbRemove;\\n    }\\n\\n    struct CreditObj {\\n        uint256 credits;\\n        uint256 idealBalance;\\n    }\\n\\n    //---------------------------------------------------------------------------\\n    // VARIABLES\\n\\n    // chainPath\\n    ChainPath[] public chainPaths; // list of connected chains with shared pools\\n    mapping(uint16 => mapping(uint256 => uint256)) public chainPathIndexLookup; // lookup for chainPath by chainId => poolId =>index\\n\\n    // metadata\\n    uint256 public immutable poolId; // shared id between chains to represent same pool\\n    uint256 public sharedDecimals; // the shared decimals (lowest common decimals between chains)\\n    uint256 public localDecimals; // the decimals for the token\\n    uint256 public immutable convertRate; // the decimals for the token\\n    address public immutable token; // the token for the pool\\n    address public immutable router; // the token for the pool\\n\\n    bool public stopSwap; // flag to stop swapping in extreme cases\\n\\n    // Fee and Liquidity\\n    uint256 public totalLiquidity; // the total amount of tokens added on this side of the chain (fees + deposits - withdrawals)\\n    uint256 public totalWeight; // total weight for pool percentages\\n    uint256 public mintFeeBP; // fee basis points for the mint/deposit\\n    uint256 public protocolFeeBalance; // fee balance created from dao fee\\n    uint256 public mintFeeBalance; // fee balance created from mint fee\\n    uint256 public eqFeePool; // pool rewards in Shared Decimal format. indicate the total budget for reverse swap incentive\\n    address public feeLibrary; // address for retrieving fee params for swaps\\n\\n    // Delta related\\n    uint256 public deltaCredit; // credits accumulated from txn\\n    bool public batched; // flag to indicate if we want batch processing.\\n    bool public defaultSwapMode; // flag for the default mode for swap\\n    bool public defaultLPMode; // flag for the default mode for lp\\n    uint256 public swapDeltaBP; // basis points of poolCredits to activate Delta in swap\\n    uint256 public lpDeltaBP; // basis points of poolCredits to activate Delta in liquidity events\\n\\n    //---------------------------------------------------------------------------\\n    // EVENTS\\n    event Mint(address to, uint256 amountLP, uint256 amountSD, uint256 mintFeeAmountSD);\\n    event Burn(address from, uint256 amountLP, uint256 amountSD);\\n    event RedeemLocalCallback(address _to, uint256 _amountSD, uint256 _amountToMintSD);\\n    event Swap(\\n        uint16 chainId,\\n        uint256 dstPoolId,\\n        address from,\\n        uint256 amountSD,\\n        uint256 eqReward,\\n        uint256 eqFee,\\n        uint256 protocolFee,\\n        uint256 lpFee\\n    );\\n    event SendCredits(uint16 dstChainId, uint256 dstPoolId, uint256 credits, uint256 idealBalance);\\n    event RedeemRemote(uint16 chainId, uint256 dstPoolId, address from, uint256 amountLP, uint256 amountSD);\\n    event RedeemLocal(address from, uint256 amountLP, uint256 amountSD, uint16 chainId, uint256 dstPoolId, bytes to);\\n    event InstantRedeemLocal(address from, uint256 amountLP, uint256 amountSD, address to);\\n    event CreditChainPath(uint16 chainId, uint256 srcPoolId, uint256 amountSD, uint256 idealBalance);\\n    event SwapRemote(address to, uint256 amountSD, uint256 protocolFee, uint256 dstFee);\\n    event WithdrawRemote(uint16 srcChainId, uint256 srcPoolId, uint256 swapAmount, uint256 mintAmount);\\n    event ChainPathUpdate(uint16 dstChainId, uint256 dstPoolId, uint256 weight);\\n    event FeesUpdated(uint256 mintFeeBP);\\n    event FeeLibraryUpdated(address feeLibraryAddr);\\n    event StopSwapUpdated(bool swapStop);\\n    event WithdrawProtocolFeeBalance(address to, uint256 amountSD);\\n    event WithdrawMintFeeBalance(address to, uint256 amountSD);\\n    event DeltaParamUpdated(bool batched, uint256 swapDeltaBP, uint256 lpDeltaBP, bool defaultSwapMode, bool defaultLPMode);\\n\\n    //---------------------------------------------------------------------------\\n    // MODIFIERS\\n    modifier onlyRouter() {\\n        require(msg.sender == router, \\\"Stargate: only the router can call this method\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        uint256 _poolId,\\n        address _router,\\n        address _token,\\n        uint256 _sharedDecimals,\\n        uint256 _localDecimals,\\n        address _feeLibrary,\\n        string memory _name,\\n        string memory _symbol\\n    ) LPTokenERC20(_name, _symbol) {\\n        require(_token != address(0x0), \\\"Stargate: _token cannot be 0x0\\\");\\n        require(_router != address(0x0), \\\"Stargate: _router cannot be 0x0\\\");\\n        poolId = _poolId;\\n        router = _router;\\n        token = _token;\\n        sharedDecimals = _sharedDecimals;\\n        decimals = uint8(_sharedDecimals);\\n        localDecimals = _localDecimals;\\n        convertRate = 10**(uint256(localDecimals).sub(sharedDecimals));\\n        totalWeight = 0;\\n        feeLibrary = _feeLibrary;\\n\\n        //delta algo related\\n        batched = false;\\n        defaultSwapMode = true;\\n        defaultLPMode = true;\\n    }\\n\\n    function getChainPathsLength() public view returns (uint256) {\\n        return chainPaths.length;\\n    }\\n\\n    //---------------------------------------------------------------------------\\n    // LOCAL CHAIN FUNCTIONS\\n\\n    function mint(address _to, uint256 _amountLD) external nonReentrant onlyRouter returns (uint256) {\\n        return _mintLocal(_to, _amountLD, true, true);\\n    }\\n\\n    // Local                                    Remote\\n    // -------                                  ---------\\n    // swap             ->                      swapRemote\\n    function swap(\\n        uint16 _dstChainId,\\n        uint256 _dstPoolId,\\n        address _from,\\n        uint256 _amountLD,\\n        uint256 _minAmountLD,\\n        bool newLiquidity\\n    ) external nonReentrant onlyRouter returns (SwapObj memory) {\\n        require(!stopSwap, \\\"Stargate: swap func stopped\\\");\\n        ChainPath storage cp = getAndCheckCP(_dstChainId, _dstPoolId);\\n        require(cp.ready == true, \\\"Stargate: counter chainPath is not ready\\\");\\n\\n        uint256 amountSD = amountLDtoSD(_amountLD);\\n        uint256 minAmountSD = amountLDtoSD(_minAmountLD);\\n\\n        // request fee params from library\\n        SwapObj memory s = IStargateFeeLibrary(feeLibrary).getFees(poolId, _dstPoolId, _dstChainId, _from, amountSD);\\n\\n        // equilibrium fee and reward. note eqFee/eqReward are separated from swap liquidity\\n        eqFeePool = eqFeePool.sub(s.eqReward);\\n        // update the new amount the user gets minus the fees\\n        s.amount = amountSD.sub(s.eqFee).sub(s.protocolFee).sub(s.lpFee);\\n        // users will also get the eqReward\\n        require(s.amount.add(s.eqReward) >= minAmountSD, \\\"Stargate: slippage too high\\\");\\n\\n        // behaviours\\n        //     - protocolFee: booked, stayed and withdrawn at remote.\\n        //     - eqFee: booked, stayed and withdrawn at remote.\\n        //     - lpFee: booked and stayed at remote, can be withdrawn anywhere\\n\\n        s.lkbRemove = amountSD.sub(s.lpFee).add(s.eqReward);\\n        // check for transfer solvency.\\n        require(cp.balance >= s.lkbRemove, \\\"Stargate: dst balance too low\\\");\\n        cp.balance = cp.balance.sub(s.lkbRemove);\\n\\n        if (newLiquidity) {\\n            deltaCredit = deltaCredit.add(amountSD).add(s.eqReward);\\n        } else if (s.eqReward > 0) {\\n            deltaCredit = deltaCredit.add(s.eqReward);\\n        }\\n\\n        // distribute credits on condition.\\n        if (!batched || deltaCredit >= totalLiquidity.mul(swapDeltaBP).div(BP_DENOMINATOR)) {\\n            _delta(defaultSwapMode);\\n        }\\n\\n        emit Swap(_dstChainId, _dstPoolId, _from, s.amount, s.eqReward, s.eqFee, s.protocolFee, s.lpFee);\\n        return s;\\n    }\\n\\n    // Local                                    Remote\\n    // -------                                  ---------\\n    // sendCredits      ->                      creditChainPath\\n    function sendCredits(uint16 _dstChainId, uint256 _dstPoolId) external nonReentrant onlyRouter returns (CreditObj memory c) {\\n        ChainPath storage cp = getAndCheckCP(_dstChainId, _dstPoolId);\\n        require(cp.ready == true, \\\"Stargate: counter chainPath is not ready\\\");\\n        cp.lkb = cp.lkb.add(cp.credits);\\n        c.idealBalance = totalLiquidity.mul(cp.weight).div(totalWeight);\\n        c.credits = cp.credits;\\n        cp.credits = 0;\\n        emit SendCredits(_dstChainId, _dstPoolId, c.credits, c.idealBalance);\\n    }\\n\\n    // Local                                    Remote\\n    // -------                                  ---------\\n    // redeemRemote   ->                        swapRemote\\n    function redeemRemote(\\n        uint16 _dstChainId,\\n        uint256 _dstPoolId,\\n        address _from,\\n        uint256 _amountLP\\n    ) external nonReentrant onlyRouter {\\n        require(_from != address(0x0), \\\"Stargate: _from cannot be 0x0\\\");\\n        uint256 amountSD = _burnLocal(_from, _amountLP);\\n        //run Delta\\n        if (!batched || deltaCredit > totalLiquidity.mul(lpDeltaBP).div(BP_DENOMINATOR)) {\\n            _delta(defaultLPMode);\\n        }\\n        uint256 amountLD = amountSDtoLD(amountSD);\\n        emit RedeemRemote(_dstChainId, _dstPoolId, _from, _amountLP, amountLD);\\n    }\\n\\n    function instantRedeemLocal(\\n        address _from,\\n        uint256 _amountLP,\\n        address _to\\n    ) external nonReentrant onlyRouter returns (uint256 amountSD) {\\n        require(_from != address(0x0), \\\"Stargate: _from cannot be 0x0\\\");\\n        uint256 _deltaCredit = deltaCredit; // sload optimization.\\n        uint256 _capAmountLP = _amountSDtoLP(_deltaCredit);\\n\\n        if (_amountLP > _capAmountLP) _amountLP = _capAmountLP;\\n\\n        amountSD = _burnLocal(_from, _amountLP);\\n        deltaCredit = _deltaCredit.sub(amountSD);\\n        uint256 amountLD = amountSDtoLD(amountSD);\\n        _safeTransfer(token, _to, amountLD);\\n        emit InstantRedeemLocal(_from, _amountLP, amountSD, _to);\\n    }\\n\\n    // Local                                    Remote\\n    // -------                                  ---------\\n    // redeemLocal   ->                         redeemLocalCheckOnRemote\\n    // redeemLocalCallback             <-\\n    function redeemLocal(\\n        address _from,\\n        uint256 _amountLP,\\n        uint16 _dstChainId,\\n        uint256 _dstPoolId,\\n        bytes calldata _to\\n    ) external nonReentrant onlyRouter returns (uint256 amountSD) {\\n        require(_from != address(0x0), \\\"Stargate: _from cannot be 0x0\\\");\\n\\n        // safeguard.\\n        require(chainPaths[chainPathIndexLookup[_dstChainId][_dstPoolId]].ready == true, \\\"Stargate: counter chainPath is not ready\\\");\\n        amountSD = _burnLocal(_from, _amountLP);\\n\\n        // run Delta\\n        if (!batched || deltaCredit > totalLiquidity.mul(lpDeltaBP).div(BP_DENOMINATOR)) {\\n            _delta(false);\\n        }\\n        emit RedeemLocal(_from, _amountLP, amountSD, _dstChainId, _dstPoolId, _to);\\n    }\\n\\n    //---------------------------------------------------------------------------\\n    // REMOTE CHAIN FUNCTIONS\\n\\n    // Local                                    Remote\\n    // -------                                  ---------\\n    // sendCredits      ->                      creditChainPath\\n    function creditChainPath(\\n        uint16 _dstChainId,\\n        uint256 _dstPoolId,\\n        CreditObj memory _c\\n    ) external nonReentrant onlyRouter {\\n        ChainPath storage cp = chainPaths[chainPathIndexLookup[_dstChainId][_dstPoolId]];\\n        cp.balance = cp.balance.add(_c.credits);\\n        if (cp.idealBalance != _c.idealBalance) {\\n            cp.idealBalance = _c.idealBalance;\\n        }\\n        emit CreditChainPath(_dstChainId, _dstPoolId, _c.credits, _c.idealBalance);\\n    }\\n\\n    // Local                                    Remote\\n    // -------                                  ---------\\n    // swap             ->                      swapRemote\\n    function swapRemote(\\n        uint16 _srcChainId,\\n        uint256 _srcPoolId,\\n        address _to,\\n        SwapObj memory _s\\n    ) external nonReentrant onlyRouter returns (uint256 amountLD) {\\n        // booking lpFee\\n        totalLiquidity = totalLiquidity.add(_s.lpFee);\\n        // booking eqFee\\n        eqFeePool = eqFeePool.add(_s.eqFee);\\n        // booking stargateFee\\n        protocolFeeBalance = protocolFeeBalance.add(_s.protocolFee);\\n\\n        // update LKB\\n        uint256 chainPathIndex = chainPathIndexLookup[_srcChainId][_srcPoolId];\\n        chainPaths[chainPathIndex].lkb = chainPaths[chainPathIndex].lkb.sub(_s.lkbRemove);\\n\\n        // user receives the amount + the srcReward\\n        amountLD = amountSDtoLD(_s.amount.add(_s.eqReward));\\n        _safeTransfer(token, _to, amountLD);\\n        emit SwapRemote(_to, _s.amount.add(_s.eqReward), _s.protocolFee, _s.eqFee);\\n    }\\n\\n    // Local                                    Remote\\n    // -------                                  ---------\\n    // redeemLocal   ->                         redeemLocalCheckOnRemote\\n    // redeemLocalCallback             <-\\n    function redeemLocalCallback(\\n        uint16 _srcChainId,\\n        uint256 _srcPoolId,\\n        address _to,\\n        uint256 _amountSD,\\n        uint256 _amountToMintSD\\n    ) external nonReentrant onlyRouter {\\n        if (_amountToMintSD > 0) {\\n            _mintLocal(_to, amountSDtoLD(_amountToMintSD), false, false);\\n        }\\n\\n        ChainPath storage cp = getAndCheckCP(_srcChainId, _srcPoolId);\\n        cp.lkb = cp.lkb.sub(_amountSD);\\n\\n        uint256 amountLD = amountSDtoLD(_amountSD);\\n        _safeTransfer(token, _to, amountLD);\\n        emit RedeemLocalCallback(_to, _amountSD, _amountToMintSD);\\n    }\\n\\n    // Local                                    Remote\\n    // -------                                  ---------\\n    // redeemLocal(amount)   ->               redeemLocalCheckOnRemote\\n    // redeemLocalCallback             <-\\n    function redeemLocalCheckOnRemote(\\n        uint16 _srcChainId,\\n        uint256 _srcPoolId,\\n        uint256 _amountSD\\n    ) external nonReentrant onlyRouter returns (uint256 swapAmount, uint256 mintAmount) {\\n        ChainPath storage cp = getAndCheckCP(_srcChainId, _srcPoolId);\\n        if (_amountSD > cp.balance) {\\n            mintAmount = _amountSD - cp.balance;\\n            swapAmount = cp.balance;\\n            cp.balance = 0;\\n        } else {\\n            cp.balance = cp.balance.sub(_amountSD);\\n            swapAmount = _amountSD;\\n            mintAmount = 0;\\n        }\\n        emit WithdrawRemote(_srcChainId, _srcPoolId, swapAmount, mintAmount);\\n    }\\n\\n    //---------------------------------------------------------------------------\\n    // DAO Calls\\n    function createChainPath(\\n        uint16 _dstChainId,\\n        uint256 _dstPoolId,\\n        uint256 _weight\\n    ) external onlyRouter {\\n        for (uint256 i = 0; i < chainPaths.length; ++i) {\\n            ChainPath memory cp = chainPaths[i];\\n            bool exists = cp.dstChainId == _dstChainId && cp.dstPoolId == _dstPoolId;\\n            require(!exists, \\\"Stargate: cant createChainPath of existing dstChainId and _dstPoolId\\\");\\n        }\\n        totalWeight = totalWeight.add(_weight);\\n        chainPathIndexLookup[_dstChainId][_dstPoolId] = chainPaths.length;\\n        chainPaths.push(ChainPath(false, _dstChainId, _dstPoolId, _weight, 0, 0, 0, 0));\\n        emit ChainPathUpdate(_dstChainId, _dstPoolId, _weight);\\n    }\\n\\n    function setWeightForChainPath(\\n        uint16 _dstChainId,\\n        uint256 _dstPoolId,\\n        uint16 _weight\\n    ) external onlyRouter {\\n        ChainPath storage cp = getAndCheckCP(_dstChainId, _dstPoolId);\\n        totalWeight = totalWeight.sub(cp.weight).add(_weight);\\n        cp.weight = _weight;\\n        emit ChainPathUpdate(_dstChainId, _dstPoolId, _weight);\\n    }\\n\\n    function setFee(uint256 _mintFeeBP) external onlyRouter {\\n        require(_mintFeeBP <= BP_DENOMINATOR, \\\"Bridge: cum fees > 100%\\\");\\n        mintFeeBP = _mintFeeBP;\\n        emit FeesUpdated(mintFeeBP);\\n    }\\n\\n    function setFeeLibrary(address _feeLibraryAddr) external onlyRouter {\\n        require(_feeLibraryAddr != address(0x0), \\\"Stargate: fee library cant be 0x0\\\");\\n        feeLibrary = _feeLibraryAddr;\\n        emit FeeLibraryUpdated(_feeLibraryAddr);\\n    }\\n\\n    function setSwapStop(bool _swapStop) external onlyRouter {\\n        stopSwap = _swapStop;\\n        emit StopSwapUpdated(_swapStop);\\n    }\\n\\n    function setDeltaParam(\\n        bool _batched,\\n        uint256 _swapDeltaBP,\\n        uint256 _lpDeltaBP,\\n        bool _defaultSwapMode,\\n        bool _defaultLPMode\\n    ) external onlyRouter {\\n        require(_swapDeltaBP <= BP_DENOMINATOR && _lpDeltaBP <= BP_DENOMINATOR, \\\"Stargate: wrong Delta param\\\");\\n        batched = _batched;\\n        swapDeltaBP = _swapDeltaBP;\\n        lpDeltaBP = _lpDeltaBP;\\n        defaultSwapMode = _defaultSwapMode;\\n        defaultLPMode = _defaultLPMode;\\n        emit DeltaParamUpdated(_batched, _swapDeltaBP, _lpDeltaBP, _defaultSwapMode, _defaultLPMode);\\n    }\\n\\n    function callDelta(bool _fullMode) external onlyRouter {\\n        _delta(_fullMode);\\n    }\\n\\n    function activateChainPath(uint16 _dstChainId, uint256 _dstPoolId) external onlyRouter {\\n        ChainPath storage cp = getAndCheckCP(_dstChainId, _dstPoolId);\\n        require(cp.ready == false, \\\"Stargate: chainPath is already active\\\");\\n        // this func will only be called once\\n        cp.ready = true;\\n    }\\n\\n    function withdrawProtocolFeeBalance(address _to) external onlyRouter {\\n        if (protocolFeeBalance > 0) {\\n            uint256 amountOfLD = amountSDtoLD(protocolFeeBalance);\\n            protocolFeeBalance = 0;\\n            _safeTransfer(token, _to, amountOfLD);\\n            emit WithdrawProtocolFeeBalance(_to, amountOfLD);\\n        }\\n    }\\n\\n    function withdrawMintFeeBalance(address _to) external onlyRouter {\\n        if (mintFeeBalance > 0) {\\n            uint256 amountOfLD = amountSDtoLD(mintFeeBalance);\\n            mintFeeBalance = 0;\\n            _safeTransfer(token, _to, amountOfLD);\\n            emit WithdrawMintFeeBalance(_to, amountOfLD);\\n        }\\n    }\\n\\n    //---------------------------------------------------------------------------\\n    // INTERNAL\\n    // Conversion Helpers\\n    //---------------------------------------------------------------------------\\n    function amountLPtoLD(uint256 _amountLP) external view returns (uint256) {\\n        return amountSDtoLD(_amountLPtoSD(_amountLP));\\n    }\\n\\n    function _amountLPtoSD(uint256 _amountLP) internal view returns (uint256) {\\n        require(totalSupply > 0, \\\"Stargate: cant convert LPtoSD when totalSupply == 0\\\");\\n        return _amountLP.mul(totalLiquidity).div(totalSupply);\\n    }\\n\\n    function _amountSDtoLP(uint256 _amountSD) internal view returns (uint256) {\\n        require(totalLiquidity > 0, \\\"Stargate: cant convert SDtoLP when totalLiq == 0\\\");\\n        return _amountSD.mul(totalSupply).div(totalLiquidity);\\n    }\\n\\n    function amountSDtoLD(uint256 _amount) internal view returns (uint256) {\\n        return _amount.mul(convertRate);\\n    }\\n\\n    function amountLDtoSD(uint256 _amount) internal view returns (uint256) {\\n        return _amount.div(convertRate);\\n    }\\n\\n    function getAndCheckCP(uint16 _dstChainId, uint256 _dstPoolId) internal view returns (ChainPath storage) {\\n        require(chainPaths.length > 0, \\\"Stargate: no chainpaths exist\\\");\\n        ChainPath storage cp = chainPaths[chainPathIndexLookup[_dstChainId][_dstPoolId]];\\n        require(cp.dstChainId == _dstChainId && cp.dstPoolId == _dstPoolId, \\\"Stargate: local chainPath does not exist\\\");\\n        return cp;\\n    }\\n\\n    function getChainPath(uint16 _dstChainId, uint256 _dstPoolId) external view returns (ChainPath memory) {\\n        ChainPath memory cp = chainPaths[chainPathIndexLookup[_dstChainId][_dstPoolId]];\\n        require(cp.dstChainId == _dstChainId && cp.dstPoolId == _dstPoolId, \\\"Stargate: local chainPath does not exist\\\");\\n        return cp;\\n    }\\n\\n    function _burnLocal(address _from, uint256 _amountLP) internal returns (uint256) {\\n        require(totalSupply > 0, \\\"Stargate: cant burn when totalSupply == 0\\\");\\n        uint256 amountOfLPTokens = balanceOf[_from];\\n        require(amountOfLPTokens >= _amountLP, \\\"Stargate: not enough LP tokens to burn\\\");\\n\\n        uint256 amountSD = _amountLP.mul(totalLiquidity).div(totalSupply);\\n        //subtract totalLiquidity accordingly\\n        totalLiquidity = totalLiquidity.sub(amountSD);\\n\\n        _burn(_from, _amountLP);\\n        emit Burn(_from, _amountLP, amountSD);\\n        return amountSD;\\n    }\\n\\n    function _delta(bool fullMode) internal {\\n        if (deltaCredit > 0 && totalWeight > 0) {\\n            uint256 cpLength = chainPaths.length;\\n            uint256[] memory deficit = new uint256[](cpLength);\\n            uint256 totalDeficit = 0;\\n\\n            // algorithm steps 6-9: calculate the total and the amounts required to get to balance state\\n            for (uint256 i = 0; i < cpLength; ++i) {\\n                ChainPath storage cp = chainPaths[i];\\n                // (liquidity * (weight/totalWeight)) - (lkb+credits)\\n                uint256 balLiq = totalLiquidity.mul(cp.weight).div(totalWeight);\\n                uint256 currLiq = cp.lkb.add(cp.credits);\\n                if (balLiq > currLiq) {\\n                    // save gas since we know balLiq > currLiq and we know deficit[i] > 0\\n                    deficit[i] = balLiq - currLiq;\\n                    totalDeficit = totalDeficit.add(deficit[i]);\\n                }\\n            }\\n\\n            // indicates how much delta credit is distributed\\n            uint256 spent;\\n\\n            // handle credits with 2 tranches. the [ < totalDeficit] [excessCredit]\\n            // run full Delta, allocate all credits\\n            if (totalDeficit == 0) {\\n                // only fullMode delta will allocate excess credits\\n                if (fullMode && deltaCredit > 0) {\\n                    // credit ChainPath by weights\\n                    for (uint256 i = 0; i < cpLength; ++i) {\\n                        ChainPath storage cp = chainPaths[i];\\n                        // credits = credits + toBalanceChange + remaining allocation based on weight\\n                        uint256 amtToCredit = deltaCredit.mul(cp.weight).div(totalWeight);\\n                        spent = spent.add(amtToCredit);\\n                        cp.credits = cp.credits.add(amtToCredit);\\n                    }\\n                } // else do nth\\n            } else if (totalDeficit <= deltaCredit) {\\n                if (fullMode) {\\n                    // algorithm step 13: calculate amount to disperse to bring to balance state or as close as possible\\n                    uint256 excessCredit = deltaCredit - totalDeficit;\\n                    // algorithm steps 14-16: calculate credits\\n                    for (uint256 i = 0; i < cpLength; ++i) {\\n                        if (deficit[i] > 0) {\\n                            ChainPath storage cp = chainPaths[i];\\n                            // credits = credits + deficit + remaining allocation based on weight\\n                            uint256 amtToCredit = deficit[i].add(excessCredit.mul(cp.weight).div(totalWeight));\\n                            spent = spent.add(amtToCredit);\\n                            cp.credits = cp.credits.add(amtToCredit);\\n                        }\\n                    }\\n                } else {\\n                    // totalDeficit <= deltaCredit but not running fullMode\\n                    // credit chainPaths as is if any deficit, not using all deltaCredit\\n                    for (uint256 i = 0; i < cpLength; ++i) {\\n                        if (deficit[i] > 0) {\\n                            ChainPath storage cp = chainPaths[i];\\n                            uint256 amtToCredit = deficit[i];\\n                            spent = spent.add(amtToCredit);\\n                            cp.credits = cp.credits.add(amtToCredit);\\n                        }\\n                    }\\n                }\\n            } else {\\n                // totalDeficit > deltaCredit, fullMode or not, normalize the deficit by deltaCredit\\n                for (uint256 i = 0; i < cpLength; ++i) {\\n                    if (deficit[i] > 0) {\\n                        ChainPath storage cp = chainPaths[i];\\n                        uint256 proportionalDeficit = deficit[i].mul(deltaCredit).div(totalDeficit);\\n                        spent = spent.add(proportionalDeficit);\\n                        cp.credits = cp.credits.add(proportionalDeficit);\\n                    }\\n                }\\n            }\\n\\n            // deduct the amount of credit sent\\n            deltaCredit = deltaCredit.sub(spent);\\n        }\\n    }\\n\\n    function _mintLocal(\\n        address _to,\\n        uint256 _amountLD,\\n        bool _feesEnabled,\\n        bool _creditDelta\\n    ) internal returns (uint256 amountSD) {\\n        require(totalWeight > 0, \\\"Stargate: No ChainPaths exist\\\");\\n        amountSD = amountLDtoSD(_amountLD);\\n\\n        uint256 mintFeeSD = 0;\\n        if (_feesEnabled) {\\n            mintFeeSD = amountSD.mul(mintFeeBP).div(BP_DENOMINATOR);\\n            amountSD = amountSD.sub(mintFeeSD);\\n            mintFeeBalance = mintFeeBalance.add(mintFeeSD);\\n        }\\n\\n        if (_creditDelta) {\\n            deltaCredit = deltaCredit.add(amountSD);\\n        }\\n\\n        uint256 amountLPTokens = amountSD;\\n        if (totalSupply != 0) {\\n            amountLPTokens = amountSD.mul(totalSupply).div(totalLiquidity);\\n        }\\n        totalLiquidity = totalLiquidity.add(amountSD);\\n\\n        _mint(_to, amountLPTokens);\\n        emit Mint(_to, amountLPTokens, amountSD, mintFeeSD);\\n\\n        // add to credits and call delta. short circuit to save gas\\n        if (!batched || deltaCredit > totalLiquidity.mul(lpDeltaBP).div(BP_DENOMINATOR)) {\\n            _delta(defaultLPMode);\\n        }\\n    }\\n\\n    function _safeTransfer(\\n        address _token,\\n        address _to,\\n        uint256 _value\\n    ) private {\\n        (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(SELECTOR, _to, _value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"Stargate: TRANSFER_FAILED\\\");\\n    }\\n}\\n\",\"keccak256\":\"0xff0ac7ffc5a5813fb1bce42222d7199f05546fb4b12f55fc3791b6607533f820\",\"license\":\"BUSL-1.1\"},\"contracts/Router.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\n// imports\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"./Factory.sol\\\";\\nimport \\\"./Pool.sol\\\";\\nimport \\\"./Bridge.sol\\\";\\n\\n// interfaces\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./interfaces/IStargateRouter.sol\\\";\\nimport \\\"./interfaces/IStargateReceiver.sol\\\";\\n\\n// libraries\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\ncontract Router is IStargateRouter, Ownable, ReentrancyGuard {\\n    using SafeMath for uint256;\\n\\n    //---------------------------------------------------------------------------\\n    // CONSTANTS\\n    uint8 internal constant TYPE_REDEEM_LOCAL_RESPONSE = 1;\\n    uint8 internal constant TYPE_REDEEM_LOCAL_CALLBACK_RETRY = 2;\\n    uint8 internal constant TYPE_SWAP_REMOTE_RETRY = 3;\\n\\n    //---------------------------------------------------------------------------\\n    // STRUCTS\\n    struct CachedSwap {\\n        address token;\\n        uint256 amountLD;\\n        address to;\\n        bytes payload;\\n    }\\n\\n    //---------------------------------------------------------------------------\\n    // VARIABLES\\n    Factory public factory; // used for creating pools\\n    address public protocolFeeOwner; // can call methods to pull Stargate fees collected in pools\\n    address public mintFeeOwner; // can call methods to pull mint fees collected in pools\\n    Bridge public bridge;\\n    mapping(uint16 => mapping(bytes => mapping(uint256 => bytes))) public revertLookup; //[chainId][srcAddress][nonce]\\n    mapping(uint16 => mapping(bytes => mapping(uint256 => CachedSwap))) public cachedSwapLookup; //[chainId][srcAddress][nonce]\\n\\n    //---------------------------------------------------------------------------\\n    // EVENTS\\n    event Revert(uint8 bridgeFunctionType, uint16 chainId, bytes srcAddress, uint256 nonce);\\n    event CachedSwapSaved(\\n        uint16 chainId,\\n        bytes srcAddress,\\n        uint256 nonce,\\n        address token,\\n        uint256 amountLD,\\n        address to,\\n        bytes payload,\\n        bytes reason\\n    );\\n    event RevertRedeemLocal(\\n        uint16 srcChainId,\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        bytes to,\\n        uint256 redeemAmountSD,\\n        uint256 mintAmountSD,\\n        uint256 indexed nonce,\\n        bytes indexed srcAddress\\n    );\\n    event RedeemLocalCallback(\\n        uint16 srcChainId,\\n        bytes indexed srcAddress,\\n        uint256 indexed nonce,\\n        uint256 srcPoolId,\\n        uint256 dstPoolId,\\n        address to,\\n        uint256 amountSD,\\n        uint256 mintAmountSD\\n    );\\n\\n    //---------------------------------------------------------------------------\\n    // MODIFIERS\\n    modifier onlyBridge() {\\n        require(msg.sender == address(bridge), \\\"Bridge: caller must be Bridge.\\\");\\n        _;\\n    }\\n\\n    constructor() {}\\n\\n    function setBridgeAndFactory(Bridge _bridge, Factory _factory) external onlyOwner {\\n        require(address(bridge) == address(0x0) && address(factory) == address(0x0), \\\"Stargate: bridge and factory already initialized\\\"); // 1 time only\\n        require(address(_bridge) != address(0x0), \\\"Stargate: bridge cant be 0x0\\\");\\n        require(address(_factory) != address(0x0), \\\"Stargate: factory cant be 0x0\\\");\\n\\n        bridge = _bridge;\\n        factory = _factory;\\n    }\\n\\n    //---------------------------------------------------------------------------\\n    // VIEWS\\n    function _getPool(uint256 _poolId) internal view returns (Pool pool) {\\n        pool = factory.getPool(_poolId);\\n        require(address(pool) != address(0x0), \\\"Stargate: Pool does not exist\\\");\\n    }\\n\\n    //---------------------------------------------------------------------------\\n    // INTERNAL\\n    function _safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) private {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"Stargate: TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    //---------------------------------------------------------------------------\\n    // LOCAL CHAIN FUNCTIONS\\n    function addLiquidity(\\n        uint256 _poolId,\\n        uint256 _amountLD,\\n        address _to\\n    ) external override nonReentrant {\\n        Pool pool = _getPool(_poolId);\\n        uint256 convertRate = pool.convertRate();\\n        _amountLD = _amountLD.div(convertRate).mul(convertRate);\\n        _safeTransferFrom(pool.token(), msg.sender, address(pool), _amountLD);\\n        pool.mint(_to, _amountLD);\\n    }\\n\\n    function swap(\\n        uint16 _dstChainId,\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        address payable _refundAddress,\\n        uint256 _amountLD,\\n        uint256 _minAmountLD,\\n        lzTxObj memory _lzTxParams,\\n        bytes calldata _to,\\n        bytes calldata _payload\\n    ) external payable override nonReentrant {\\n        require(_amountLD > 0, \\\"Stargate: cannot swap 0\\\");\\n        require(_refundAddress != address(0x0), \\\"Stargate: _refundAddress cannot be 0x0\\\");\\n        Pool.SwapObj memory s;\\n        Pool.CreditObj memory c;\\n        {\\n            Pool pool = _getPool(_srcPoolId);\\n            {\\n                uint256 convertRate = pool.convertRate();\\n                _amountLD = _amountLD.div(convertRate).mul(convertRate);\\n            }\\n\\n            s = pool.swap(_dstChainId, _dstPoolId, msg.sender, _amountLD, _minAmountLD, true);\\n            _safeTransferFrom(pool.token(), msg.sender, address(pool), _amountLD);\\n            c = pool.sendCredits(_dstChainId, _dstPoolId);\\n        }\\n        bridge.swap{value: msg.value}(_dstChainId, _srcPoolId, _dstPoolId, _refundAddress, c, s, _lzTxParams, _to, _payload);\\n    }\\n\\n    function redeemRemote(\\n        uint16 _dstChainId,\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        address payable _refundAddress,\\n        uint256 _amountLP,\\n        uint256 _minAmountLD,\\n        bytes calldata _to,\\n        lzTxObj memory _lzTxParams\\n    ) external payable override nonReentrant {\\n        require(_refundAddress != address(0x0), \\\"Stargate: _refundAddress cannot be 0x0\\\");\\n        require(_amountLP > 0, \\\"Stargate: not enough lp to redeemRemote\\\");\\n        Pool.SwapObj memory s;\\n        Pool.CreditObj memory c;\\n        {\\n            Pool pool = _getPool(_srcPoolId);\\n            uint256 amountLD = pool.amountLPtoLD(_amountLP);\\n            // perform a swap with no liquidity\\n            s = pool.swap(_dstChainId, _dstPoolId, msg.sender, amountLD, _minAmountLD, false);\\n            pool.redeemRemote(_dstChainId, _dstPoolId, msg.sender, _amountLP);\\n            c = pool.sendCredits(_dstChainId, _dstPoolId);\\n        }\\n        // equal to a swap, with no payload (\\\"0x\\\") no dstGasForCall 0\\n        bridge.swap{value: msg.value}(_dstChainId, _srcPoolId, _dstPoolId, _refundAddress, c, s, _lzTxParams, _to, \\\"\\\");\\n    }\\n\\n    function instantRedeemLocal(\\n        uint16 _srcPoolId,\\n        uint256 _amountLP,\\n        address _to\\n    ) external override nonReentrant returns (uint256 amountSD) {\\n        require(_amountLP > 0, \\\"Stargate: not enough lp to redeem\\\");\\n        Pool pool = _getPool(_srcPoolId);\\n        amountSD = pool.instantRedeemLocal(msg.sender, _amountLP, _to);\\n    }\\n\\n    function redeemLocal(\\n        uint16 _dstChainId,\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        address payable _refundAddress,\\n        uint256 _amountLP,\\n        bytes calldata _to,\\n        lzTxObj memory _lzTxParams\\n    ) external payable override nonReentrant {\\n        require(_refundAddress != address(0x0), \\\"Stargate: _refundAddress cannot be 0x0\\\");\\n        Pool pool = _getPool(_srcPoolId);\\n        require(_amountLP > 0, \\\"Stargate: not enough lp to redeem\\\");\\n        uint256 amountSD = pool.redeemLocal(msg.sender, _amountLP, _dstChainId, _dstPoolId, _to);\\n        require(amountSD > 0, \\\"Stargate: not enough lp to redeem with amountSD\\\");\\n\\n        Pool.CreditObj memory c = pool.sendCredits(_dstChainId, _dstPoolId);\\n        bridge.redeemLocal{value: msg.value}(_dstChainId, _srcPoolId, _dstPoolId, _refundAddress, c, amountSD, _to, _lzTxParams);\\n    }\\n\\n    function sendCredits(\\n        uint16 _dstChainId,\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        address payable _refundAddress\\n    ) external payable override nonReentrant {\\n        require(_refundAddress != address(0x0), \\\"Stargate: _refundAddress cannot be 0x0\\\");\\n        Pool pool = _getPool(_srcPoolId);\\n        Pool.CreditObj memory c = pool.sendCredits(_dstChainId, _dstPoolId);\\n        bridge.sendCredits{value: msg.value}(_dstChainId, _srcPoolId, _dstPoolId, _refundAddress, c);\\n    }\\n\\n    function quoteLayerZeroFee(\\n        uint16 _dstChainId,\\n        uint8 _functionType,\\n        bytes calldata _toAddress,\\n        bytes calldata _transferAndCallPayload,\\n        Router.lzTxObj memory _lzTxParams\\n    ) external view override returns (uint256, uint256) {\\n        return bridge.quoteLayerZeroFee(_dstChainId, _functionType, _toAddress, _transferAndCallPayload, _lzTxParams);\\n    }\\n\\n    function revertRedeemLocal(\\n        uint16 _dstChainId,\\n        bytes calldata _srcAddress,\\n        uint256 _nonce,\\n        address payable _refundAddress,\\n        lzTxObj memory _lzTxParams\\n    ) external payable {\\n        require(_refundAddress != address(0x0), \\\"Stargate: _refundAddress cannot be 0x0\\\");\\n        bytes memory payload = revertLookup[_dstChainId][_srcAddress][_nonce];\\n        require(payload.length > 0, \\\"Stargate: no retry revert\\\");\\n        {\\n            uint8 functionType;\\n            assembly {\\n                functionType := mload(add(payload, 32))\\n            }\\n            require(functionType == TYPE_REDEEM_LOCAL_RESPONSE, \\\"Stargate: invalid function type\\\");\\n        }\\n\\n        // empty it\\n        revertLookup[_dstChainId][_srcAddress][_nonce] = \\\"\\\";\\n\\n        uint256 srcPoolId;\\n        uint256 dstPoolId;\\n        assembly {\\n            srcPoolId := mload(add(payload, 64))\\n            dstPoolId := mload(add(payload, 96))\\n        }\\n\\n        Pool.CreditObj memory c;\\n        {\\n            Pool pool = _getPool(dstPoolId);\\n            c = pool.sendCredits(_dstChainId, srcPoolId);\\n        }\\n\\n        bridge.redeemLocalCallback{value: msg.value}(_dstChainId, _refundAddress, c, _lzTxParams, payload);\\n    }\\n\\n    function retryRevert(\\n        uint16 _srcChainId,\\n        bytes calldata _srcAddress,\\n        uint256 _nonce\\n    ) external payable {\\n        bytes memory payload = revertLookup[_srcChainId][_srcAddress][_nonce];\\n        require(payload.length > 0, \\\"Stargate: no retry revert\\\");\\n\\n        // empty it\\n        revertLookup[_srcChainId][_srcAddress][_nonce] = \\\"\\\";\\n\\n        uint8 functionType;\\n        assembly {\\n            functionType := mload(add(payload, 32))\\n        }\\n\\n        if (functionType == TYPE_REDEEM_LOCAL_CALLBACK_RETRY) {\\n            (, uint256 srcPoolId, uint256 dstPoolId, address to, uint256 amountSD, uint256 mintAmountSD) = abi.decode(\\n                payload,\\n                (uint8, uint256, uint256, address, uint256, uint256)\\n            );\\n            _redeemLocalCallback(_srcChainId, _srcAddress, _nonce, srcPoolId, dstPoolId, to, amountSD, mintAmountSD);\\n        }\\n        // for retrying the swapRemote. if it fails again, retry\\n        else if (functionType == TYPE_SWAP_REMOTE_RETRY) {\\n            (, uint256 srcPoolId, uint256 dstPoolId, uint256 dstGasForCall, address to, Pool.SwapObj memory s, bytes memory p) = abi.decode(\\n                payload,\\n                (uint8, uint256, uint256, uint256, address, Pool.SwapObj, bytes)\\n            );\\n            _swapRemote(_srcChainId, _srcAddress, _nonce, srcPoolId, dstPoolId, dstGasForCall, to, s, p);\\n        } else {\\n            revert(\\\"Stargate: invalid function type\\\");\\n        }\\n    }\\n\\n    function clearCachedSwap(\\n        uint16 _srcChainId,\\n        bytes calldata _srcAddress,\\n        uint256 _nonce\\n    ) external {\\n        CachedSwap memory cs = cachedSwapLookup[_srcChainId][_srcAddress][_nonce];\\n        require(cs.to != address(0x0), \\\"Stargate: cache already cleared\\\");\\n        // clear the data\\n        cachedSwapLookup[_srcChainId][_srcAddress][_nonce] = CachedSwap(address(0x0), 0, address(0x0), \\\"\\\");\\n        IStargateReceiver(cs.to).sgReceive(_srcChainId, _srcAddress, _nonce, cs.token, cs.amountLD, cs.payload);\\n    }\\n\\n    function creditChainPath(\\n        uint16 _dstChainId,\\n        uint256 _dstPoolId,\\n        uint256 _srcPoolId,\\n        Pool.CreditObj memory _c\\n    ) external onlyBridge {\\n        Pool pool = _getPool(_srcPoolId);\\n        pool.creditChainPath(_dstChainId, _dstPoolId, _c);\\n    }\\n\\n    //---------------------------------------------------------------------------\\n    // REMOTE CHAIN FUNCTIONS\\n    function redeemLocalCheckOnRemote(\\n        uint16 _srcChainId,\\n        bytes memory _srcAddress,\\n        uint256 _nonce,\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        uint256 _amountSD,\\n        bytes calldata _to\\n    ) external onlyBridge {\\n        Pool pool = _getPool(_dstPoolId);\\n        try pool.redeemLocalCheckOnRemote(_srcChainId, _srcPoolId, _amountSD) returns (uint256 redeemAmountSD, uint256 mintAmountSD) {\\n            revertLookup[_srcChainId][_srcAddress][_nonce] = abi.encode(\\n                TYPE_REDEEM_LOCAL_RESPONSE,\\n                _srcPoolId,\\n                _dstPoolId,\\n                redeemAmountSD,\\n                mintAmountSD,\\n                _to\\n            );\\n            emit RevertRedeemLocal(_srcChainId, _srcPoolId, _dstPoolId, _to, redeemAmountSD, mintAmountSD, _nonce, _srcAddress);\\n        } catch {\\n            // if the func fail, return [swapAmount: 0, mintAMount: _amountSD]\\n            // swapAmount represents the amount of chainPath balance deducted on the remote side, which because the above tx failed, should be 0\\n            // mintAmount is the full amount of tokens the user attempted to redeem on the src side, which gets converted back into the lp amount\\n            revertLookup[_srcChainId][_srcAddress][_nonce] = abi.encode(TYPE_REDEEM_LOCAL_RESPONSE, _srcPoolId, _dstPoolId, 0, _amountSD, _to);\\n            emit Revert(TYPE_REDEEM_LOCAL_RESPONSE, _srcChainId, _srcAddress, _nonce);\\n        }\\n    }\\n\\n    function redeemLocalCallback(\\n        uint16 _srcChainId,\\n        bytes memory _srcAddress,\\n        uint256 _nonce,\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        address _to,\\n        uint256 _amountSD,\\n        uint256 _mintAmountSD\\n    ) external onlyBridge {\\n        _redeemLocalCallback(_srcChainId, _srcAddress, _nonce, _srcPoolId, _dstPoolId, _to, _amountSD, _mintAmountSD);\\n    }\\n\\n    function _redeemLocalCallback(\\n        uint16 _srcChainId,\\n        bytes memory _srcAddress,\\n        uint256 _nonce,\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        address _to,\\n        uint256 _amountSD,\\n        uint256 _mintAmountSD\\n    ) internal {\\n        Pool pool = _getPool(_dstPoolId);\\n        try pool.redeemLocalCallback(_srcChainId, _srcPoolId, _to, _amountSD, _mintAmountSD) {} catch {\\n            revertLookup[_srcChainId][_srcAddress][_nonce] = abi.encode(\\n                TYPE_REDEEM_LOCAL_CALLBACK_RETRY,\\n                _srcPoolId,\\n                _dstPoolId,\\n                _to,\\n                _amountSD,\\n                _mintAmountSD\\n            );\\n            emit Revert(TYPE_REDEEM_LOCAL_CALLBACK_RETRY, _srcChainId, _srcAddress, _nonce);\\n        }\\n        emit RedeemLocalCallback(_srcChainId, _srcAddress, _nonce, _srcPoolId, _dstPoolId, _to, _amountSD, _mintAmountSD);\\n    }\\n\\n    function swapRemote(\\n        uint16 _srcChainId,\\n        bytes memory _srcAddress,\\n        uint256 _nonce,\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        uint256 _dstGasForCall,\\n        address _to,\\n        Pool.SwapObj memory _s,\\n        bytes memory _payload\\n    ) external onlyBridge {\\n        _swapRemote(_srcChainId, _srcAddress, _nonce, _srcPoolId, _dstPoolId, _dstGasForCall, _to, _s, _payload);\\n    }\\n\\n    function _swapRemote(\\n        uint16 _srcChainId,\\n        bytes memory _srcAddress,\\n        uint256 _nonce,\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        uint256 _dstGasForCall,\\n        address _to,\\n        Pool.SwapObj memory _s,\\n        bytes memory _payload\\n    ) internal {\\n        Pool pool = _getPool(_dstPoolId);\\n        // first try catch the swap remote\\n        try pool.swapRemote(_srcChainId, _srcPoolId, _to, _s) returns (uint256 amountLD) {\\n            if (Address.isContract(_to) && _payload.length > 0) {\\n                // then try catch the external contract call\\n                try IStargateReceiver(_to).sgReceive{gas: _dstGasForCall}(_srcChainId, _srcAddress, _nonce, pool.token(), amountLD, _payload) {\\n                    // do nothing\\n                } catch (bytes memory reason) {\\n                    cachedSwapLookup[_srcChainId][_srcAddress][_nonce] = CachedSwap(pool.token(), amountLD, _to, _payload);\\n                    emit CachedSwapSaved(_srcChainId, _srcAddress, _nonce, pool.token(), amountLD, _to, _payload, reason);\\n                }\\n            }\\n        } catch {\\n            revertLookup[_srcChainId][_srcAddress][_nonce] = abi.encode(\\n                TYPE_SWAP_REMOTE_RETRY,\\n                _srcPoolId,\\n                _dstPoolId,\\n                _dstGasForCall,\\n                _to,\\n                _s,\\n                _payload\\n            );\\n            emit Revert(TYPE_SWAP_REMOTE_RETRY, _srcChainId, _srcAddress, _nonce);\\n        }\\n    }\\n\\n    //---------------------------------------------------------------------------\\n    // DAO Calls\\n    function createPool(\\n        uint256 _poolId,\\n        address _token,\\n        uint8 _sharedDecimals,\\n        uint8 _localDecimals,\\n        string memory _name,\\n        string memory _symbol\\n    ) external onlyOwner returns (address) {\\n        require(_token != address(0x0), \\\"Stargate: _token cannot be 0x0\\\");\\n        return factory.createPool(_poolId, _token, _sharedDecimals, _localDecimals, _name, _symbol);\\n    }\\n\\n    function createChainPath(\\n        uint256 _poolId,\\n        uint16 _dstChainId,\\n        uint256 _dstPoolId,\\n        uint256 _weight\\n    ) external onlyOwner {\\n        Pool pool = _getPool(_poolId);\\n        pool.createChainPath(_dstChainId, _dstPoolId, _weight);\\n    }\\n\\n    function activateChainPath(\\n        uint256 _poolId,\\n        uint16 _dstChainId,\\n        uint256 _dstPoolId\\n    ) external onlyOwner {\\n        Pool pool = _getPool(_poolId);\\n        pool.activateChainPath(_dstChainId, _dstPoolId);\\n    }\\n\\n    function setWeightForChainPath(\\n        uint256 _poolId,\\n        uint16 _dstChainId,\\n        uint256 _dstPoolId,\\n        uint16 _weight\\n    ) external onlyOwner {\\n        Pool pool = _getPool(_poolId);\\n        pool.setWeightForChainPath(_dstChainId, _dstPoolId, _weight);\\n    }\\n\\n    function setProtocolFeeOwner(address _owner) external onlyOwner {\\n        require(_owner != address(0x0), \\\"Stargate: _owner cannot be 0x0\\\");\\n        protocolFeeOwner = _owner;\\n    }\\n\\n    function setMintFeeOwner(address _owner) external onlyOwner {\\n        require(_owner != address(0x0), \\\"Stargate: _owner cannot be 0x0\\\");\\n        mintFeeOwner = _owner;\\n    }\\n\\n    function setFees(uint256 _poolId, uint256 _mintFeeBP) external onlyOwner {\\n        Pool pool = _getPool(_poolId);\\n        pool.setFee(_mintFeeBP);\\n    }\\n\\n    function setFeeLibrary(uint256 _poolId, address _feeLibraryAddr) external onlyOwner {\\n        Pool pool = _getPool(_poolId);\\n        pool.setFeeLibrary(_feeLibraryAddr);\\n    }\\n\\n    function setSwapStop(uint256 _poolId, bool _swapStop) external onlyOwner {\\n        Pool pool = _getPool(_poolId);\\n        pool.setSwapStop(_swapStop);\\n    }\\n\\n    function setDeltaParam(\\n        uint256 _poolId,\\n        bool _batched,\\n        uint256 _swapDeltaBP,\\n        uint256 _lpDeltaBP,\\n        bool _defaultSwapMode,\\n        bool _defaultLPMode\\n    ) external onlyOwner {\\n        Pool pool = _getPool(_poolId);\\n        pool.setDeltaParam(_batched, _swapDeltaBP, _lpDeltaBP, _defaultSwapMode, _defaultLPMode);\\n    }\\n\\n    function callDelta(uint256 _poolId, bool _fullMode) external {\\n        Pool pool = _getPool(_poolId);\\n        pool.callDelta(_fullMode);\\n    }\\n\\n    function withdrawMintFee(uint256 _poolId, address _to) external {\\n        require(mintFeeOwner == msg.sender, \\\"Stargate: only mintFeeOwner\\\");\\n        Pool pool = _getPool(_poolId);\\n        pool.withdrawMintFeeBalance(_to);\\n    }\\n\\n    function withdrawProtocolFee(uint256 _poolId, address _to) external {\\n        require(protocolFeeOwner == msg.sender, \\\"Stargate: only protocolFeeOwner\\\");\\n        Pool pool = _getPool(_poolId);\\n        pool.withdrawProtocolFeeBalance(_to);\\n    }\\n}\\n\",\"keccak256\":\"0x76751565358053cafbb19ff2e76f130a1a8521ad53af95e8b80924791e81aef1\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IStargateFeeLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\nimport \\\"../Pool.sol\\\";\\n\\ninterface IStargateFeeLibrary {\\n    function getFees(\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        uint16 _dstChainId,\\n        address _from,\\n        uint256 _amountSD\\n    ) external returns (Pool.SwapObj memory s);\\n\\n    function getVersion() external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x712bc424a034519d61c5a1bbbf3f19fd34dfa51908421775c613f0a44e612d63\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IStargateReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.7.6;\\n\\ninterface IStargateReceiver {\\n    function sgReceive(\\n        uint16 _chainId,\\n        bytes memory _srcAddress,\\n        uint256 _nonce,\\n        address _token,\\n        uint256 amountLD,\\n        bytes memory payload\\n    ) external;\\n}\\n\",\"keccak256\":\"0x426e44d3907557a4cc3938894f5c42620d553603900c855ccd7cd417b3a75e79\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IStargateRouter.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\ninterface IStargateRouter {\\n    struct lzTxObj {\\n        uint256 dstGasForCall;\\n        uint256 dstNativeAmount;\\n        bytes dstNativeAddr;\\n    }\\n\\n    function addLiquidity(\\n        uint256 _poolId,\\n        uint256 _amountLD,\\n        address _to\\n    ) external;\\n\\n    function swap(\\n        uint16 _dstChainId,\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        address payable _refundAddress,\\n        uint256 _amountLD,\\n        uint256 _minAmountLD,\\n        lzTxObj memory _lzTxParams,\\n        bytes calldata _to,\\n        bytes calldata _payload\\n    ) external payable;\\n\\n    function redeemRemote(\\n        uint16 _dstChainId,\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        address payable _refundAddress,\\n        uint256 _amountLP,\\n        uint256 _minAmountLD,\\n        bytes calldata _to,\\n        lzTxObj memory _lzTxParams\\n    ) external payable;\\n\\n    function instantRedeemLocal(\\n        uint16 _srcPoolId,\\n        uint256 _amountLP,\\n        address _to\\n    ) external returns (uint256);\\n\\n    function redeemLocal(\\n        uint16 _dstChainId,\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        address payable _refundAddress,\\n        uint256 _amountLP,\\n        bytes calldata _to,\\n        lzTxObj memory _lzTxParams\\n    ) external payable;\\n\\n    function sendCredits(\\n        uint16 _dstChainId,\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        address payable _refundAddress\\n    ) external payable;\\n\\n    function quoteLayerZeroFee(\\n        uint16 _dstChainId,\\n        uint8 _functionType,\\n        bytes calldata _toAddress,\\n        bytes calldata _transferAndCallPayload,\\n        lzTxObj memory _lzTxParams\\n    ) external view returns (uint256, uint256);\\n}\\n\",\"keccak256\":\"0xe560f0b426fdcd13d3add6bab4a18aed16fcaa99ea7d785e4a9d96ccc66f2ca3\",\"license\":\"BUSL-1.1\"},\"contracts/precrime/IPreCrime.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >=0.7.0;\\npragma abicoder v2;\\n\\ninterface IPreCrime {\\n    struct Packet {\\n        uint16 srcChainId; // source chain id\\n        bytes32 srcAddress; // srouce UA address\\n        uint64 nonce;\\n        bytes payload;\\n    }\\n\\n    /**\\n     * @dev get precrime config,\\n     * @param _packets packets\\n     * @return bytes of [maxBatchSize, remotePrecrimes]\\n     */\\n    function getConfig(Packet[] calldata _packets) external view returns (bytes memory);\\n\\n    /**\\n     * @dev simulate run cross chain packets and get a simulation result for precrime later\\n     * @param _packets packets, the packets item should group by srcChainId, srcAddress, then sort by nonce\\n     * @return code   simulation result code; see the error code defination\\n     * @return result the result is use for precrime params\\n     */\\n    function simulate(Packet[] calldata _packets) external view returns (uint16 code, bytes memory result);\\n\\n    /**\\n     * @dev\\n     * @param _simulation all simulation results from difference chains\\n     * @return code     precrime result code; check out the error code defination\\n     * @return reason   error reason\\n     */\\n    function precrime(Packet[] calldata _packets, bytes[] calldata _simulation) external view returns (uint16 code, bytes memory reason);\\n\\n    /**\\n     * @dev protocol version\\n     */\\n    function version() external view returns (uint16);\\n}\\n\",\"keccak256\":\"0x46d94cbe35efb28b88464ec8d1d93de0b6f29e3583aea967e78ba21190f1c5b2\",\"license\":\"GPL-3.0-only\"},\"contracts/precrime/PreCrime.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./IPreCrime.sol\\\";\\nimport \\\"../util/StringLib.sol\\\";\\nimport \\\"../util/BytesLib.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\nabstract contract PreCrime is IPreCrime {\\n    using strings for *;\\n    using BytesLib for bytes;\\n\\n    uint16 public constant PRECRIME_VERSION = 1;\\n    uint16 public constant CONFIG_VERSION = 1;\\n\\n    //---------------- error code ----------------------\\n    // --- UA scope code ---\\n    uint16 public constant CODE_SUCCESS = 0; // success\\n    uint16 public constant CODE_PRECRIME_FAILURE = 1; // !!! crimes found\\n\\n    // --- protocol scope error code ---\\n    // simualte\\n    uint16 public constant CODE_PACKETS_OVERSIZE = 2; // packets number bigger then max size\\n    uint16 public constant CODE_PACKETS_UNSORTED = 3; // packets are unsorted, need backfill and keep order\\n    // precrime\\n    uint16 public constant CODE_MISS_SIMULATE_RESULT = 4; // miss simulation result\\n\\n    string constant SIMULATION_RESULT_PREFIX = \\\"^simulation result^\\\";\\n\\n    uint16 public localChainId;\\n\\n    constructor(uint16 _localChainId) {\\n        localChainId = _localChainId;\\n    }\\n\\n    /**\\n     * @dev get precrime config,\\n     * @param _packets packets\\n     * @return configation bytes\\n     */\\n    function getConfig(Packet[] calldata _packets) external view virtual override returns (bytes memory) {\\n        (uint16[] memory remoteChains, bytes32[] memory remoteAddresses) = _remotePrecrimeAddress(_packets);\\n        return\\n            abi.encodePacked(\\n                CONFIG_VERSION,\\n                //---- max packets size for simulate batch ---\\n                _maxBatchSize(),\\n                //------------- remote precrimes -------------\\n                remoteChains.length,\\n                remoteChains,\\n                remoteAddresses\\n            );\\n    }\\n\\n    /**\\n     * @dev simulate run cross chain packets and get a simulation result for precrime later\\n     * @param _packets packets, the packets item should group by srcChainId, srcAddress, then sort by nonce\\n     * @return code   simulation result code; see the error code defination\\n     * @return data the result is use for precrime params\\n     */\\n    function simulate(Packet[] calldata _packets) external view override returns (uint16 code, bytes memory data) {\\n        uint64 maxSize = _maxBatchSize();\\n        if (_packets.length > maxSize) {\\n            return (CODE_PACKETS_OVERSIZE, abi.encodePacked(\\\"packets size exceed limited \\\", Strings.toString(uint256(maxSize))));\\n        }\\n\\n        // check packets nonce, sequence order\\n        // packets should group by srcChainId and srcAddress, then sort by nonce ascending\\n        if (_packets.length > 0) {\\n            uint16 srcChainId;\\n            bytes32 srcAddress;\\n            uint64 nonce;\\n            for (uint256 i = 0; i < _packets.length; i++) {\\n                Packet memory packet = _packets[i];\\n                // start from a new chain packet or a new source UA\\n                if (packet.srcChainId != srcChainId || packet.srcAddress != srcAddress) {\\n                    srcChainId = packet.srcChainId;\\n                    srcAddress = packet.srcAddress;\\n                    nonce = packet.nonce;\\n                    uint64 nextInboundNonce = _getInboundNonce(packet) + 1;\\n                    // the first packet's nonce must equal to dst InboundNonce+1\\n                    if (nonce != nextInboundNonce) {\\n                        return (CODE_PACKETS_UNSORTED, abi.encodePacked(\\\"skipped inboundNonce, packet index: \\\", Strings.toString(i)));\\n                    }\\n                } else {\\n                    // the following packet's nonce add 1 in order\\n                    if (packet.nonce != ++nonce) {\\n                        return (CODE_PACKETS_UNSORTED, abi.encodePacked(\\\"unsorted packets, packet index: \\\", Strings.toString(i)));\\n                    }\\n                }\\n            }\\n        }\\n\\n        (bool success, bytes memory result) = address(this).staticcall(abi.encodeWithSelector(this._simulateAndRevert.selector, _packets));\\n        // the _simulateAndRevert will never return success\\n        if (success) {\\n            revert(string(result));\\n        }\\n\\n        (code, data) = _parseRevertResult(result);\\n        if (code == CODE_SUCCESS) {\\n            data = abi.encode(localChainId, data); // add localChainId to the header\\n        }\\n    }\\n\\n    /**\\n     * @dev\\n     * @param _simulation all simulation results from difference chains\\n     * @return code     precrime result code; check out the error code defination\\n     * @return reason   error reason\\n     */\\n    function precrime(\\n        Packet[] calldata _packets,\\n        bytes[] calldata _simulation\\n    ) external view override returns (uint16 code, bytes memory reason) {\\n        bytes[] memory originSimulateResult = new bytes[](_simulation.length);\\n        uint16[] memory chainIds = new uint16[](_simulation.length);\\n        for (uint256 i = 0; i < _simulation.length; i++) {\\n            (uint16 chainId, bytes memory simulateResult) = abi.decode(_simulation[i], (uint16, bytes));\\n            chainIds[i] = chainId;\\n            originSimulateResult[i] = simulateResult;\\n        }\\n\\n        (code, reason) = _checkResultsCompleteness(_packets, chainIds);\\n        if (code != CODE_SUCCESS) {\\n            return (code, reason);\\n        }\\n\\n        (code, reason) = _precrime(originSimulateResult);\\n    }\\n\\n    function _checkResultsCompleteness(\\n        Packet[] calldata _packets,\\n        uint16[] memory _resultChainIds\\n    ) internal view returns (uint16 code, bytes memory reason) {\\n        // check if all remote result included\\n        if (_packets.length > 0) {\\n            (uint16[] memory remoteChains, ) = _remotePrecrimeAddress(_packets);\\n            for (uint256 i = 0; i < remoteChains.length; i++) {\\n                bool resultChainIdChecked;\\n                for (uint256 j = 0; j < _resultChainIds.length; j++) {\\n                    if (_resultChainIds[j] == remoteChains[i]) {\\n                        resultChainIdChecked = true;\\n                        break;\\n                    }\\n                }\\n                if (!resultChainIdChecked) {\\n                    return (CODE_MISS_SIMULATE_RESULT, \\\"missing remote simulation result\\\");\\n                }\\n            }\\n        }\\n        // check if local resut included\\n        bool localChainIdResultChecked;\\n        for (uint256 j = 0; j < _resultChainIds.length; j++) {\\n            if (_resultChainIds[j] == localChainId) {\\n                localChainIdResultChecked = true;\\n                break;\\n            }\\n        }\\n        if (!localChainIdResultChecked) {\\n            return (CODE_MISS_SIMULATE_RESULT, \\\"missing local simulation result\\\");\\n        }\\n\\n        return (CODE_SUCCESS, \\\"\\\");\\n    }\\n\\n    function _parseRevertResult(bytes memory result) internal pure returns (uint16 code, bytes memory data) {\\n        if (result.length < 0x04) {\\n            revert(string(result));\\n        }\\n        assembly {\\n            // Slice the sighash. Remove the selector which is the first 4 bytes\\n            // https://ethereum.stackexchange.com/a/83577\\n            data := add(result, 0x04)\\n        }\\n        // parse _simulateAndRevert/_precrimeAndRevert result, if it start with SIMULATE_RESULT_PREFIX, it means it run expected.\\n        // otherwise, it was reverted by unexpected error.\\n        string memory dataStr = abi.decode(data, (string));\\n        strings.slice memory dataSlice = dataStr.toSlice();\\n        strings.slice memory prefixSlice = SIMULATION_RESULT_PREFIX.toSlice();\\n        if (!dataSlice.startsWith(prefixSlice)) {\\n            revert(string(result));\\n        }\\n        // parse code and result\\n        bytes memory codeResultData = bytes(dataSlice.beyond(prefixSlice).toString());\\n        code = codeResultData.toUint16(0);\\n        data = codeResultData.slice(2, codeResultData.length - 2);\\n    }\\n\\n    /**\\n     * @dev internal function, no one should call\\n     * @param _packets packets\\n     */\\n    function _simulateAndRevert(Packet[] calldata _packets) external virtual {\\n        require(msg.sender == address(this));\\n        (uint16 code, bytes memory simulation) = _simulate(_packets);\\n        revert(string(abi.encodePacked(SIMULATION_RESULT_PREFIX, code, simulation)));\\n    }\\n\\n    function version() external pure override returns (uint16) {\\n        return PRECRIME_VERSION;\\n    }\\n\\n    /**\\n     * @dev\\n     * @param _simulation all simulation results from difference chains\\n     * @return code     precrime result code; check out the error code defination\\n     * @return reason   error reason\\n     */\\n    function _precrime(bytes[] memory _simulation) internal view virtual returns (uint16 code, bytes memory reason);\\n\\n    /**\\n     * @dev UA execute the logic by _packets, and return simulation result for precrime. would revert state after returned result.\\n     * @param _packets packets\\n     * @return code\\n     * @return result\\n     */\\n    function _simulate(Packet[] calldata _packets) internal virtual returns (uint16 code, bytes memory result);\\n\\n    /**\\n     * @dev UA return trusted remote precrimes by packets\\n     * @param _packets packets\\n     * @return\\n     */\\n    function _remotePrecrimeAddress(Packet[] calldata _packets) internal view virtual returns (uint16[] memory, bytes32[] memory);\\n\\n    /**\\n     * @dev max batch size for simulate\\n     * @return\\n     */\\n    function _maxBatchSize() internal view virtual returns (uint64);\\n\\n    /**\\n     * get srcChain & srcAddress InboundNonce by packet\\n     */\\n    function _getInboundNonce(Packet memory packet) internal view virtual returns (uint64 nonce);\\n}\\n\",\"keccak256\":\"0x0b1bb707963527aed7c01ec236a989acad9441f24bc38f577fac8b93100de8ef\",\"license\":\"GPL-3.0-only\"},\"contracts/precrime/stargate/PoolView.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../../Pool.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\ncontract PoolView {\\n    using SafeMath for uint256;\\n\\n    struct ChainPathState {\\n        uint16 dstChainId;\\n        uint256 dstPoolId;\\n        uint256 balance;\\n        uint256 lkb;\\n        uint256 credits;\\n        uint256 idealBalance;\\n        bool needPrecrime;\\n    }\\n\\n    struct PoolBalance {\\n        uint256 totalLiquidity; // the total amount of tokens added on this side of the chain (fees + deposits - withdrawals)\\n        uint256 protocolFeeBalance; // fee balance created from dao fee\\n        uint256 mintFeeBalance; // fee balance created from mint fee\\n        uint256 eqFeePool;\\n        uint256 deltaCredit;\\n        uint256 tokenBalance; // token balance of the pool, in sd\\n    }\\n\\n    struct PoolState {\\n        uint256 poolId;\\n        ChainPathState[] chainPaths; // list of connected chains with shared pools\\n        PoolBalance balance;\\n    }\\n\\n    function getPoolState(Pool _pool) external view returns (PoolState memory) {\\n        // get all chain paths\\n        uint256 chainPathSize = _pool.getChainPathsLength();\\n        ChainPathState[] memory chainPaths = new ChainPathState[](chainPathSize);\\n        for (uint256 j = 0; j < chainPathSize; j++) {\\n            (, uint16 dstChainId, uint256 dstPoolId, , uint256 balance, uint256 lkb, uint256 credits, uint256 idealBalance) = _pool.chainPaths(\\n                j\\n            );\\n\\n            chainPaths[j] = ChainPathState({\\n                dstChainId: dstChainId,\\n                dstPoolId: dstPoolId,\\n                balance: balance,\\n                lkb: lkb,\\n                credits: credits,\\n                idealBalance: idealBalance,\\n                needPrecrime: false\\n            });\\n        }\\n\\n        uint256 tokenBalance = IERC20(_pool.token()).balanceOf(address(_pool));\\n\\n        return\\n            PoolState({\\n                poolId: _pool.poolId(),\\n                chainPaths: chainPaths,\\n                balance: PoolBalance({\\n                    totalLiquidity: _pool.totalLiquidity(),\\n                    protocolFeeBalance: _pool.protocolFeeBalance(),\\n                    mintFeeBalance: _pool.mintFeeBalance(),\\n                    eqFeePool: _pool.eqFeePool(),\\n                    deltaCredit: _pool.deltaCredit(),\\n                    tokenBalance: amountLDtoSD(_pool, tokenBalance)\\n                })\\n            });\\n    }\\n\\n    // Local                                    Remote\\n    // -------                                  ---------\\n    // sendCredits      ->                      creditChainPath\\n    function creditChainPath(ChainPathState memory _cp, Pool.CreditObj memory _c) external pure returns (ChainPathState memory) {\\n        _cp.balance = _cp.balance.add(_c.credits);\\n        _cp.needPrecrime = true;\\n        if (_cp.idealBalance != _c.idealBalance) {\\n            _cp.idealBalance = _c.idealBalance;\\n        }\\n\\n        return _cp;\\n    }\\n\\n    // Local                                    Remote\\n    // -------                                  ---------\\n    // swap             ->                      swapRemote\\n    function swapRemote(\\n        PoolBalance memory _pb,\\n        ChainPathState memory _cp,\\n        Pool.SwapObj memory _s\\n    ) external pure returns (PoolBalance memory, ChainPathState memory) {\\n//        // booking lpFee\\n//        totalLiquidity = totalLiquidity.add(_s.lpFee);\\n//        // booking eqFee\\n//        eqFeePool = eqFeePool.add(_s.eqFee);\\n//        // booking stargateFee\\n//        protocolFeeBalance = protocolFeeBalance.add(_s.protocolFee);\\n//\\n//        // update LKB\\n//        uint256 chainPathIndex = chainPathIndexLookup[_srcChainId][_srcPoolId];\\n//        chainPaths[chainPathIndex].lkb = chainPaths[chainPathIndex].lkb.sub(_s.lkbRemove);\\n//\\n//        // user receives the amount + the srcReward\\n//        amountLD = amountSDtoLD(_s.amount.add(_s.eqReward));\\n//        _safeTransfer(token, _to, amountLD);\\n//        emit SwapRemote(_to, _s.amount.add(_s.eqReward), _s.protocolFee, _s.eqFee);\\n\\n        // booking lpFee\\n        _pb.totalLiquidity = _pb.totalLiquidity.add(_s.lpFee);\\n        // booking eqFee\\n        _pb.eqFeePool = _pb.eqFeePool.add(_s.eqFee);\\n        // booking stargateFee\\n        _pb.protocolFeeBalance = _pb.protocolFeeBalance.add(_s.protocolFee);\\n\\n        // update LKB\\n        _cp.lkb = _cp.lkb.sub(_s.lkbRemove);\\n        _cp.needPrecrime = true;\\n\\n        // user receives the amount + the srcReward\\n        _pb.tokenBalance = _pb.tokenBalance.sub(_s.amount.add(_s.eqReward));\\n\\n        return (_pb, _cp);\\n    }\\n\\n    // Local                                    Remote\\n    // -------                                  ---------\\n    // redeemLocal   ->                         redeemLocalCheckOnRemote\\n    // redeemLocalCallback             <-\\n    function redeemLocalCallback(\\n        PoolBalance memory _pb,\\n        ChainPathState memory _cp,\\n        uint256 _amountSD,\\n        uint256 _amountToMintSD\\n    ) external pure returns (PoolBalance memory, ChainPathState memory) {\\n//        if (_amountToMintSD > 0) {\\n//            _mintLocal(_to, amountSDtoLD(_amountToMintSD), false, false);\\n//        }\\n//\\n//        ChainPath storage cp = getAndCheckCP(_srcChainId, _srcPoolId);\\n//        cp.lkb = cp.lkb.sub(_amountSD);\\n//\\n//        uint256 amountLD = amountSDtoLD(_amountSD);\\n//        _safeTransfer(token, _to, amountLD);\\n//        emit RedeemLocalCallback(_to, _amountSD, _amountToMintSD);\\n\\n\\n        if (_amountToMintSD > 0) {\\n            _pb.totalLiquidity = _pb.totalLiquidity.add(_amountToMintSD);\\n        }\\n\\n        _cp.lkb = _cp.lkb.sub(_amountSD);\\n        _cp.needPrecrime = true;\\n\\n        _pb.tokenBalance = _pb.tokenBalance.sub(_amountSD);\\n\\n        return (_pb, _cp);\\n    }\\n\\n    // Local                                    Remote\\n    // -------                                  ---------\\n    // redeemLocal(amount)   ->               redeemLocalCheckOnRemote\\n    // redeemLocalCallback             <-\\n    function redeemLocalCheckOnRemote(ChainPathState memory _cp, uint256 _amountSD) external pure returns (ChainPathState memory) {\\n//        ChainPath storage cp = getAndCheckCP(_srcChainId, _srcPoolId);\\n//        if (_amountSD > cp.balance) {\\n//            mintAmount = _amountSD - cp.balance;\\n//            swapAmount = cp.balance;\\n//            cp.balance = 0;\\n//        } else {\\n//            cp.balance = cp.balance.sub(_amountSD);\\n//            swapAmount = _amountSD;\\n//            mintAmount = 0;\\n//        }\\n//        emit WithdrawRemote(_srcChainId, _srcPoolId, swapAmount, mintAmount);\\n\\n        if (_amountSD > _cp.balance) {\\n            _cp.balance = 0;\\n        } else {\\n            _cp.balance = _cp.balance.sub(_amountSD);\\n        }\\n        _cp.needPrecrime = true;\\n        return _cp;\\n    }\\n\\n    function amountSDtoLD(Pool _pool, uint256 _amount) internal view returns (uint256) {\\n        return _amount.mul(_pool.convertRate());\\n    }\\n\\n    function amountLDtoSD(Pool _pool, uint256 _amount) internal view returns (uint256) {\\n        return _amount.div(_pool.convertRate());\\n    }\\n}\\n\",\"keccak256\":\"0x6a7cd16c4526f26e365414a5253a5263c23e035aa4384f35470dc3b12e0c1d0c\",\"license\":\"UNLICENSED\"},\"contracts/precrime/stargate/StargatePreCrime.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../../Pool.sol\\\";\\nimport \\\"../../Factory.sol\\\";\\nimport \\\"../../Router.sol\\\";\\nimport \\\"../../Bridge.sol\\\";\\nimport \\\"./PoolView.sol\\\";\\nimport \\\"../PreCrime.sol\\\";\\nimport \\\"../../util/BytesLib.sol\\\";\\n\\nimport \\\"@layerzerolabs/layerzero-core/contracts/interfaces/ILayerZeroEndpoint.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\ncontract StargatePreCrime is Ownable, PreCrime {\\n    using SafeMath for uint256;\\n    using BytesLib for bytes;\\n\\n    struct SimulationResult {\\n        uint16 chainId;\\n        PoolView.PoolState[] poolStates;\\n    }\\n\\n    // CONSTANTS\\n    uint8 internal constant TYPE_SWAP_REMOTE = 1;\\n    uint8 internal constant TYPE_ADD_LIQUIDITY = 2;\\n    uint8 internal constant TYPE_REDEEM_LOCAL_CALL_BACK = 3;\\n    uint8 internal constant TYPE_WITHDRAW_REMOTE = 4;\\n\\n    Router public stargateRouter;\\n    PoolView public poolView;\\n    uint16[] public remoteChainIds;\\n    bytes32[] public remotePrecrimeAddresses;\\n    uint64 public maxBatchSize;\\n    uint public inflightBuffer;\\n\\n    constructor(\\n        uint16 _localChainId,\\n        address _stargateRouter,\\n        address _poolView,\\n        uint64 _maxBatchSizeForSimulate,\\n        uint16[] memory _remoteChainIds,\\n        bytes32[] memory _remotePrecrimeAddresses\\n    ) PreCrime(_localChainId) {\\n        setStargateRouter(_stargateRouter);\\n        setPoolView(_poolView);\\n        setMaxBatchSize(_maxBatchSizeForSimulate);\\n        setRemotePrecrimeAddresses(_remoteChainIds, _remotePrecrimeAddresses);\\n    }\\n\\n    function setStargateRouter(address _stargateRouter) public onlyOwner {\\n        stargateRouter = Router(_stargateRouter);\\n    }\\n\\n    function setRemotePrecrimeAddresses(uint16[] memory _remoteChainIds, bytes32[] memory _remotePrecrimeAddresses) public onlyOwner {\\n        require(_remoteChainIds.length == _remotePrecrimeAddresses.length, \\\"StargatePrecrime: invalid size\\\");\\n        remoteChainIds = _remoteChainIds;\\n        remotePrecrimeAddresses = _remotePrecrimeAddresses;\\n    }\\n\\n    function setMaxBatchSize(uint64 _size) public onlyOwner {\\n        maxBatchSize = _size;\\n    }\\n\\n    function setPoolView(address _poolView) public onlyOwner {\\n        poolView = PoolView(_poolView);\\n    }\\n\\n    function setInflightBuffer(uint _inflightBuffer) public onlyOwner {\\n        inflightBuffer = _inflightBuffer;\\n    }\\n\\n    // srcPool.dstChainPath.lkb >= dstPool.srcChainPath.balance\\n    // totalPromisedBalance = poolBalance - eqFeePool - protocolFeeBalance - minFeeBalance\\n    // totalPromisedBalance >= total lkbs + total credits\\n    function _precrime(bytes[] memory _simulation) internal view override returns (uint16 code, bytes memory reason) {\\n        SimulationResult memory localResult;\\n        // decode results\\n        SimulationResult[] memory results = new SimulationResult[](_simulation.length);\\n        for (uint256 i = 0; i < _simulation.length; i++) {\\n            results[i] = abi.decode(_simulation[i], (SimulationResult));\\n            if (results[i].chainId == localChainId) {\\n                localResult = results[i];\\n            }\\n        }\\n\\n        // each pool\\n        for (uint256 j = 0; j < localResult.poolStates.length; j++) {\\n            PoolView.PoolState memory localPool = localResult.poolStates[j];\\n            // local pool assertion\\n            (code, reason) = _assertPool(localPool);\\n            if (code != CODE_SUCCESS) {\\n                return (code, reason);\\n            }\\n\\n            // each chain path\\n            for (uint256 k = 0; k < localPool.chainPaths.length; k++) {\\n                PoolView.ChainPathState memory localPoolCp = localPool.chainPaths[k];\\n\\n                if (localPoolCp.needPrecrime) {\\n                    // find and assert remote pool\\n                    PoolView.PoolState memory remotePool = _getPool(results, localPoolCp.dstChainId, localPoolCp.dstPoolId);\\n                    // remote pool assertion\\n                    (code, reason) = _assertPool(remotePool);\\n                    if (code != CODE_SUCCESS) {\\n                        return (code, reason);\\n                    }\\n\\n                    // find and assert remote CP\\n                    (PoolView.ChainPathState memory remotePoolCp, ) = _getChainPath(remotePool, localResult.chainId, localPool.poolId);\\n                    (code, reason) = _assertCP(localPoolCp, remotePoolCp);\\n                    if (code != CODE_SUCCESS) {\\n                        return (code, reason);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return (CODE_SUCCESS, \\\"\\\");\\n    }\\n\\n    function _assertPool(PoolView.PoolState memory _pool) internal pure returns (uint16 code, bytes memory reason) {\\n        uint256 totalPromisedBalance = _pool.balance.deltaCredit;\\n        // each chain path\\n        for (uint256 k = 0; k < _pool.chainPaths.length; k++) {\\n            PoolView.ChainPathState memory localPoolCp = _pool.chainPaths[k];\\n            totalPromisedBalance = totalPromisedBalance.add(localPoolCp.lkb).add(localPoolCp.credits);\\n        }\\n\\n        uint256 totalSolventBalance = _pool.balance.tokenBalance.sub(_pool.balance.eqFeePool).sub(_pool.balance.protocolFeeBalance).sub(\\n            _pool.balance.mintFeeBalance\\n        );\\n\\n        if (totalPromisedBalance > totalSolventBalance) {\\n            return (CODE_PRECRIME_FAILURE, \\\"StargatePrecrime: totalPromisedBalance > totalSolventBalance\\\");\\n        }\\n\\n        return (CODE_SUCCESS, \\\"\\\");\\n    }\\n\\n    function _assertCP(\\n        PoolView.ChainPathState memory localPoolCp,\\n        PoolView.ChainPathState memory remotePoolCp\\n    ) internal view returns (uint16 code, bytes memory reason) {\\n        // add buffer to account for inflight and dust\\n        if (localPoolCp.lkb.add(localPoolCp.lkb/1000000).add(inflightBuffer) < remotePoolCp.balance) {\\n            return (CODE_PRECRIME_FAILURE, \\\"StargatePrecrime: localPoolCp.lkb < remotePoolCp.balance\\\");\\n        }\\n        return (CODE_SUCCESS, \\\"\\\");\\n    }\\n\\n    function _getSimulationResult(SimulationResult[] memory _results, uint16 _chainId) internal pure returns (SimulationResult memory) {\\n        for (uint256 i = 0; i < _results.length; i++) {\\n            SimulationResult memory result = _results[i];\\n            if (result.chainId == _chainId) {\\n                return result;\\n            }\\n        }\\n        revert(\\\"StargatePrecrime: simulation result not found\\\");\\n    }\\n\\n    function _getPool(SimulationResult[] memory _results, uint16 _chainId, uint256 _poolId) internal pure returns (PoolView.PoolState memory) {\\n        SimulationResult memory result = _getSimulationResult(_results, _chainId);\\n        for (uint256 i = 0; i < result.poolStates.length; i++) {\\n            PoolView.PoolState memory poolState = result.poolStates[i];\\n            if (poolState.poolId == _poolId) {\\n                return poolState;\\n            }\\n        }\\n        revert(\\\"StargatePrecrime: pool state not found\\\");\\n    }\\n\\n    function _simulate(Packet[] calldata _packets) internal view override returns (uint16, bytes memory) {\\n        // get state from stargate\\n        (Pool[] memory pools, PoolView.PoolState[] memory poolStates) = _getPoolAddressesAndStates();\\n\\n        // simulate\\n        for (uint256 i = 0; i < _packets.length; i++) {\\n            Packet memory packet = _packets[i];\\n            if (_isPacketFromTrustedRemote(packet)) {\\n                _lzReceive(pools, poolStates, packet);\\n            }\\n        }\\n\\n        // return simulation result\\n        return (CODE_SUCCESS, abi.encode(SimulationResult({chainId: localChainId, poolStates: poolStates})));\\n    }\\n\\n    function _getPoolAddressesAndStates() internal view returns (Pool[] memory, PoolView.PoolState[] memory) {\\n        Factory factory = stargateRouter.factory();\\n        uint256 poolSize = factory.allPoolsLength();\\n        PoolView.PoolState[] memory poolStates = new PoolView.PoolState[](poolSize);\\n        Pool[] memory pools = new Pool[](poolSize);\\n        for (uint256 i = 0; i < poolSize; i++) {\\n            Pool pool = Pool(factory.allPools(i));\\n            pools[i] = pool;\\n            poolStates[i] = poolView.getPoolState(pool);\\n        }\\n        return (pools, poolStates);\\n    }\\n\\n    function _getPoolAddressAndStateByPoolId(\\n        Pool[] memory _pools,\\n        PoolView.PoolState[] memory _poolStates,\\n        uint256 _poolId\\n    ) internal pure returns (Pool, PoolView.PoolState memory, uint) {\\n        for (uint256 i = 0; i < _poolStates.length; i++) {\\n            if (_poolStates[i].poolId == _poolId) {\\n                return (_pools[i], _poolStates[i], i);\\n            }\\n        }\\n        revert(\\\"StargatePrecrime: _poolId not found\\\");\\n    }\\n\\n    function _lzReceive(Pool[] memory _pools, PoolView.PoolState[] memory _poolStates, Packet memory _packet) internal view {\\n        uint8 functionType;\\n        bytes memory payload = _packet.payload;\\n        assembly {\\n            functionType := mload(add(payload, 32))\\n        }\\n\\n        if (functionType == TYPE_SWAP_REMOTE) {\\n            _swapRemote(_pools, _poolStates, _packet.srcChainId, payload);\\n        } else if (functionType == TYPE_ADD_LIQUIDITY) {\\n            _addLiquidity(_pools, _poolStates, _packet.srcChainId, payload);\\n        } else if (functionType == TYPE_REDEEM_LOCAL_CALL_BACK) {\\n            _redeemLocalCallback(_pools, _poolStates, _packet.srcChainId, payload);\\n        } else if (functionType == TYPE_WITHDRAW_REMOTE) {\\n            _redeemLocalCheckOnRemote(_pools, _poolStates, _packet.srcChainId, payload);\\n        }\\n    }\\n\\n    function _getInboundNonce(Packet memory packet) internal view override returns (uint64 inboundNonce) {\\n        // only evm address by now\\n        address srcAddress = address(uint160(uint(packet.srcAddress)));\\n        bytes memory pathData = abi.encodePacked(srcAddress, address(stargateRouter.bridge()));\\n        ILayerZeroEndpoint endpoint = Bridge(stargateRouter.bridge()).layerZeroEndpoint();\\n        inboundNonce = endpoint.getInboundNonce(packet.srcChainId, pathData);\\n    }\\n\\n    function _getChainPath(\\n        PoolView.PoolState memory _poolState,\\n        uint16 _dstChainId,\\n        uint256 _dstPoolId\\n    ) internal pure returns (PoolView.ChainPathState memory, uint256) {\\n        for (uint256 i = 0; i < _poolState.chainPaths.length; i++) {\\n            if (_poolState.chainPaths[i].dstChainId == _dstChainId && _poolState.chainPaths[i].dstPoolId == _dstPoolId) {\\n                return (_poolState.chainPaths[i], i);\\n            }\\n        }\\n        revert(\\\"StargatePrecrime: chain path not found\\\");\\n    }\\n\\n    function _swapRemote(\\n        Pool[] memory _pools,\\n        PoolView.PoolState[] memory _poolStates,\\n        uint16 _srcChainId,\\n        bytes memory _payload\\n    ) internal view {\\n        (, uint256 srcPoolId, uint256 dstPoolId, , Pool.CreditObj memory c, Pool.SwapObj memory s, , ) = abi.decode(\\n            _payload,\\n            (uint8, uint256, uint256, uint256, Pool.CreditObj, Pool.SwapObj, bytes, bytes)\\n        );\\n\\n        (, PoolView.PoolState memory poolState, uint256 poolIndex) = _getPoolAddressAndStateByPoolId(_pools, _poolStates, dstPoolId);\\n        (PoolView.ChainPathState memory cp, uint256 cpIndex) = _getChainPath(poolState, _srcChainId, srcPoolId);\\n\\n        cp = poolView.creditChainPath(cp, c);\\n\\n        try poolView.swapRemote(poolState.balance, cp, s) returns (PoolView.PoolBalance memory newPB, PoolView.ChainPathState memory newCP) {\\n            _poolStates[poolIndex].balance = newPB;\\n            _poolStates[poolIndex].chainPaths[cpIndex] = newCP;\\n        } catch {}\\n    }\\n\\n    function _addLiquidity(\\n        Pool[] memory _pools,\\n        PoolView.PoolState[] memory _poolStates,\\n        uint16 _srcChainId,\\n        bytes memory _payload\\n    ) internal view {\\n        (, uint256 srcPoolId, uint256 dstPoolId, Pool.CreditObj memory c) = abi.decode(_payload, (uint8, uint256, uint256, Pool.CreditObj));\\n\\n        (, PoolView.PoolState memory poolState, uint256 poolIndex) = _getPoolAddressAndStateByPoolId(_pools, _poolStates, dstPoolId);\\n        (PoolView.ChainPathState memory cp, uint256 cpIndex) = _getChainPath(poolState, _srcChainId, srcPoolId);\\n\\n        cp = poolView.creditChainPath(cp, c);\\n        _poolStates[poolIndex].chainPaths[cpIndex] = cp;\\n    }\\n\\n    function _redeemLocalCallback(\\n        Pool[] memory _pools,\\n        PoolView.PoolState[] memory _poolStates,\\n        uint16 _srcChainId,\\n        bytes memory _payload\\n    ) internal view {\\n        (, uint256 srcPoolId, uint256 dstPoolId, Pool.CreditObj memory c, uint256 amountSD, uint256 mintAmountSD, ) = abi.decode(\\n            _payload,\\n            (uint8, uint256, uint256, Pool.CreditObj, uint256, uint256, bytes)\\n        );\\n\\n        (, PoolView.PoolState memory poolState, uint256 poolIndex) = _getPoolAddressAndStateByPoolId(_pools, _poolStates, dstPoolId);\\n        (PoolView.ChainPathState memory cp, uint256 cpIndex) = _getChainPath(poolState, _srcChainId, srcPoolId);\\n\\n        cp = poolView.creditChainPath(cp, c);\\n\\n        try poolView.redeemLocalCallback(poolState.balance, cp, amountSD, mintAmountSD) returns (\\n            PoolView.PoolBalance memory newPB,\\n            PoolView.ChainPathState memory newCP\\n        ) {\\n            _poolStates[poolIndex].balance = newPB;\\n            _poolStates[poolIndex].chainPaths[cpIndex] = newCP;\\n        } catch {}\\n    }\\n\\n    function _redeemLocalCheckOnRemote(\\n        Pool[] memory _pools,\\n        PoolView.PoolState[] memory _poolStates,\\n        uint16 _srcChainId,\\n        bytes memory _payload\\n    ) internal view {\\n        (, uint256 srcPoolId, uint256 dstPoolId, Pool.CreditObj memory c, uint256 amountSD, ) = abi.decode(\\n            _payload,\\n            (uint8, uint256, uint256, Pool.CreditObj, uint256, bytes)\\n        );\\n\\n        (, PoolView.PoolState memory poolState, uint256 poolIndex) = _getPoolAddressAndStateByPoolId(_pools, _poolStates, dstPoolId);\\n        (PoolView.ChainPathState memory cp, uint256 cpIndex) = _getChainPath(poolState, _srcChainId, srcPoolId);\\n\\n        cp = poolView.creditChainPath(cp, c);\\n\\n        try poolView.redeemLocalCheckOnRemote(cp, amountSD) returns (PoolView.ChainPathState memory newCP) {\\n            _poolStates[poolIndex].chainPaths[cpIndex] = newCP;\\n        } catch {}\\n    }\\n\\n    function _remotePrecrimeAddress(\\n        Packet[] calldata _packets\\n    ) internal view override returns (uint16[] memory chainIds, bytes32[] memory precrimeAddresses) {\\n        if (_packets.length == 0) {\\n            return (remoteChainIds, remotePrecrimeAddresses);\\n        }\\n\\n        // only return related remotes\\n        uint16 size = _getRelatedRemoteSize(_packets);\\n        if (size > 0) {\\n            chainIds = new uint16[](size);\\n            uint256 k = 0;\\n            precrimeAddresses = new bytes32[](size);\\n            for (uint16 i = 0; i < remoteChainIds.length; i++) {\\n                for (uint16 j = 0; j < _packets.length; j++) {\\n                    uint16 srcChainId = _packets[j].srcChainId;\\n                    if (remoteChainIds[i] == srcChainId) {\\n                        chainIds[k] = srcChainId;\\n                        precrimeAddresses[k] = remotePrecrimeAddresses[i];\\n                        k++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    function _getRelatedRemoteSize(Packet[] memory _packets) internal view returns (uint16 size) {\\n        for (uint16 i = 0; i < remoteChainIds.length; i++) {\\n            for (uint16 j = 0; j < _packets.length; j++) {\\n                if (remoteChainIds[i] == _packets[j].srcChainId) {\\n                    size++;\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n\\n    function _maxBatchSize() internal view virtual override returns (uint64) {\\n        return maxBatchSize;\\n    }\\n\\n    function _isPacketFromTrustedRemote(Packet memory _packet) internal view returns (bool) {\\n        bytes memory path = stargateRouter.bridge().bridgeLookup(_packet.srcChainId);\\n        if (path.length > 20) {\\n            // path style: remote + local\\n            path = path.slice(0, path.length - 20);\\n        }\\n        require(path.length <= 32, \\\"invalid remote address loopup path\\\");\\n        uint256 remoteAddressLength = path.length;\\n        uint256 mask = (2 ** (remoteAddressLength * 8)) - 1;\\n        bytes32 remoteUaAddress;\\n        assembly {\\n            remoteUaAddress := and(mload(add(path, remoteAddressLength)), mask)\\n        }\\n        return remoteUaAddress == _packet.srcAddress;\\n    }\\n}\\n\",\"keccak256\":\"0x1e67f4ec280c60fc385da32b8ac2b9894524def26dc0fce848e7daf3bee70cd3\",\"license\":\"GPL-3.0-only\"},\"contracts/util/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\\u00e7alo S\\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity >=0.7.0 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary BytesLib {\\n    using SafeMath for uint256;\\n\\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\\n        require(_length.add(31) >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start.add(_length), \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\n        require(_bytes.length >= _start.add(2), \\\"toUint16_outOfBounds\\\");\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n        require(_bytes.length >= _start.add(32), \\\"toBytes32_outOfBounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= _start.add(20), \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n}\\n\",\"keccak256\":\"0x580c87b745723de63be6c491f466ec72eda9f8b7a8d498fe325da90602d5d318\",\"license\":\"Unlicense\"},\"contracts/util/StringLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n/*\\n * @title String & slice utility library for Solidity contracts.\\n * @author Nick Johnson <arachnid@notdot.net>\\n *\\n * https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.t.sol\\n *\\n * @dev Functionality in this library is largely implemented using an\\n *      abstraction called a 'slice'. A slice represents a part of a string -\\n *      anything from the entire string to a single character, or even no\\n *      characters at all (a 0-length slice). Since a slice only has to specify\\n *      an offset and a length, copying and manipulating slices is a lot less\\n *      expensive than copying and manipulating the strings they reference.\\n *\\n *      To further reduce gas costs, most functions on slice that need to return\\n *      a slice modify the original one instead of allocating a new one; for\\n *      instance, `s.split(\\\".\\\")` will return the text up to the first '.',\\n *      modifying s to only contain the remainder of the string after the '.'.\\n *      In situations where you do not want to modify the original slice, you\\n *      can make a copy first with `.copy()`, for example:\\n *      `s.copy().split(\\\".\\\")`. Try and avoid using this idiom in loops; since\\n *      Solidity has no memory management, it will result in allocating many\\n *      short-lived slices that are later discarded.\\n *\\n *      Functions that return two slices come in two versions: a non-allocating\\n *      version that takes the second slice as an argument, modifying it in\\n *      place, and an allocating version that allocates and returns the second\\n *      slice; see `nextRune` for example.\\n *\\n *      Functions that have to copy string data will return strings rather than\\n *      slices; these can be cast back to slices for further processing if\\n *      required.\\n *\\n *      For convenience, some functions are provided with non-modifying\\n *      variants that create a new slice and return both; for instance,\\n *      `s.splitNew('.')` leaves s unmodified, and returns two values\\n *      corresponding to the left and right parts of the string.\\n */\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary strings {\\n    using SafeMath for uint256;\\n\\n    struct slice {\\n        uint _len;\\n        uint _ptr;\\n    }\\n\\n    function memcpy(uint dest, uint src, uint len) private pure {\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest = dest.add(32);\\n            src = src.add(32);\\n        }\\n\\n        // Copy remaining bytes\\n        uint mask = type(uint).max;\\n        if (len > 0) {\\n            mask = 256 ** (32 - len) - 1;\\n        }\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns a slice containing the entire string.\\n     * @param self The string to make a slice from.\\n     * @return A newly allocated slice containing the entire string.\\n     */\\n    function toSlice(string memory self) internal pure returns (slice memory) {\\n        uint ptr;\\n        assembly {\\n            ptr := add(self, 0x20)\\n        }\\n        return slice(bytes(self).length, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns true if `self` starts with `needle`.\\n     * @param self The slice to operate on.\\n     * @param needle The slice to search for.\\n     * @return True if the slice starts with the provided text, false otherwise.\\n     */\\n    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\\n        if (self._len < needle._len) {\\n            return false;\\n        }\\n\\n        if (self._ptr == needle._ptr) {\\n            return true;\\n        }\\n\\n        bool equal;\\n        assembly {\\n            let length := mload(needle)\\n            let selfptr := mload(add(self, 0x20))\\n            let needleptr := mload(add(needle, 0x20))\\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n        }\\n        return equal;\\n    }\\n\\n    /*\\n     * @dev If `self` starts with `needle`, `needle` is removed from the\\n     *      beginning of `self`. Otherwise, `self` is unmodified.\\n     * @param self The slice to operate on.\\n     * @param needle The slice to search for.\\n     * @return `self`\\n     */\\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\\n        if (self._len < needle._len) {\\n            return self;\\n        }\\n\\n        bool equal = true;\\n        if (self._ptr != needle._ptr) {\\n            assembly {\\n                let length := mload(needle)\\n                let selfptr := mload(add(self, 0x20))\\n                let needleptr := mload(add(needle, 0x20))\\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n            }\\n        }\\n\\n        if (equal) {\\n            self._len = self._len.sub(needle._len);\\n            self._ptr = self._ptr.add(needle._len);\\n        }\\n\\n        return self;\\n    }\\n\\n    /*\\n     * @dev Copies a slice to a new string.\\n     * @param self The slice to copy.\\n     * @return A newly allocated string containing the slice's text.\\n     */\\n    function toString(slice memory self) internal pure returns (string memory) {\\n        string memory ret = new string(self._len);\\n        uint retptr;\\n        assembly {\\n            retptr := add(ret, 32)\\n        }\\n\\n        memcpy(retptr, self._ptr, self._len);\\n        return ret;\\n    }\\n\\n    /*\\n     * @dev Returns a newly allocated string containing the concatenation of\\n     *      `self` and `other`.\\n     * @param self The first slice to concatenate.\\n     * @param other The second slice to concatenate.\\n     * @return The concatenation of the two strings.\\n     */\\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\\n        string memory ret = new string(self._len.add(other._len));\\n        uint retptr;\\n        assembly {\\n            retptr := add(ret, 32)\\n        }\\n        memcpy(retptr, self._ptr, self._len);\\n        memcpy(retptr.add(self._len), other._ptr, other._len);\\n        return ret;\\n    }\\n}\\n\",\"keccak256\":\"0xc420938242520bb7a6c9481a90dc74f29b5ffd3c9b6fd0ee1f08fd4718e96fd3\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b506040516200481038038062004810833981016040819052620000349162000503565b85600062000041620000e4565b600080546001600160a01b0319166001600160a01b0383169081178255604051929350917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a3506000805461ffff909216600160a01b0261ffff60a01b19909216919091179055620000b685620000e8565b620000c18462000172565b620000cc83620001fc565b620000d8828262000286565b5050505050506200069a565b3390565b620000f2620000e4565b6001600160a01b0316620001056200034b565b6001600160a01b03161462000150576040805162461bcd60e51b81526020600482018190526024820152600080516020620047f0833981519152604482015290519081900360640190fd5b600180546001600160a01b0319166001600160a01b0392909216919091179055565b6200017c620000e4565b6001600160a01b03166200018f6200034b565b6001600160a01b031614620001da576040805162461bcd60e51b81526020600482018190526024820152600080516020620047f0833981519152604482015290519081900360640190fd5b600280546001600160a01b0319166001600160a01b0392909216919091179055565b62000206620000e4565b6001600160a01b0316620002196200034b565b6001600160a01b03161462000264576040805162461bcd60e51b81526020600482018190526024820152600080516020620047f0833981519152604482015290519081900360640190fd5b600580546001600160401b0319166001600160401b0392909216919091179055565b62000290620000e4565b6001600160a01b0316620002a36200034b565b6001600160a01b031614620002ee576040805162461bcd60e51b81526020600482018190526024820152600080516020620047f0833981519152604482015290519081900360640190fd5b80518251146200031b5760405162461bcd60e51b8152600401620003129062000621565b60405180910390fd5b8151620003309060039060208501906200035a565b508051620003469060049060208401906200040a565b505050565b6000546001600160a01b031690565b82805482825590600052602060002090600f01601090048101928215620003f85791602002820160005b83821115620003c657835183826101000a81548161ffff021916908361ffff160217905550926020019260020160208160010104928301926001030262000384565b8015620003f65782816101000a81549061ffff0219169055600201602081600101049283019260010302620003c6565b505b506200040692915062000448565b5090565b828054828255906000526020600020908101928215620003f8579160200282015b82811115620003f85782518255916020019190600101906200042b565b5b8082111562000406576000815560010162000449565b80516001600160a01b03811681146200047757600080fd5b919050565b600082601f8301126200048d578081fd5b81516020620004a6620004a0836200067c565b62000658565b8281528181019085830183850287018401881015620004c3578586fd5b855b85811015620004e357815184529284019290840190600101620004c5565b5090979650505050505050565b805161ffff811681146200047757600080fd5b60008060008060008060c087890312156200051c578182fd5b6200052787620004f0565b95506020620005388189016200045f565b955062000548604089016200045f565b60608901519095506001600160401b03808216821462000566578485fd5b60808a0151919550808211156200057b578485fd5b818a0191508a601f8301126200058f578485fd5b8151620005a0620004a0826200067c565b81815284810190848601868402860187018f1015620005bd578889fd5b8895505b83861015620005ea57620005d581620004f0565b835260019590950194918601918601620005c1565b5060a08d0151909750945050508083111562000604578384fd5b50506200061489828a016200047c565b9150509295509295509295565b6020808252601e908201527f53746172676174655072656372696d653a20696e76616c69642073697a650000604082015260600190565b6040518181016001600160401b03811182821017156200067457fe5b604052919050565b60006001600160401b038211156200069057fe5b5060209081020190565b61414680620006aa6000396000f3fe608060405234801561001057600080fd5b50600436106101a95760003560e01c8063715018a6116100f9578063bb96836811610097578063ec67df3011610071578063ec67df301461030d578063f0099e2a1461032e578063f2fde38b14610341578063f95d1404146101f1576101a9565b8063bb968368146102ea578063c6be4b9b146102fd578063e5bc030314610305576101a9565b80639590dc9d116100d35780639590dc9d1461029c5780639eb51f5b146102bc578063a9e56f3c146102cf578063afea44ef146102d7576101a9565b8063715018a61461026c5780638971efff146102745780638da5cb5b14610287576101a9565b8063472641c11161016657806351b78b471161014057806351b78b471461024157806354fd4d50146102545780635b056da51461025c5780636eb3d2a514610264576101a9565b8063472641c1146101f15780634979e3711461020e5780634e0ab1ab14610221576101a9565b80630638fb64146101ae5780630e735a63146101cc57806317c9efb0146101d45780632913daa0146101dc57806334e30097146101f157806337de4ba1146101f9575b600080fd5b6101b6610354565b6040516101c39190613e95565b60405180910390f35b6101b6610359565b6101b661035e565b6101e4610363565b6040516101c39190613ec1565b6101b6610372565b61020c610207366004613193565b610377565b005b61020c61021c36600461315b565b610403565b61023461022f366004613535565b610487565b6040516101c39190613b73565b61020c61024f36600461315b565b6104a8565b6101b661052c565b6101b6610531565b610234610542565b61020c610548565b61020c610282366004613535565b6105f4565b61028f61065b565b6040516101c39190613a6f565b6102af6102aa366004613193565b61066a565b6040516101c39190613b7c565b6101b66102ca366004613535565b6106b9565b61028f6106f1565b61020c6102e5366004613565565b610700565b61020c6102f836600461323a565b610785565b6101b6610834565b61028f610839565b61032061031b3660046131d2565b610848565b6040516101c3929190613ea4565b61032061033c366004613193565b61099d565b61020c61034f36600461315b565b610c63565b600281565b600381565b600081565b6005546001600160401b031681565b600181565b33301461038357600080fd5b6000806103908484610d65565b91509150604051806040016040528060138152602001722f39b4b6bab630ba34b7b7103932b9bab63a2f60691b81525082826040516020016103d4939291906138c0565b60408051601f198184030181529082905262461bcd60e51b82526103fa91600401613b7c565b60405180910390fd5b61040b610e1e565b6001600160a01b031661041c61065b565b6001600160a01b031614610465576040805162461bcd60e51b815260206004820181905260248201526000805160206140f1833981519152604482015290519081900360640190fd5b600280546001600160a01b0319166001600160a01b0392909216919091179055565b6004818154811061049757600080fd5b600091825260209091200154905081565b6104b0610e1e565b6001600160a01b03166104c161065b565b6001600160a01b03161461050a576040805162461bcd60e51b815260206004820181905260248201526000805160206140f1833981519152604482015290519081900360640190fd5b600180546001600160a01b0319166001600160a01b0392909216919091179055565b600190565b600054600160a01b900461ffff1681565b60065481565b610550610e1e565b6001600160a01b031661056161065b565b6001600160a01b0316146105aa576040805162461bcd60e51b815260206004820181905260248201526000805160206140f1833981519152604482015290519081900360640190fd5b600080546040516001600160a01b03909116907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908390a3600080546001600160a01b0319169055565b6105fc610e1e565b6001600160a01b031661060d61065b565b6001600160a01b031614610656576040805162461bcd60e51b815260206004820181905260248201526000805160206140f1833981519152604482015290519081900360640190fd5b600655565b6000546001600160a01b031690565b60606000806106798585610e22565b9150915060016106876110c1565b8351848460405160200161069f9594939291906139e3565b604051602081830303815290604052925050505b92915050565b600381815481106106c957600080fd5b9060005260206000209060109182820401919006600202915054906101000a900461ffff1681565b6001546001600160a01b031681565b610708610e1e565b6001600160a01b031661071961065b565b6001600160a01b031614610762576040805162461bcd60e51b815260206004820181905260248201526000805160206140f1833981519152604482015290519081900360640190fd5b6005805467ffffffffffffffff19166001600160401b0392909216919091179055565b61078d610e1e565b6001600160a01b031661079e61065b565b6001600160a01b0316146107e7576040805162461bcd60e51b815260206004820181905260248201526000805160206140f1833981519152604482015290519081900360640190fd5b80518251146108085760405162461bcd60e51b81526004016103fa90613bdc565b815161081b906003906020850190612b68565b50805161082f906004906020840190612c11565b505050565b600481565b6002546001600160a01b031681565b6000606081836001600160401b038111801561086357600080fd5b5060405190808252806020026020018201604052801561089757816020015b60608152602001906001900390816108825790505b5090506000846001600160401b03811180156108b257600080fd5b506040519080825280602002602001820160405280156108dc578160200160208202803683370190505b50905060005b85811015610961576000808888848181106108f957fe5b905060200281019061090b9190613ed5565b81019061091891906134f2565b915091508184848151811061092957fe5b602002602001019061ffff16908161ffff16815250508085848151811061094c57fe5b602090810291909101015250506001016108e2565b5061096d8888836110d0565b909450925061ffff841615610983575050610994565b61098c82611252565b909450925050505b94509492505050565b6000606060006109ab6110c1565b90506001600160401b0381168411156109fb5760026109d2826001600160401b0316611486565b6040516020016109e29190613907565b6040516020818303038152906040529250925050610c5c565b8315610b445760008080805b87811015610b3f576000898983818110610a1d57fe5b9050602002810190610a2f9190613f19565b610a3890613fdd565b90508461ffff16816000015161ffff16141580610a59575083816020015114155b15610ada57805160208201516040830151919650945092506000610a7c82611562565b6001019050806001600160401b0316846001600160401b031614610ad4576003610aa584611486565b604051602001610ab5919061394c565b6040516020818303038152906040529850985050505050505050610c5c565b50610b36565b826001019250826001600160401b031681604001516001600160401b031614610b36576003610b0883611486565b604051602001610b18919061399e565b60405160208183030381529060405297509750505050505050610c5c565b50600101610a07565b505050505b600080306001600160a01b03166337de4ba160e01b8888604051602401610b6c929190613a83565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b0319909416939093179092529051610baa91906138a4565b600060405180830381855afa9150503d8060008114610be5576040519150601f19603f3d011682016040523d82523d6000602084013e610bea565b606091505b50915091508115610c0f578060405162461bcd60e51b81526004016103fa9190613b7c565b610c1881611782565b909550935061ffff8516610c5857600054604051610c4691600160a01b900461ffff16908690602001613ea4565b60405160208183030381529060405293505b5050505b9250929050565b610c6b610e1e565b6001600160a01b0316610c7c61065b565b6001600160a01b031614610cc5576040805162461bcd60e51b815260206004820181905260248201526000805160206140f1833981519152604482015290519081900360640190fd5b6001600160a01b038116610d0a5760405162461bcd60e51b81526004018080602001828103825260268152602001806140936026913960400191505060405180910390fd5b600080546040516001600160a01b03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b0319166001600160a01b0392909216919091179055565b60006060600080610d7461187c565b9150915060005b85811015610dd0576000878783818110610d9157fe5b9050602002810190610da39190613f19565b610dac90613fdd565b9050610db781611b6d565b15610dc757610dc7848483611ce0565b50600101610d7b565b5060408051808201825260008054600160a01b900461ffff168252602080830185905292519092610e02929101613dc2565b6040516020818303038152906040529350935050509250929050565b3390565b60608082610f03576003600481805480602002602001604051908101604052809291908181526020018280548015610ea157602002820191906000526020600020906000905b82829054906101000a900461ffff1661ffff1681526020019060020190602082600101049283019260010382029150808411610e685790505b5050505050915080805480602002602001604051908101604052809291908181526020018280548015610ef357602002820191906000526020600020905b815481526020019060010190808311610edf575b5050505050905091509150610c5c565b6000610f17610f128587613f8f565b611d67565b905061ffff8116156110b9578061ffff166001600160401b0381118015610f3d57600080fd5b50604051908082528060200260200182016040528015610f67578160200160208202803683370190505b50925060008161ffff166001600160401b0381118015610f8657600080fd5b50604051908082528060200260200182016040528015610fb0578160200160208202803683370190505b50925060005b60035461ffff82161015610c585760005b61ffff81168711156110b057600088888361ffff16818110610fe557fe5b9050602002810190610ff79190613f19565b6110059060208101906134d6565b90508061ffff1660038461ffff168154811061101d57fe5b60009182526020909120601082040154600f9091166002026101000a900461ffff1614156110a7578087858151811061105257fe5b602002602001019061ffff16908161ffff168152505060048361ffff168154811061107957fe5b906000526020600020015486858151811061109057fe5b6020908102919091010152506001909201916110b0565b50600101610fc7565b50600101610fb6565b509250929050565b6005546001600160401b031690565b60006060831561119f5760006110e68686610e22565b50905060005b815181101561119c576000805b86518110156111495783838151811061110e57fe5b602002602001015161ffff1687828151811061112657fe5b602002602001015161ffff1614156111415760019150611149565b6001016110f9565b50806111935760046040518060400160405280602081526020017f6d697373696e672072656d6f74652073696d756c6174696f6e20726573756c748152509450945050505061124a565b506001016110ec565b50505b6000805b84518110156111f057600060149054906101000a900461ffff1661ffff168582815181106111cd57fe5b602002602001015161ffff1614156111e857600191506111f0565b6001016111a3565b508061123557505060408051808201909152601f81527f6d697373696e67206c6f63616c2073696d756c6174696f6e20726573756c740060208201526004915061124a565b50506040805160208101909152600080825291505b935093915050565b6000606061125e612c4c565b600084516001600160401b038111801561127757600080fd5b506040519080825280602002602001820160405280156112b157816020015b61129e612c4c565b8152602001906001900390816112965790505b50905060005b8551811015611354578581815181106112cc57fe5b60200260200101518060200190518101906112e791906133fa565b8282815181106112f357fe5b6020026020010181905250600060149054906101000a900461ffff1661ffff1682828151811061131f57fe5b60200260200101516000015161ffff16141561134c5781818151811061134157fe5b602002602001015192505b6001016112b7565b5060005b8260200151518110156114675760008360200151828151811061137757fe5b6020026020010151905061138a81611e04565b909650945061ffff8616156113a25750505050611481565b60005b81602001515181101561145d576000826020015182815181106113c457fe5b602002602001015190508060c00151156114545760006113ed8683600001518460200151611ef2565b90506113f881611e04565b909950975061ffff8916156114135750505050505050611481565b60006114288289600001518760000151611f73565b5090506114358382612021565b909a50985061ffff8a1615611451575050505050505050611481565b50505b506001016113a5565b5050600101611358565b506000604051806020016040528060008152509350935050505b915091565b6060816114ab57506040805180820190915260018152600360fc1b602082015261155d565b8160005b81156114c357600101600a820491506114af565b6000816001600160401b03811180156114db57600080fd5b506040519080825280601f01601f191660200182016040528015611506576020820181803683370190505b50859350905060001982015b831561155757600a840660300160f81b8282806001900393508151811061153557fe5b60200101906001600160f81b031916908160001a905350600a84049350611512565b50925050505b919050565b602080820151600154604080516373c6754960e11b81529051600094859385936001600160a01b039091169263e78cea9292600480840193919291829003018186803b1580156115b157600080fd5b505afa1580156115c5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115e99190613177565b6040516020016115fa92919061387d565b60408051601f198184030181528282526001546373c6754960e11b845291519093506000926001600160a01b039092169163e78cea92916004808301926020929190829003018186803b15801561165057600080fd5b505afa158015611664573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116889190613177565b6001600160a01b03166307968db16040518163ffffffff1660e01b815260040160206040518083038186803b1580156116c057600080fd5b505afa1580156116d4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116f89190613177565b8551604051630fdc07c760e41b81529192506001600160a01b0383169163fdc07c7091611729918690600401613ea4565b60206040518083038186803b15801561174157600080fd5b505afa158015611755573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117799190613581565b95945050505050565b600060606004835110156117aa578260405162461bcd60e51b81526004016103fa9190613b7c565b6004830190506000818060200190518101906117c69190613333565b905060006117d382612094565b9050600061180b604051806040016040528060138152602001722f39b4b6bab630ba34b7b7103932b9bab63a2f60691b815250612094565b905061181782826120b9565b611835578560405162461bcd60e51b81526004016103fa9190613b7c565b600061184961184484846120fd565b612170565b90506118568160006121de565b9550611871600280835103836122409092919063ffffffff16565b945050505050915091565b6060806000600160009054906101000a90046001600160a01b03166001600160a01b031663c45a01556040518163ffffffff1660e01b815260040160206040518083038186803b1580156118cf57600080fd5b505afa1580156118e3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119079190613177565b90506000816001600160a01b031663efde4e646040518163ffffffff1660e01b815260040160206040518083038186803b15801561194457600080fd5b505afa158015611958573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061197c919061354d565b90506000816001600160401b038111801561199657600080fd5b506040519080825280602002602001820160405280156119d057816020015b6119bd612c64565b8152602001906001900390816119b55790505b5090506000826001600160401b03811180156119eb57600080fd5b50604051908082528060200260200182016040528015611a15578160200160208202803683370190505b50905060005b83811015611b62576040516341d1de9760e01b81526000906001600160a01b038716906341d1de9790611a52908590600401613b73565b60206040518083038186803b158015611a6a57600080fd5b505afa158015611a7e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611aa29190613177565b905080838381518110611ab157fe5b6001600160a01b03928316602091820292909201015260025460405163ec04205b60e01b815291169063ec04205b90611aee908490600401613a6f565b60006040518083038186803b158015611b0657600080fd5b505afa158015611b1a573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611b4291908101906133c8565b848381518110611b4e57fe5b602090810291909101015250600101611a1b565b509450925050509091565b600080600160009054906101000a90046001600160a01b03166001600160a01b031663e78cea926040518163ffffffff1660e01b815260040160206040518083038186803b158015611bbe57600080fd5b505afa158015611bd2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611bf69190613177565b835160405163471daeb560e11b81526001600160a01b039290921691638e3b5d6a91611c2491600401613e95565b60006040518083038186803b158015611c3c57600080fd5b505afa158015611c50573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611c7891908101906132f9565b9050601481511115611c9b578051611c9890829060009060131901612240565b90505b602081511115611cbd5760405162461bcd60e51b81526004016103fa90613c13565b8051908101516020840151600019600890930260020a9290920116149050919050565b606081015160208101519060ff821660011415611d0c57611d078585856000015184612357565b611d60565b60ff821660021415611d2857611d07858585600001518461250c565b60ff821660031415611d4457611d078585856000015184612611565b60ff821660041415611d6057611d6085858560000151846127cb565b5050505050565b6000805b60035461ffff82161015611dfe5760005b83518161ffff161015611df557838161ffff1681518110611d9957fe5b60200260200101516000015161ffff1660038361ffff1681548110611dba57fe5b60009182526020909120601082040154600f9091166002026101000a900461ffff161415611ded57600190920191611df5565b600101611d7c565b50600101611d6b565b50919050565b604081015160800151600090606090825b846020015151811015611e6e57600085602001518281518110611e3457fe5b60200260200101519050611e638160800151611e5d83606001518661295890919063ffffffff16565b90612958565b925050600101611e15565b50604080850151908101516020820151606083015160a090930151600093611ea59392611e9f9290918391906129b2565b906129b2565b905080821115611ed55760016040518060600160405280603c8152602001614057603c9139935093505050611481565b600060405180602001604052806000815250935093505050915091565b611efa612c64565b6000611f068585612a0f565b905060005b816020015151811015611f5357600082602001518281518110611f2a57fe5b602002602001015190508481600001511415611f4a579250611f6c915050565b50600101611f0b565b5060405162461bcd60e51b81526004016103fa90613cde565b9392505050565b611f7b612c8a565b6000805b856020015151811015612008578461ffff1686602001518281518110611fa157fe5b60200260200101516000015161ffff16148015611fd857508386602001518281518110611fca57fe5b602002602001015160200151145b156120005785602001518181518110611fed57fe5b602002602001015181925092505061124a565b600101611f7f565b5060405162461bcd60e51b81526004016103fa90613c98565b600060608260400151612050600654611e5d620f424088606001518161204357fe5b60608a0151919004612958565b101561207a5760016040518060600160405280603881526020016140b96038913991509150610c5c565b505060408051602081019091526000808252909250929050565b61209c612ccd565b506040805180820190915281518152602082810190820152919050565b8051825160009111156120ce575060006106b3565b8160200151836020015114156120e6575060016106b3565b508051602092830151929091015181902091201490565b612105612ccd565b8151835110156121165750816106b3565b602080830151908401516001911461213d5750815160208481015190840151829020919020145b80156121685782518451612150916129b2565b84528251602085015161216291612958565b60208501525b509192915050565b6060600082600001516001600160401b038111801561218e57600080fd5b506040519080825280601f01601f1916602001820160405280156121b9576020820181803683370190505b50905060006020820190506121d78185602001518660000151612a7a565b5092915050565b60006121eb826002612958565b83511015612237576040805162461bcd60e51b8152602060048201526014602482015273746f55696e7431365f6f75744f66426f756e647360601b604482015290519081900360640190fd5b50016002015190565b60608161224e81601f612958565b1015612292576040805162461bcd60e51b815260206004820152600e60248201526d736c6963655f6f766572666c6f7760901b604482015290519081900360640190fd5b61229c8383612958565b845110156122e5576040805162461bcd60e51b8152602060048201526011602482015270736c6963655f6f75744f66426f756e647360781b604482015290519081900360640190fd5b606082158015612304576040519150600082526020820160405261234e565b6040519150601f8416801560200281840101858101878315602002848b0101015b8183101561233d578051835260209283019201612325565b5050858452601f01601f1916604052505b50949350505050565b6000806000808480602001905181019061237191906136df565b50509550955050945094505060008061238b8a8a87612ad3565b925092505060008061239e848b8a611f73565b600254604051636ab202d360e01b81529294509092506001600160a01b031690636ab202d3906123d49085908a90600401613d24565b60e06040518083038186803b1580156123ec57600080fd5b505afa158015612400573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906124249190613378565b600254604080870151905163ea8683cd60e01b81529294506001600160a01b039091169163ea8683cd9161245e9186908a90600401613d68565b6101a06040518083038186803b15801561247757600080fd5b505afa9250505080156124a7575060408051601f3d908101601f191682019092526124a491810190613393565b60015b6124b0576124fe565b818d86815181106124bd57fe5b602002602001015160400181905250808d86815181106124d957fe5b60200260200101516020015184815181106124f057fe5b602002602001018190525050505b505050505050505050505050565b600080600083806020019051810190612525919061359d565b9350935093505060008061253a898986612ad3565b925092505060008061254d848a89611f73565b600254604051636ab202d360e01b81529294509092506001600160a01b031690636ab202d3906125839085908990600401613d24565b60e06040518083038186803b15801561259b57600080fd5b505afa1580156125af573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125d39190613378565b9150818a84815181106125e257fe5b60200260200101516020015182815181106125f957fe5b60200260200101819052505050505050505050505050565b60008060008060008580602001905181019061262d919061365b565b5095509550955095509550506000806126478b8b88612ad3565b925092505060008061265a848c8b611f73565b600254604051636ab202d360e01b81529294509092506001600160a01b031690636ab202d3906126909085908b90600401613d24565b60e06040518083038186803b1580156126a857600080fd5b505afa1580156126bc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126e09190613378565b600254604080870151905163072666b160e41b81529294506001600160a01b03909116916372666b109161271c9186908b908b90600401613d92565b6101a06040518083038186803b15801561273557600080fd5b505afa925050508015612765575060408051601f3d908101601f1916820190925261276291810190613393565b60015b61276e576127bc565b818e868151811061277b57fe5b602002602001015160400181905250808e868151811061279757fe5b60200260200101516020015184815181106127ae57fe5b602002602001018190525050505b50505050505050505050505050565b600080600080848060200190518101906127e591906135e3565b509450945094509450506000806127fd8a8a87612ad3565b9250925050600080612810848b8a611f73565b600254604051636ab202d360e01b81529294509092506001600160a01b031690636ab202d3906128469085908a90600401613d24565b60e06040518083038186803b15801561285e57600080fd5b505afa158015612872573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906128969190613378565b6002546040516317b597d960e01b81529193506001600160a01b0316906317b597d9906128c99085908990600401613d4c565b60e06040518083038186803b1580156128e157600080fd5b505afa925050508015612911575060408051601f3d908101601f1916820190925261290e91810190613378565b60015b61291a576124fe565b808c858151811061292757fe5b602002602001015160200151838151811061293e57fe5b602002602001018190525050505050505050505050505050565b600082820183811015611f6c576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b600082821115612a09576040805162461bcd60e51b815260206004820152601e60248201527f536166654d6174683a207375627472616374696f6e206f766572666c6f770000604482015290519081900360640190fd5b50900390565b612a17612c4c565b60005b8351811015612a61576000848281518110612a3157fe5b602002602001015190508361ffff16816000015161ffff161415612a585791506106b39050565b50600101612a1a565b5060405162461bcd60e51b81526004016103fa90613b8f565b60208110612aa95781518352612a91836020612958565b9250612a9e826020612958565b9150601f1901612a7a565b6000198115612ac0576001826020036101000a0390505b9151835183169219169190911790915250565b6000612add612c64565b6000805b8551811015612b465784868281518110612af757fe5b6020026020010151600001511415612b3e57868181518110612b1557fe5b6020026020010151868281518110612b2957fe5b60200260200101518293509350935050612b5f565b600101612ae1565b5060405162461bcd60e51b81526004016103fa90613c55565b93509350939050565b82805482825590600052602060002090600f01601090048101928215612c015791602002820160005b83821115612bd157835183826101000a81548161ffff021916908361ffff1602179055509260200192600201602081600101049283019260010302612b91565b8015612bff5782816101000a81549061ffff0219169055600201602081600101049283019260010302612bd1565b505b50612c0d929150612ce7565b5090565b828054828255906000526020600020908101928215612c01579160200282015b82811115612c01578251825591602001919060010190612c31565b60408051808201909152600081526060602082015290565b60405180606001604052806000815260200160608152602001612c85612cfc565b905290565b6040518060e00160405280600061ffff16815260200160008152602001600081526020016000815260200160008152602001600081526020016000151581525090565b604051806040016040528060008152602001600081525090565b5b80821115612c0d5760008155600101612ce8565b6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6000612d45612d4084613f6e565b613f2e565b9050828152838383011115612d5957600080fd5b611f6c836020830184613fe9565b600082601f830112612d77578081fd5b81356020612d87612d4083613f51565b8281528181019085830183850287018401881015612da3578586fd5b855b85811015612dc157813584529284019290840190600101612da5565b5090979650505050505050565b60008083601f840112612ddf578182fd5b5081356001600160401b03811115612df5578182fd5b6020830191508360208083028501011115610c5c57600080fd5b8051801515811461155d57600080fd5b600082601f830112612e2f578081fd5b8135612e3d612d4082613f6e565b818152846020838601011115612e51578283fd5b816020850160208301379081016020019190915292915050565b600082601f830112612e7b578081fd5b611f6c83835160208501612d32565b600060e08284031215612e9b578081fd5b60405160e081018181106001600160401b0382111715612eb757fe5b604052905080612ec68361313f565b81526020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a0820152612f0660c08401612e0f565b60c08201525092915050565b600060408284031215612f23578081fd5b604051604081018181106001600160401b0382111715612f3f57fe5b604052825181526020928301519281019290925250919050565b600060808284031215612f6a578081fd5b604051608081016001600160401b038282108183111715612f8757fe5b8160405282935084359150612f9b82614031565b8183526020850135602084015260408501359150612fb882614041565b8160408401526060850135915080821115612fd257600080fd5b50612fdf85828601612e1f565b6060830152505092915050565b600060c08284031215612ffd578081fd5b60405160c081018181106001600160401b038211171561301957fe5b8060405250809150825181526020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a08201525092915050565b60006101008284031215613070578081fd5b604051606081016001600160401b03828210818311171561308d57fe5b81604052829350845183526020915081850151818111156130ad57600080fd5b85019050601f810186136130c057600080fd5b80516130ce612d4082613f51565b8181528381019083850160e0808502860187018b10156130ed57600080fd5b600095505b8486101561311a576131048b83612e8a565b84526001959095019492860192908101906130f2565b5050808587015250505050506131338460408501612fec565b60408201525092915050565b805161155d81614031565b805160ff8116811461155d57600080fd5b60006020828403121561316c578081fd5b8135611f6c81614019565b600060208284031215613188578081fd5b8151611f6c81614019565b600080602083850312156131a5578081fd5b82356001600160401b038111156131ba578182fd5b6131c685828601612dce565b90969095509350505050565b600080600080604085870312156131e7578182fd5b84356001600160401b03808211156131fd578384fd5b61320988838901612dce565b90965094506020870135915080821115613221578384fd5b5061322e87828801612dce565b95989497509550505050565b6000806040838503121561324c578182fd5b82356001600160401b0380821115613262578384fd5b818501915085601f830112613275578384fd5b81356020613285612d4083613f51565b82815281810190858301838502870184018b10156132a1578889fd5b8896505b848710156132cc5780356132b881614031565b8352600196909601959183019183016132a5565b50965050860135925050808211156132e2578283fd5b506132ef85828601612d67565b9150509250929050565b60006020828403121561330a578081fd5b81516001600160401b0381111561331f578182fd5b61332b84828501612e6b565b949350505050565b600060208284031215613344578081fd5b81516001600160401b03811115613359578182fd5b8201601f81018413613369578182fd5b61332b84825160208401612d32565b600060e08284031215613389578081fd5b611f6c8383612e8a565b6000806101a083850312156133a6578182fd5b6133b08484612fec565b91506133bf8460c08501612e8a565b90509250929050565b6000602082840312156133d9578081fd5b81516001600160401b038111156133ee578182fd5b61332b8482850161305e565b6000602080838503121561340c578182fd5b82516001600160401b0380821115613422578384fd5b9084019060408287031215613435578384fd5b60405160408101818110838211171561344a57fe5b604052825161345881614031565b8152828401518281111561346a578586fd5b80840193505086601f84011261347e578485fd5b8251915061348e612d4083613f51565b82815284810190848601875b858110156134c3576134b18b8984518a010161305e565b8452928701929087019060010161349a565b5050948201949094529695505050505050565b6000602082840312156134e7578081fd5b8135611f6c81614031565b60008060408385031215613504578182fd5b823561350f81614031565b915060208301356001600160401b03811115613529578182fd5b6132ef85828601612e1f565b600060208284031215613546578081fd5b5035919050565b60006020828403121561355e578081fd5b5051919050565b600060208284031215613576578081fd5b8135611f6c81614041565b600060208284031215613592578081fd5b8151611f6c81614041565b60008060008060a085870312156135b2578182fd5b6135bb8561314a565b935060208501519250604085015191506135d88660608701612f12565b905092959194509250565b60008060008060008060e087890312156135fb578384fd5b6136048761314a565b955060208701519450604087015193506136218860608901612f12565b925060a0870151915060c08701516001600160401b03811115613642578182fd5b61364e89828a01612e6b565b9150509295509295509295565b6000806000806000806000610100888a031215613676578485fd5b61367f8861314a565b9650602088015195506040880151945061369c8960608a01612f12565b935060a0880151925060c0880151915060e08801516001600160401b038111156136c4578182fd5b6136d08a828b01612e6b565b91505092959891949750929550565b6000806000806000806000806101c0898b0312156136fb578182fd5b6137048961314a565b97506020890151965060408901519550606089015194506137288a60808b01612f12565b93506137378a60c08b01612fec565b92506101808901516001600160401b0380821115613753578384fd5b61375f8c838d01612e6b565b93506101a08b0151915080821115613775578283fd5b506137828b828c01612e6b565b9150509295985092959890939650565b60008284528282602086013780602084860101526020601f19601f85011685010190509392505050565b600081518084526137d4816020860160208601613fe9565b601f01601f19169290920160200192915050565b61ffff81511682526020810151602083015260408101516040830152606081015160608301526080810151608083015260a081015160a083015260c0810151151560c08301525050565b805182526020810151602083015260408101516040830152606081015160608301526080810151608083015260a081015160a08301525050565b60f01b6001600160f01b0319169052565b6bffffffffffffffffffffffff19606093841b811682529190921b16601482015260280190565b600082516138b6818460208701613fe9565b9190910192915050565b600084516138d2818460208901613fe9565b60f085901b6001600160f01b03191690830190815283516138fa816002840160208801613fe9565b0160020195945050505050565b60007f7061636b6574732073697a6520657863656564206c696d6974656420000000008252825161393f81601c850160208701613fe9565b91909101601c0192915050565b60007f736b697070656420696e626f756e644e6f6e63652c207061636b657420696e64825263032bc1d160e51b60208301528251613991816024850160208701613fe9565b9190910160240192915050565b60007f756e736f72746564207061636b6574732c207061636b657420696e6465783a20825282516139d6816020850160208701613fe9565b9190910160200192915050565b60006139ef828861386c565b6001600160401b0360c01b8660c01b16600283015284600a830152602a820184516020808701845b83811015613a3757815161ffff1685529382019390820190600101613a17565b50508551818701939250845b81811015613a5f57845184529382019392820192600101613a43565b50919a9950505050505050505050565b6001600160a01b0391909116815260200190565b602080825281810183905260009060408084018583028501820187855b88811015613b6557878303603f190184528135368b9003607e19018112613ac5578788fd5b8a0160808135613ad481614031565b61ffff168552818801358886015286820135613aef81614041565b6001600160401b03908116868901526060908382013536859003601e19018112613b17578b8cfd5b8401803582811115613b27578c8dfd5b803603861315613b35578c8dfd5b84848a0152613b49858a01828e8501613792565b998c019998505050948901945050506001919091019050613aa0565b509098975050505050505050565b90815260200190565b600060208252611f6c60208301846137bc565b6020808252602d908201527f53746172676174655072656372696d653a2073696d756c6174696f6e2072657360408201526c1d5b1d081b9bdd08199bdd5b99609a1b606082015260800190565b6020808252601e908201527f53746172676174655072656372696d653a20696e76616c69642073697a650000604082015260600190565b60208082526022908201527f696e76616c69642072656d6f74652061646472657373206c6f6f7075702070616040820152610e8d60f31b606082015260800190565b60208082526023908201527f53746172676174655072656372696d653a205f706f6f6c4964206e6f7420666f6040820152621d5b9960ea1b606082015260800190565b60208082526026908201527f53746172676174655072656372696d653a20636861696e2070617468206e6f7460408201526508199bdd5b9960d21b606082015260800190565b60208082526026908201527f53746172676174655072656372696d653a20706f6f6c207374617465206e6f7460408201526508199bdd5b9960d21b606082015260800190565b6101208101613d3382856137e8565b825160e083015260208301516101008301529392505050565b6101008101613d5b82856137e8565b8260e08301529392505050565b6102608101613d778286613832565b613d8460c08301856137e8565b61332b6101a0830184613832565b6101e08101613da18287613832565b613dae60c08301866137e8565b6101a08201939093526101c0015292915050565b600060208083526060830161ffff855116828501528185015160408081870152828251808552608088019150608086820289010194508584019350865b81811015613e8757888603607f190183528451805187528781015161010089890181905281519089018190526101208901918a01908b905b80821015613e6057613e4a8484516137e8565b60e0840193508b83019250600182019150613e37565b5050509085015190613e7488870183613832565b9650509386019391860191600101613dff565b509398975050505050505050565b61ffff91909116815260200190565b600061ffff841682526040602083015261332b60408301846137bc565b6001600160401b0391909116815260200190565b6000808335601e19843603018112613eeb578283fd5b8301803591506001600160401b03821115613f04578283fd5b602001915036819003821315610c5c57600080fd5b60008235607e198336030181126138b6578182fd5b6040518181016001600160401b0381118282101715613f4957fe5b604052919050565b60006001600160401b03821115613f6457fe5b5060209081020190565b60006001600160401b03821115613f8157fe5b50601f01601f191660200190565b6000613f9d612d4084613f51565b8381526020808201919084845b87811015613fd157613fbf3683358901612f59565b85529382019390820190600101613faa565b50919695505050505050565b60006106b33683612f59565b60005b83811015614004578181015183820152602001613fec565b83811115614013576000848401525b50505050565b6001600160a01b038116811461402e57600080fd5b50565b61ffff8116811461402e57600080fd5b6001600160401b038116811461402e57600080fdfe53746172676174655072656372696d653a20746f74616c50726f6d6973656442616c616e6365203e20746f74616c536f6c76656e7442616c616e63654f776e61626c653a206e6577206f776e657220697320746865207a65726f206164647265737353746172676174655072656372696d653a206c6f63616c506f6f6c43702e6c6b62203c2072656d6f7465506f6f6c43702e62616c616e63654f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572a26469706673582212200da437d2e419d234c0a825012b53200fd38613146798ffba614bd35c2b33af8264736f6c634300070600334f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101a95760003560e01c8063715018a6116100f9578063bb96836811610097578063ec67df3011610071578063ec67df301461030d578063f0099e2a1461032e578063f2fde38b14610341578063f95d1404146101f1576101a9565b8063bb968368146102ea578063c6be4b9b146102fd578063e5bc030314610305576101a9565b80639590dc9d116100d35780639590dc9d1461029c5780639eb51f5b146102bc578063a9e56f3c146102cf578063afea44ef146102d7576101a9565b8063715018a61461026c5780638971efff146102745780638da5cb5b14610287576101a9565b8063472641c11161016657806351b78b471161014057806351b78b471461024157806354fd4d50146102545780635b056da51461025c5780636eb3d2a514610264576101a9565b8063472641c1146101f15780634979e3711461020e5780634e0ab1ab14610221576101a9565b80630638fb64146101ae5780630e735a63146101cc57806317c9efb0146101d45780632913daa0146101dc57806334e30097146101f157806337de4ba1146101f9575b600080fd5b6101b6610354565b6040516101c39190613e95565b60405180910390f35b6101b6610359565b6101b661035e565b6101e4610363565b6040516101c39190613ec1565b6101b6610372565b61020c610207366004613193565b610377565b005b61020c61021c36600461315b565b610403565b61023461022f366004613535565b610487565b6040516101c39190613b73565b61020c61024f36600461315b565b6104a8565b6101b661052c565b6101b6610531565b610234610542565b61020c610548565b61020c610282366004613535565b6105f4565b61028f61065b565b6040516101c39190613a6f565b6102af6102aa366004613193565b61066a565b6040516101c39190613b7c565b6101b66102ca366004613535565b6106b9565b61028f6106f1565b61020c6102e5366004613565565b610700565b61020c6102f836600461323a565b610785565b6101b6610834565b61028f610839565b61032061031b3660046131d2565b610848565b6040516101c3929190613ea4565b61032061033c366004613193565b61099d565b61020c61034f36600461315b565b610c63565b600281565b600381565b600081565b6005546001600160401b031681565b600181565b33301461038357600080fd5b6000806103908484610d65565b91509150604051806040016040528060138152602001722f39b4b6bab630ba34b7b7103932b9bab63a2f60691b81525082826040516020016103d4939291906138c0565b60408051601f198184030181529082905262461bcd60e51b82526103fa91600401613b7c565b60405180910390fd5b61040b610e1e565b6001600160a01b031661041c61065b565b6001600160a01b031614610465576040805162461bcd60e51b815260206004820181905260248201526000805160206140f1833981519152604482015290519081900360640190fd5b600280546001600160a01b0319166001600160a01b0392909216919091179055565b6004818154811061049757600080fd5b600091825260209091200154905081565b6104b0610e1e565b6001600160a01b03166104c161065b565b6001600160a01b03161461050a576040805162461bcd60e51b815260206004820181905260248201526000805160206140f1833981519152604482015290519081900360640190fd5b600180546001600160a01b0319166001600160a01b0392909216919091179055565b600190565b600054600160a01b900461ffff1681565b60065481565b610550610e1e565b6001600160a01b031661056161065b565b6001600160a01b0316146105aa576040805162461bcd60e51b815260206004820181905260248201526000805160206140f1833981519152604482015290519081900360640190fd5b600080546040516001600160a01b03909116907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908390a3600080546001600160a01b0319169055565b6105fc610e1e565b6001600160a01b031661060d61065b565b6001600160a01b031614610656576040805162461bcd60e51b815260206004820181905260248201526000805160206140f1833981519152604482015290519081900360640190fd5b600655565b6000546001600160a01b031690565b60606000806106798585610e22565b9150915060016106876110c1565b8351848460405160200161069f9594939291906139e3565b604051602081830303815290604052925050505b92915050565b600381815481106106c957600080fd5b9060005260206000209060109182820401919006600202915054906101000a900461ffff1681565b6001546001600160a01b031681565b610708610e1e565b6001600160a01b031661071961065b565b6001600160a01b031614610762576040805162461bcd60e51b815260206004820181905260248201526000805160206140f1833981519152604482015290519081900360640190fd5b6005805467ffffffffffffffff19166001600160401b0392909216919091179055565b61078d610e1e565b6001600160a01b031661079e61065b565b6001600160a01b0316146107e7576040805162461bcd60e51b815260206004820181905260248201526000805160206140f1833981519152604482015290519081900360640190fd5b80518251146108085760405162461bcd60e51b81526004016103fa90613bdc565b815161081b906003906020850190612b68565b50805161082f906004906020840190612c11565b505050565b600481565b6002546001600160a01b031681565b6000606081836001600160401b038111801561086357600080fd5b5060405190808252806020026020018201604052801561089757816020015b60608152602001906001900390816108825790505b5090506000846001600160401b03811180156108b257600080fd5b506040519080825280602002602001820160405280156108dc578160200160208202803683370190505b50905060005b85811015610961576000808888848181106108f957fe5b905060200281019061090b9190613ed5565b81019061091891906134f2565b915091508184848151811061092957fe5b602002602001019061ffff16908161ffff16815250508085848151811061094c57fe5b602090810291909101015250506001016108e2565b5061096d8888836110d0565b909450925061ffff841615610983575050610994565b61098c82611252565b909450925050505b94509492505050565b6000606060006109ab6110c1565b90506001600160401b0381168411156109fb5760026109d2826001600160401b0316611486565b6040516020016109e29190613907565b6040516020818303038152906040529250925050610c5c565b8315610b445760008080805b87811015610b3f576000898983818110610a1d57fe5b9050602002810190610a2f9190613f19565b610a3890613fdd565b90508461ffff16816000015161ffff16141580610a59575083816020015114155b15610ada57805160208201516040830151919650945092506000610a7c82611562565b6001019050806001600160401b0316846001600160401b031614610ad4576003610aa584611486565b604051602001610ab5919061394c565b6040516020818303038152906040529850985050505050505050610c5c565b50610b36565b826001019250826001600160401b031681604001516001600160401b031614610b36576003610b0883611486565b604051602001610b18919061399e565b60405160208183030381529060405297509750505050505050610c5c565b50600101610a07565b505050505b600080306001600160a01b03166337de4ba160e01b8888604051602401610b6c929190613a83565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b0319909416939093179092529051610baa91906138a4565b600060405180830381855afa9150503d8060008114610be5576040519150601f19603f3d011682016040523d82523d6000602084013e610bea565b606091505b50915091508115610c0f578060405162461bcd60e51b81526004016103fa9190613b7c565b610c1881611782565b909550935061ffff8516610c5857600054604051610c4691600160a01b900461ffff16908690602001613ea4565b60405160208183030381529060405293505b5050505b9250929050565b610c6b610e1e565b6001600160a01b0316610c7c61065b565b6001600160a01b031614610cc5576040805162461bcd60e51b815260206004820181905260248201526000805160206140f1833981519152604482015290519081900360640190fd5b6001600160a01b038116610d0a5760405162461bcd60e51b81526004018080602001828103825260268152602001806140936026913960400191505060405180910390fd5b600080546040516001600160a01b03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b0319166001600160a01b0392909216919091179055565b60006060600080610d7461187c565b9150915060005b85811015610dd0576000878783818110610d9157fe5b9050602002810190610da39190613f19565b610dac90613fdd565b9050610db781611b6d565b15610dc757610dc7848483611ce0565b50600101610d7b565b5060408051808201825260008054600160a01b900461ffff168252602080830185905292519092610e02929101613dc2565b6040516020818303038152906040529350935050509250929050565b3390565b60608082610f03576003600481805480602002602001604051908101604052809291908181526020018280548015610ea157602002820191906000526020600020906000905b82829054906101000a900461ffff1661ffff1681526020019060020190602082600101049283019260010382029150808411610e685790505b5050505050915080805480602002602001604051908101604052809291908181526020018280548015610ef357602002820191906000526020600020905b815481526020019060010190808311610edf575b5050505050905091509150610c5c565b6000610f17610f128587613f8f565b611d67565b905061ffff8116156110b9578061ffff166001600160401b0381118015610f3d57600080fd5b50604051908082528060200260200182016040528015610f67578160200160208202803683370190505b50925060008161ffff166001600160401b0381118015610f8657600080fd5b50604051908082528060200260200182016040528015610fb0578160200160208202803683370190505b50925060005b60035461ffff82161015610c585760005b61ffff81168711156110b057600088888361ffff16818110610fe557fe5b9050602002810190610ff79190613f19565b6110059060208101906134d6565b90508061ffff1660038461ffff168154811061101d57fe5b60009182526020909120601082040154600f9091166002026101000a900461ffff1614156110a7578087858151811061105257fe5b602002602001019061ffff16908161ffff168152505060048361ffff168154811061107957fe5b906000526020600020015486858151811061109057fe5b6020908102919091010152506001909201916110b0565b50600101610fc7565b50600101610fb6565b509250929050565b6005546001600160401b031690565b60006060831561119f5760006110e68686610e22565b50905060005b815181101561119c576000805b86518110156111495783838151811061110e57fe5b602002602001015161ffff1687828151811061112657fe5b602002602001015161ffff1614156111415760019150611149565b6001016110f9565b50806111935760046040518060400160405280602081526020017f6d697373696e672072656d6f74652073696d756c6174696f6e20726573756c748152509450945050505061124a565b506001016110ec565b50505b6000805b84518110156111f057600060149054906101000a900461ffff1661ffff168582815181106111cd57fe5b602002602001015161ffff1614156111e857600191506111f0565b6001016111a3565b508061123557505060408051808201909152601f81527f6d697373696e67206c6f63616c2073696d756c6174696f6e20726573756c740060208201526004915061124a565b50506040805160208101909152600080825291505b935093915050565b6000606061125e612c4c565b600084516001600160401b038111801561127757600080fd5b506040519080825280602002602001820160405280156112b157816020015b61129e612c4c565b8152602001906001900390816112965790505b50905060005b8551811015611354578581815181106112cc57fe5b60200260200101518060200190518101906112e791906133fa565b8282815181106112f357fe5b6020026020010181905250600060149054906101000a900461ffff1661ffff1682828151811061131f57fe5b60200260200101516000015161ffff16141561134c5781818151811061134157fe5b602002602001015192505b6001016112b7565b5060005b8260200151518110156114675760008360200151828151811061137757fe5b6020026020010151905061138a81611e04565b909650945061ffff8616156113a25750505050611481565b60005b81602001515181101561145d576000826020015182815181106113c457fe5b602002602001015190508060c00151156114545760006113ed8683600001518460200151611ef2565b90506113f881611e04565b909950975061ffff8916156114135750505050505050611481565b60006114288289600001518760000151611f73565b5090506114358382612021565b909a50985061ffff8a1615611451575050505050505050611481565b50505b506001016113a5565b5050600101611358565b506000604051806020016040528060008152509350935050505b915091565b6060816114ab57506040805180820190915260018152600360fc1b602082015261155d565b8160005b81156114c357600101600a820491506114af565b6000816001600160401b03811180156114db57600080fd5b506040519080825280601f01601f191660200182016040528015611506576020820181803683370190505b50859350905060001982015b831561155757600a840660300160f81b8282806001900393508151811061153557fe5b60200101906001600160f81b031916908160001a905350600a84049350611512565b50925050505b919050565b602080820151600154604080516373c6754960e11b81529051600094859385936001600160a01b039091169263e78cea9292600480840193919291829003018186803b1580156115b157600080fd5b505afa1580156115c5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115e99190613177565b6040516020016115fa92919061387d565b60408051601f198184030181528282526001546373c6754960e11b845291519093506000926001600160a01b039092169163e78cea92916004808301926020929190829003018186803b15801561165057600080fd5b505afa158015611664573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116889190613177565b6001600160a01b03166307968db16040518163ffffffff1660e01b815260040160206040518083038186803b1580156116c057600080fd5b505afa1580156116d4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116f89190613177565b8551604051630fdc07c760e41b81529192506001600160a01b0383169163fdc07c7091611729918690600401613ea4565b60206040518083038186803b15801561174157600080fd5b505afa158015611755573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117799190613581565b95945050505050565b600060606004835110156117aa578260405162461bcd60e51b81526004016103fa9190613b7c565b6004830190506000818060200190518101906117c69190613333565b905060006117d382612094565b9050600061180b604051806040016040528060138152602001722f39b4b6bab630ba34b7b7103932b9bab63a2f60691b815250612094565b905061181782826120b9565b611835578560405162461bcd60e51b81526004016103fa9190613b7c565b600061184961184484846120fd565b612170565b90506118568160006121de565b9550611871600280835103836122409092919063ffffffff16565b945050505050915091565b6060806000600160009054906101000a90046001600160a01b03166001600160a01b031663c45a01556040518163ffffffff1660e01b815260040160206040518083038186803b1580156118cf57600080fd5b505afa1580156118e3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119079190613177565b90506000816001600160a01b031663efde4e646040518163ffffffff1660e01b815260040160206040518083038186803b15801561194457600080fd5b505afa158015611958573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061197c919061354d565b90506000816001600160401b038111801561199657600080fd5b506040519080825280602002602001820160405280156119d057816020015b6119bd612c64565b8152602001906001900390816119b55790505b5090506000826001600160401b03811180156119eb57600080fd5b50604051908082528060200260200182016040528015611a15578160200160208202803683370190505b50905060005b83811015611b62576040516341d1de9760e01b81526000906001600160a01b038716906341d1de9790611a52908590600401613b73565b60206040518083038186803b158015611a6a57600080fd5b505afa158015611a7e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611aa29190613177565b905080838381518110611ab157fe5b6001600160a01b03928316602091820292909201015260025460405163ec04205b60e01b815291169063ec04205b90611aee908490600401613a6f565b60006040518083038186803b158015611b0657600080fd5b505afa158015611b1a573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611b4291908101906133c8565b848381518110611b4e57fe5b602090810291909101015250600101611a1b565b509450925050509091565b600080600160009054906101000a90046001600160a01b03166001600160a01b031663e78cea926040518163ffffffff1660e01b815260040160206040518083038186803b158015611bbe57600080fd5b505afa158015611bd2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611bf69190613177565b835160405163471daeb560e11b81526001600160a01b039290921691638e3b5d6a91611c2491600401613e95565b60006040518083038186803b158015611c3c57600080fd5b505afa158015611c50573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611c7891908101906132f9565b9050601481511115611c9b578051611c9890829060009060131901612240565b90505b602081511115611cbd5760405162461bcd60e51b81526004016103fa90613c13565b8051908101516020840151600019600890930260020a9290920116149050919050565b606081015160208101519060ff821660011415611d0c57611d078585856000015184612357565b611d60565b60ff821660021415611d2857611d07858585600001518461250c565b60ff821660031415611d4457611d078585856000015184612611565b60ff821660041415611d6057611d6085858560000151846127cb565b5050505050565b6000805b60035461ffff82161015611dfe5760005b83518161ffff161015611df557838161ffff1681518110611d9957fe5b60200260200101516000015161ffff1660038361ffff1681548110611dba57fe5b60009182526020909120601082040154600f9091166002026101000a900461ffff161415611ded57600190920191611df5565b600101611d7c565b50600101611d6b565b50919050565b604081015160800151600090606090825b846020015151811015611e6e57600085602001518281518110611e3457fe5b60200260200101519050611e638160800151611e5d83606001518661295890919063ffffffff16565b90612958565b925050600101611e15565b50604080850151908101516020820151606083015160a090930151600093611ea59392611e9f9290918391906129b2565b906129b2565b905080821115611ed55760016040518060600160405280603c8152602001614057603c9139935093505050611481565b600060405180602001604052806000815250935093505050915091565b611efa612c64565b6000611f068585612a0f565b905060005b816020015151811015611f5357600082602001518281518110611f2a57fe5b602002602001015190508481600001511415611f4a579250611f6c915050565b50600101611f0b565b5060405162461bcd60e51b81526004016103fa90613cde565b9392505050565b611f7b612c8a565b6000805b856020015151811015612008578461ffff1686602001518281518110611fa157fe5b60200260200101516000015161ffff16148015611fd857508386602001518281518110611fca57fe5b602002602001015160200151145b156120005785602001518181518110611fed57fe5b602002602001015181925092505061124a565b600101611f7f565b5060405162461bcd60e51b81526004016103fa90613c98565b600060608260400151612050600654611e5d620f424088606001518161204357fe5b60608a0151919004612958565b101561207a5760016040518060600160405280603881526020016140b96038913991509150610c5c565b505060408051602081019091526000808252909250929050565b61209c612ccd565b506040805180820190915281518152602082810190820152919050565b8051825160009111156120ce575060006106b3565b8160200151836020015114156120e6575060016106b3565b508051602092830151929091015181902091201490565b612105612ccd565b8151835110156121165750816106b3565b602080830151908401516001911461213d5750815160208481015190840151829020919020145b80156121685782518451612150916129b2565b84528251602085015161216291612958565b60208501525b509192915050565b6060600082600001516001600160401b038111801561218e57600080fd5b506040519080825280601f01601f1916602001820160405280156121b9576020820181803683370190505b50905060006020820190506121d78185602001518660000151612a7a565b5092915050565b60006121eb826002612958565b83511015612237576040805162461bcd60e51b8152602060048201526014602482015273746f55696e7431365f6f75744f66426f756e647360601b604482015290519081900360640190fd5b50016002015190565b60608161224e81601f612958565b1015612292576040805162461bcd60e51b815260206004820152600e60248201526d736c6963655f6f766572666c6f7760901b604482015290519081900360640190fd5b61229c8383612958565b845110156122e5576040805162461bcd60e51b8152602060048201526011602482015270736c6963655f6f75744f66426f756e647360781b604482015290519081900360640190fd5b606082158015612304576040519150600082526020820160405261234e565b6040519150601f8416801560200281840101858101878315602002848b0101015b8183101561233d578051835260209283019201612325565b5050858452601f01601f1916604052505b50949350505050565b6000806000808480602001905181019061237191906136df565b50509550955050945094505060008061238b8a8a87612ad3565b925092505060008061239e848b8a611f73565b600254604051636ab202d360e01b81529294509092506001600160a01b031690636ab202d3906123d49085908a90600401613d24565b60e06040518083038186803b1580156123ec57600080fd5b505afa158015612400573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906124249190613378565b600254604080870151905163ea8683cd60e01b81529294506001600160a01b039091169163ea8683cd9161245e9186908a90600401613d68565b6101a06040518083038186803b15801561247757600080fd5b505afa9250505080156124a7575060408051601f3d908101601f191682019092526124a491810190613393565b60015b6124b0576124fe565b818d86815181106124bd57fe5b602002602001015160400181905250808d86815181106124d957fe5b60200260200101516020015184815181106124f057fe5b602002602001018190525050505b505050505050505050505050565b600080600083806020019051810190612525919061359d565b9350935093505060008061253a898986612ad3565b925092505060008061254d848a89611f73565b600254604051636ab202d360e01b81529294509092506001600160a01b031690636ab202d3906125839085908990600401613d24565b60e06040518083038186803b15801561259b57600080fd5b505afa1580156125af573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125d39190613378565b9150818a84815181106125e257fe5b60200260200101516020015182815181106125f957fe5b60200260200101819052505050505050505050505050565b60008060008060008580602001905181019061262d919061365b565b5095509550955095509550506000806126478b8b88612ad3565b925092505060008061265a848c8b611f73565b600254604051636ab202d360e01b81529294509092506001600160a01b031690636ab202d3906126909085908b90600401613d24565b60e06040518083038186803b1580156126a857600080fd5b505afa1580156126bc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126e09190613378565b600254604080870151905163072666b160e41b81529294506001600160a01b03909116916372666b109161271c9186908b908b90600401613d92565b6101a06040518083038186803b15801561273557600080fd5b505afa925050508015612765575060408051601f3d908101601f1916820190925261276291810190613393565b60015b61276e576127bc565b818e868151811061277b57fe5b602002602001015160400181905250808e868151811061279757fe5b60200260200101516020015184815181106127ae57fe5b602002602001018190525050505b50505050505050505050505050565b600080600080848060200190518101906127e591906135e3565b509450945094509450506000806127fd8a8a87612ad3565b9250925050600080612810848b8a611f73565b600254604051636ab202d360e01b81529294509092506001600160a01b031690636ab202d3906128469085908a90600401613d24565b60e06040518083038186803b15801561285e57600080fd5b505afa158015612872573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906128969190613378565b6002546040516317b597d960e01b81529193506001600160a01b0316906317b597d9906128c99085908990600401613d4c565b60e06040518083038186803b1580156128e157600080fd5b505afa925050508015612911575060408051601f3d908101601f1916820190925261290e91810190613378565b60015b61291a576124fe565b808c858151811061292757fe5b602002602001015160200151838151811061293e57fe5b602002602001018190525050505050505050505050505050565b600082820183811015611f6c576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b600082821115612a09576040805162461bcd60e51b815260206004820152601e60248201527f536166654d6174683a207375627472616374696f6e206f766572666c6f770000604482015290519081900360640190fd5b50900390565b612a17612c4c565b60005b8351811015612a61576000848281518110612a3157fe5b602002602001015190508361ffff16816000015161ffff161415612a585791506106b39050565b50600101612a1a565b5060405162461bcd60e51b81526004016103fa90613b8f565b60208110612aa95781518352612a91836020612958565b9250612a9e826020612958565b9150601f1901612a7a565b6000198115612ac0576001826020036101000a0390505b9151835183169219169190911790915250565b6000612add612c64565b6000805b8551811015612b465784868281518110612af757fe5b6020026020010151600001511415612b3e57868181518110612b1557fe5b6020026020010151868281518110612b2957fe5b60200260200101518293509350935050612b5f565b600101612ae1565b5060405162461bcd60e51b81526004016103fa90613c55565b93509350939050565b82805482825590600052602060002090600f01601090048101928215612c015791602002820160005b83821115612bd157835183826101000a81548161ffff021916908361ffff1602179055509260200192600201602081600101049283019260010302612b91565b8015612bff5782816101000a81549061ffff0219169055600201602081600101049283019260010302612bd1565b505b50612c0d929150612ce7565b5090565b828054828255906000526020600020908101928215612c01579160200282015b82811115612c01578251825591602001919060010190612c31565b60408051808201909152600081526060602082015290565b60405180606001604052806000815260200160608152602001612c85612cfc565b905290565b6040518060e00160405280600061ffff16815260200160008152602001600081526020016000815260200160008152602001600081526020016000151581525090565b604051806040016040528060008152602001600081525090565b5b80821115612c0d5760008155600101612ce8565b6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6000612d45612d4084613f6e565b613f2e565b9050828152838383011115612d5957600080fd5b611f6c836020830184613fe9565b600082601f830112612d77578081fd5b81356020612d87612d4083613f51565b8281528181019085830183850287018401881015612da3578586fd5b855b85811015612dc157813584529284019290840190600101612da5565b5090979650505050505050565b60008083601f840112612ddf578182fd5b5081356001600160401b03811115612df5578182fd5b6020830191508360208083028501011115610c5c57600080fd5b8051801515811461155d57600080fd5b600082601f830112612e2f578081fd5b8135612e3d612d4082613f6e565b818152846020838601011115612e51578283fd5b816020850160208301379081016020019190915292915050565b600082601f830112612e7b578081fd5b611f6c83835160208501612d32565b600060e08284031215612e9b578081fd5b60405160e081018181106001600160401b0382111715612eb757fe5b604052905080612ec68361313f565b81526020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a0820152612f0660c08401612e0f565b60c08201525092915050565b600060408284031215612f23578081fd5b604051604081018181106001600160401b0382111715612f3f57fe5b604052825181526020928301519281019290925250919050565b600060808284031215612f6a578081fd5b604051608081016001600160401b038282108183111715612f8757fe5b8160405282935084359150612f9b82614031565b8183526020850135602084015260408501359150612fb882614041565b8160408401526060850135915080821115612fd257600080fd5b50612fdf85828601612e1f565b6060830152505092915050565b600060c08284031215612ffd578081fd5b60405160c081018181106001600160401b038211171561301957fe5b8060405250809150825181526020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a08201525092915050565b60006101008284031215613070578081fd5b604051606081016001600160401b03828210818311171561308d57fe5b81604052829350845183526020915081850151818111156130ad57600080fd5b85019050601f810186136130c057600080fd5b80516130ce612d4082613f51565b8181528381019083850160e0808502860187018b10156130ed57600080fd5b600095505b8486101561311a576131048b83612e8a565b84526001959095019492860192908101906130f2565b5050808587015250505050506131338460408501612fec565b60408201525092915050565b805161155d81614031565b805160ff8116811461155d57600080fd5b60006020828403121561316c578081fd5b8135611f6c81614019565b600060208284031215613188578081fd5b8151611f6c81614019565b600080602083850312156131a5578081fd5b82356001600160401b038111156131ba578182fd5b6131c685828601612dce565b90969095509350505050565b600080600080604085870312156131e7578182fd5b84356001600160401b03808211156131fd578384fd5b61320988838901612dce565b90965094506020870135915080821115613221578384fd5b5061322e87828801612dce565b95989497509550505050565b6000806040838503121561324c578182fd5b82356001600160401b0380821115613262578384fd5b818501915085601f830112613275578384fd5b81356020613285612d4083613f51565b82815281810190858301838502870184018b10156132a1578889fd5b8896505b848710156132cc5780356132b881614031565b8352600196909601959183019183016132a5565b50965050860135925050808211156132e2578283fd5b506132ef85828601612d67565b9150509250929050565b60006020828403121561330a578081fd5b81516001600160401b0381111561331f578182fd5b61332b84828501612e6b565b949350505050565b600060208284031215613344578081fd5b81516001600160401b03811115613359578182fd5b8201601f81018413613369578182fd5b61332b84825160208401612d32565b600060e08284031215613389578081fd5b611f6c8383612e8a565b6000806101a083850312156133a6578182fd5b6133b08484612fec565b91506133bf8460c08501612e8a565b90509250929050565b6000602082840312156133d9578081fd5b81516001600160401b038111156133ee578182fd5b61332b8482850161305e565b6000602080838503121561340c578182fd5b82516001600160401b0380821115613422578384fd5b9084019060408287031215613435578384fd5b60405160408101818110838211171561344a57fe5b604052825161345881614031565b8152828401518281111561346a578586fd5b80840193505086601f84011261347e578485fd5b8251915061348e612d4083613f51565b82815284810190848601875b858110156134c3576134b18b8984518a010161305e565b8452928701929087019060010161349a565b5050948201949094529695505050505050565b6000602082840312156134e7578081fd5b8135611f6c81614031565b60008060408385031215613504578182fd5b823561350f81614031565b915060208301356001600160401b03811115613529578182fd5b6132ef85828601612e1f565b600060208284031215613546578081fd5b5035919050565b60006020828403121561355e578081fd5b5051919050565b600060208284031215613576578081fd5b8135611f6c81614041565b600060208284031215613592578081fd5b8151611f6c81614041565b60008060008060a085870312156135b2578182fd5b6135bb8561314a565b935060208501519250604085015191506135d88660608701612f12565b905092959194509250565b60008060008060008060e087890312156135fb578384fd5b6136048761314a565b955060208701519450604087015193506136218860608901612f12565b925060a0870151915060c08701516001600160401b03811115613642578182fd5b61364e89828a01612e6b565b9150509295509295509295565b6000806000806000806000610100888a031215613676578485fd5b61367f8861314a565b9650602088015195506040880151945061369c8960608a01612f12565b935060a0880151925060c0880151915060e08801516001600160401b038111156136c4578182fd5b6136d08a828b01612e6b565b91505092959891949750929550565b6000806000806000806000806101c0898b0312156136fb578182fd5b6137048961314a565b97506020890151965060408901519550606089015194506137288a60808b01612f12565b93506137378a60c08b01612fec565b92506101808901516001600160401b0380821115613753578384fd5b61375f8c838d01612e6b565b93506101a08b0151915080821115613775578283fd5b506137828b828c01612e6b565b9150509295985092959890939650565b60008284528282602086013780602084860101526020601f19601f85011685010190509392505050565b600081518084526137d4816020860160208601613fe9565b601f01601f19169290920160200192915050565b61ffff81511682526020810151602083015260408101516040830152606081015160608301526080810151608083015260a081015160a083015260c0810151151560c08301525050565b805182526020810151602083015260408101516040830152606081015160608301526080810151608083015260a081015160a08301525050565b60f01b6001600160f01b0319169052565b6bffffffffffffffffffffffff19606093841b811682529190921b16601482015260280190565b600082516138b6818460208701613fe9565b9190910192915050565b600084516138d2818460208901613fe9565b60f085901b6001600160f01b03191690830190815283516138fa816002840160208801613fe9565b0160020195945050505050565b60007f7061636b6574732073697a6520657863656564206c696d6974656420000000008252825161393f81601c850160208701613fe9565b91909101601c0192915050565b60007f736b697070656420696e626f756e644e6f6e63652c207061636b657420696e64825263032bc1d160e51b60208301528251613991816024850160208701613fe9565b9190910160240192915050565b60007f756e736f72746564207061636b6574732c207061636b657420696e6465783a20825282516139d6816020850160208701613fe9565b9190910160200192915050565b60006139ef828861386c565b6001600160401b0360c01b8660c01b16600283015284600a830152602a820184516020808701845b83811015613a3757815161ffff1685529382019390820190600101613a17565b50508551818701939250845b81811015613a5f57845184529382019392820192600101613a43565b50919a9950505050505050505050565b6001600160a01b0391909116815260200190565b602080825281810183905260009060408084018583028501820187855b88811015613b6557878303603f190184528135368b9003607e19018112613ac5578788fd5b8a0160808135613ad481614031565b61ffff168552818801358886015286820135613aef81614041565b6001600160401b03908116868901526060908382013536859003601e19018112613b17578b8cfd5b8401803582811115613b27578c8dfd5b803603861315613b35578c8dfd5b84848a0152613b49858a01828e8501613792565b998c019998505050948901945050506001919091019050613aa0565b509098975050505050505050565b90815260200190565b600060208252611f6c60208301846137bc565b6020808252602d908201527f53746172676174655072656372696d653a2073696d756c6174696f6e2072657360408201526c1d5b1d081b9bdd08199bdd5b99609a1b606082015260800190565b6020808252601e908201527f53746172676174655072656372696d653a20696e76616c69642073697a650000604082015260600190565b60208082526022908201527f696e76616c69642072656d6f74652061646472657373206c6f6f7075702070616040820152610e8d60f31b606082015260800190565b60208082526023908201527f53746172676174655072656372696d653a205f706f6f6c4964206e6f7420666f6040820152621d5b9960ea1b606082015260800190565b60208082526026908201527f53746172676174655072656372696d653a20636861696e2070617468206e6f7460408201526508199bdd5b9960d21b606082015260800190565b60208082526026908201527f53746172676174655072656372696d653a20706f6f6c207374617465206e6f7460408201526508199bdd5b9960d21b606082015260800190565b6101208101613d3382856137e8565b825160e083015260208301516101008301529392505050565b6101008101613d5b82856137e8565b8260e08301529392505050565b6102608101613d778286613832565b613d8460c08301856137e8565b61332b6101a0830184613832565b6101e08101613da18287613832565b613dae60c08301866137e8565b6101a08201939093526101c0015292915050565b600060208083526060830161ffff855116828501528185015160408081870152828251808552608088019150608086820289010194508584019350865b81811015613e8757888603607f190183528451805187528781015161010089890181905281519089018190526101208901918a01908b905b80821015613e6057613e4a8484516137e8565b60e0840193508b83019250600182019150613e37565b5050509085015190613e7488870183613832565b9650509386019391860191600101613dff565b509398975050505050505050565b61ffff91909116815260200190565b600061ffff841682526040602083015261332b60408301846137bc565b6001600160401b0391909116815260200190565b6000808335601e19843603018112613eeb578283fd5b8301803591506001600160401b03821115613f04578283fd5b602001915036819003821315610c5c57600080fd5b60008235607e198336030181126138b6578182fd5b6040518181016001600160401b0381118282101715613f4957fe5b604052919050565b60006001600160401b03821115613f6457fe5b5060209081020190565b60006001600160401b03821115613f8157fe5b50601f01601f191660200190565b6000613f9d612d4084613f51565b8381526020808201919084845b87811015613fd157613fbf3683358901612f59565b85529382019390820190600101613faa565b50919695505050505050565b60006106b33683612f59565b60005b83811015614004578181015183820152602001613fec565b83811115614013576000848401525b50505050565b6001600160a01b038116811461402e57600080fd5b50565b61ffff8116811461402e57600080fd5b6001600160401b038116811461402e57600080fdfe53746172676174655072656372696d653a20746f74616c50726f6d6973656442616c616e6365203e20746f74616c536f6c76656e7442616c616e63654f776e61626c653a206e6577206f776e657220697320746865207a65726f206164647265737353746172676174655072656372696d653a206c6f63616c506f6f6c43702e6c6b62203c2072656d6f7465506f6f6c43702e62616c616e63654f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572a26469706673582212200da437d2e419d234c0a825012b53200fd38613146798ffba614bd35c2b33af8264736f6c63430007060033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "_simulateAndRevert((uint16,bytes32,uint64,bytes)[])": {
        "details": "internal function, no one should call",
        "params": {
          "_packets": "packets"
        }
      },
      "getConfig((uint16,bytes32,uint64,bytes)[])": {
        "details": "get precrime config,",
        "params": {
          "_packets": "packets"
        },
        "returns": {
          "_0": "configation bytes"
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "precrime((uint16,bytes32,uint64,bytes)[],bytes[])": {
        "details": "@param _simulation all simulation results from difference chains",
        "returns": {
          "code": "    precrime result code; check out the error code defination",
          "reason": "  error reason"
        }
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "simulate((uint16,bytes32,uint64,bytes)[])": {
        "details": "simulate run cross chain packets and get a simulation result for precrime later",
        "params": {
          "_packets": "packets, the packets item should group by srcChainId, srcAddress, then sort by nonce"
        },
        "returns": {
          "code": "  simulation result code; see the error code defination",
          "data": "the result is use for precrime params"
        }
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      },
      "version()": {
        "details": "protocol version"
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 197,
        "contract": "contracts/precrime/stargate/StargatePreCrime.sol:StargatePreCrime",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 22062,
        "contract": "contracts/precrime/stargate/StargatePreCrime.sol:StargatePreCrime",
        "label": "localChainId",
        "offset": 20,
        "slot": "0",
        "type": "t_uint16"
      },
      {
        "astId": 23173,
        "contract": "contracts/precrime/stargate/StargatePreCrime.sol:StargatePreCrime",
        "label": "stargateRouter",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(Router)11590"
      },
      {
        "astId": 23175,
        "contract": "contracts/precrime/stargate/StargatePreCrime.sol:StargatePreCrime",
        "label": "poolView",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(PoolView)23131"
      },
      {
        "astId": 23178,
        "contract": "contracts/precrime/stargate/StargatePreCrime.sol:StargatePreCrime",
        "label": "remoteChainIds",
        "offset": 0,
        "slot": "3",
        "type": "t_array(t_uint16)dyn_storage"
      },
      {
        "astId": 23181,
        "contract": "contracts/precrime/stargate/StargatePreCrime.sol:StargatePreCrime",
        "label": "remotePrecrimeAddresses",
        "offset": 0,
        "slot": "4",
        "type": "t_array(t_bytes32)dyn_storage"
      },
      {
        "astId": 23183,
        "contract": "contracts/precrime/stargate/StargatePreCrime.sol:StargatePreCrime",
        "label": "maxBatchSize",
        "offset": 0,
        "slot": "5",
        "type": "t_uint64"
      },
      {
        "astId": 23185,
        "contract": "contracts/precrime/stargate/StargatePreCrime.sol:StargatePreCrime",
        "label": "inflightBuffer",
        "offset": 0,
        "slot": "6",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_bytes32)dyn_storage": {
        "base": "t_bytes32",
        "encoding": "dynamic_array",
        "label": "bytes32[]",
        "numberOfBytes": "32"
      },
      "t_array(t_uint16)dyn_storage": {
        "base": "t_uint16",
        "encoding": "dynamic_array",
        "label": "uint16[]",
        "numberOfBytes": "32"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(PoolView)23131": {
        "encoding": "inplace",
        "label": "contract PoolView",
        "numberOfBytes": "20"
      },
      "t_contract(Router)11590": {
        "encoding": "inplace",
        "label": "contract Router",
        "numberOfBytes": "20"
      },
      "t_uint16": {
        "encoding": "inplace",
        "label": "uint16",
        "numberOfBytes": "2"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      }
    }
  }
}