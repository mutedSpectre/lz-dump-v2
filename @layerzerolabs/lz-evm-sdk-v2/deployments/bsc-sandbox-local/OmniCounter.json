{
  "address": "0xef11D1c2aA48826D4c41e54ab82D1Ff5Ad8A64Ca",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_endpoint",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "EndpointOnly",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "addr",
          "type": "bytes32"
        }
      ],
      "name": "InvalidPeer",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidPeerState",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "code",
          "type": "uint16"
        },
        {
          "internalType": "bytes",
          "name": "result",
          "type": "bytes"
        }
      ],
      "name": "LzReceiveRevert",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "eid",
          "type": "uint32"
        }
      ],
      "name": "NoPeerSet",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "PreCrimeOnly",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "remoteEid",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "peer",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "active",
          "type": "bool"
        }
      ],
      "name": "SetPeer",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "precrime",
          "type": "address"
        }
      ],
      "name": "SetPrecrime",
      "type": "event"
    },
    {
      "stateMutability": "payable",
      "type": "fallback"
    },
    {
      "inputs": [],
      "name": "admin",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32[]",
          "name": "_eids",
          "type": "uint32[]"
        },
        {
          "internalType": "uint8[]",
          "name": "_types",
          "type": "uint8[]"
        },
        {
          "internalType": "bytes[]",
          "name": "_options",
          "type": "bytes[]"
        }
      ],
      "name": "batchIncrement",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_eid",
          "type": "uint32"
        },
        {
          "internalType": "uint8",
          "name": "_type",
          "type": "uint8"
        },
        {
          "internalType": "bytes",
          "name": "_options",
          "type": "bytes"
        }
      ],
      "name": "brokenIncrement",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "composedCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "count",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "eid",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "endpoint",
      "outputs": [
        {
          "internalType": "contract ILayerZeroEndpointV2",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "srcEid",
          "type": "uint32"
        }
      ],
      "name": "inboundCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "count",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_eid",
          "type": "uint32"
        },
        {
          "internalType": "uint8",
          "name": "_type",
          "type": "uint8"
        },
        {
          "internalType": "bytes",
          "name": "_options",
          "type": "bytes"
        }
      ],
      "name": "increment",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "_message",
          "type": "bytes"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "lzCompose",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "srcEid",
              "type": "uint32"
            },
            {
              "internalType": "bytes32",
              "name": "sender",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "nonce",
              "type": "uint64"
            }
          ],
          "internalType": "struct IMessageOrigin.MessageOrigin",
          "name": "_origin",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "_guid",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "_message",
          "type": "bytes"
        },
        {
          "internalType": "address",
          "name": "_executor",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "_extraData",
          "type": "bytes"
        }
      ],
      "name": "lzReceive",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint32",
                  "name": "srcEid",
                  "type": "uint32"
                },
                {
                  "internalType": "bytes32",
                  "name": "sender",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint64",
                  "name": "nonce",
                  "type": "uint64"
                }
              ],
              "internalType": "struct IMessageOrigin.MessageOrigin",
              "name": "origin",
              "type": "tuple"
            },
            {
              "internalType": "bytes32",
              "name": "guid",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "message",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "callParams",
              "type": "bytes"
            }
          ],
          "internalType": "struct IPreCrime.Packet[]",
          "name": "_packets",
          "type": "tuple[]"
        }
      ],
      "name": "lzReceiveAndRevert",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_srcEid",
          "type": "uint32"
        },
        {
          "internalType": "bytes32",
          "name": "_sender",
          "type": "bytes32"
        }
      ],
      "name": "nextNonce",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "dstEid",
          "type": "uint32"
        }
      ],
      "name": "outboundCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "count",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "name": "peers",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "precrime",
      "outputs": [
        {
          "internalType": "contract IPreCrime",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_eid",
          "type": "uint32"
        },
        {
          "internalType": "uint8",
          "name": "_type",
          "type": "uint8"
        },
        {
          "internalType": "bytes",
          "name": "_options",
          "type": "bytes"
        }
      ],
      "name": "quote",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "nativeFee",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "zroFee",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_eid",
          "type": "uint32"
        }
      ],
      "name": "safeGetPeer",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "peer",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_admin",
          "type": "address"
        }
      ],
      "name": "setAdmin",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_config",
          "type": "bytes"
        }
      ],
      "name": "setEndpointConfig",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bool",
          "name": "_orderedNonce",
          "type": "bool"
        }
      ],
      "name": "setOrderedNonce",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_eid",
          "type": "uint32"
        },
        {
          "internalType": "bytes32",
          "name": "_peer",
          "type": "bytes32"
        },
        {
          "internalType": "bool",
          "name": "_active",
          "type": "bool"
        }
      ],
      "name": "setPeer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_precrime",
          "type": "address"
        }
      ],
      "name": "setPrecrime",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_srcEid",
          "type": "uint32"
        },
        {
          "internalType": "bytes32",
          "name": "_sender",
          "type": "bytes32"
        },
        {
          "internalType": "uint64",
          "name": "_nonce",
          "type": "uint64"
        }
      ],
      "name": "skipInboundNonce",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "version",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address payable",
          "name": "_to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        }
      ],
      "name": "withdraw",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0x7c037655ed5ef637f946707e918fac6790d5e3a9cc9455cd126bd0b118913c9f",
  "receipt": {
    "to": null,
    "from": "0x14dC79964da2C08b23698B3D3cc7Ca32193d9955",
    "contractAddress": "0xef11D1c2aA48826D4c41e54ab82D1Ff5Ad8A64Ca",
    "transactionIndex": 0,
    "gasUsed": "2662160",
    "logsBloom": "0x20000000000000000002000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000400000000000000000000000000020000000000000000000800000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000080000000000000000000000000000000000000000000000000000000040000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xe987b1882f2ed5b53a4d24b6944f3044940dcfb23f38eb05b60e14f4f8de35cf",
    "transactionHash": "0x7c037655ed5ef637f946707e918fac6790d5e3a9cc9455cd126bd0b118913c9f",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 16524335,
        "transactionHash": "0x7c037655ed5ef637f946707e918fac6790d5e3a9cc9455cd126bd0b118913c9f",
        "address": "0xef11D1c2aA48826D4c41e54ab82D1Ff5Ad8A64Ca",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x00000000000000000000000014dc79964da2c08b23698b3d3cc7ca32193d9955"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0xe987b1882f2ed5b53a4d24b6944f3044940dcfb23f38eb05b60e14f4f8de35cf"
      }
    ],
    "blockNumber": 16524335,
    "cumulativeGasUsed": "2662160",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xDadd1125B8Df98A66Abd5EB302C0d9Ca5A061dC2"
  ],
  "numDeployments": 1,
  "solcInputHash": "678dd2c8bfaae833f2471ff1cdef9557",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_endpoint\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"EndpointOnly\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"addr\",\"type\":\"bytes32\"}],\"name\":\"InvalidPeer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPeerState\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"code\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"name\":\"LzReceiveRevert\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"eid\",\"type\":\"uint32\"}],\"name\":\"NoPeerSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"PreCrimeOnly\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"remoteEid\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"peer\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"SetPeer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"precrime\",\"type\":\"address\"}],\"name\":\"SetPrecrime\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"_eids\",\"type\":\"uint32[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_types\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_options\",\"type\":\"bytes[]\"}],\"name\":\"batchIncrement\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_eid\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"_options\",\"type\":\"bytes\"}],\"name\":\"brokenIncrement\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"composedCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"count\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eid\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endpoint\",\"outputs\":[{\"internalType\":\"contract ILayerZeroEndpointV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"srcEid\",\"type\":\"uint32\"}],\"name\":\"inboundCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_eid\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"_options\",\"type\":\"bytes\"}],\"name\":\"increment\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"lzCompose\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"srcEid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"internalType\":\"struct IMessageOrigin.MessageOrigin\",\"name\":\"_origin\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"_guid\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_executor\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"lzReceive\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"srcEid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"internalType\":\"struct IMessageOrigin.MessageOrigin\",\"name\":\"origin\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"guid\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callParams\",\"type\":\"bytes\"}],\"internalType\":\"struct IPreCrime.Packet[]\",\"name\":\"_packets\",\"type\":\"tuple[]\"}],\"name\":\"lzReceiveAndRevert\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_srcEid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_sender\",\"type\":\"bytes32\"}],\"name\":\"nextNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"dstEid\",\"type\":\"uint32\"}],\"name\":\"outboundCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"peers\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"precrime\",\"outputs\":[{\"internalType\":\"contract IPreCrime\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_eid\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"_options\",\"type\":\"bytes\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nativeFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"zroFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_eid\",\"type\":\"uint32\"}],\"name\":\"safeGetPeer\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"peer\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_config\",\"type\":\"bytes\"}],\"name\":\"setEndpointConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_orderedNonce\",\"type\":\"bool\"}],\"name\":\"setOrderedNonce\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_eid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_peer\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"setPeer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_precrime\",\"type\":\"address\"}],\"name\":\"setPrecrime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_srcEid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"skipInboundNonce\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"lzReceive((uint32,bytes32,uint64),bytes32,bytes,address,bytes)\":{\"details\":\"Oapp can override this interface for custom logics (e.g. more assertion)\"},\"lzReceiveAndRevert(((uint32,bytes32,uint64),bytes32,bytes,bytes)[])\":{\"details\":\"a generic interface for precrime simulationsthis function reverts at the end with the simulation resultsvalue is provided as a lump sum, does not restrict how much each packet can consume\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"safeGetPeer(uint32)\":{\"details\":\"check non-zero peer and return it\"},\"setEndpointConfig(bytes)\":{\"details\":\"a generic interface to set the endpoint configthis is a low level interface, and should be used with cautionuse our SDK to generate the properly abi.encoded config\"},\"setPeer(uint32,bytes32,bool)\":{\"details\":\"set _peer to bytes32(0) (the default value) to \\\"untrust\\\"\"},\"setPrecrime(address)\":{\"details\":\"set the precrime contract. can upgrade the precrime implementation overtime\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/examples/OmniCounter.sol\":\"OmniCounter\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":20000},\"remappings\":[]},\"sources\":{\"@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/libs/VerifierOptions.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"solidity-bytes-utils/contracts/BytesLib.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/BitMaps.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Errors.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol\\\";\\n\\nlibrary VerifierOptions {\\n    using BitMaps for BitMaps.BitMap256;\\n    using CalldataBytesLib for bytes;\\n    using BytesLib for bytes;\\n\\n    uint8 internal constant WORKER_ID = 2;\\n    uint8 internal constant OPTION_TYPE_PRECRIME = 1;\\n\\n    /// @dev group verifier options by its idx\\n    /// @param _options [verifier_id][verifier_option][verifier_id][verifier_option]...\\n    ///        verifier_option = [option_size][verifier_idx][option_type][option]\\n    ///        option_size = len(verifier_idx) + len(option_type) + len(option)\\n    ///        verifier_id: uint8, verifier_idx: uint8, option_size: uint16, option_type: uint8, option: bytes\\n    /// @return verifierOptions the grouped options, still share the same format of _options\\n    /// @return verifierIndices the verifier indices\\n    function groupVerifierOptionsByIdx(\\n        bytes memory _options\\n    ) internal pure returns (bytes[] memory verifierOptions, uint8[] memory verifierIndices) {\\n        if (_options.length == 0) return (verifierOptions, verifierIndices);\\n\\n        uint8 numVerifiers = getNumVerifiers(_options);\\n\\n        // if there is only 1 verifier, we can just return the whole options\\n        if (numVerifiers == 1) {\\n            verifierOptions = new bytes[](1);\\n            verifierOptions[0] = _options;\\n\\n            verifierIndices = new uint8[](1);\\n            verifierIndices[0] = _options.toUint8(3); // verifier idx\\n            return (verifierOptions, verifierIndices);\\n        }\\n\\n        // otherwise, we need to group the options by verifier_idx\\n        verifierIndices = new uint8[](numVerifiers);\\n        verifierOptions = new bytes[](numVerifiers);\\n        unchecked {\\n            uint cursor;\\n            uint start;\\n            uint8 lastVerifierIdx = 255; // 255 is an invalid verifier_idx\\n\\n            while (cursor < _options.length) {\\n                ++cursor; // skip worker_id\\n\\n                uint16 optionLength = _options.toUint16(cursor);\\n                cursor += 2;\\n                require(optionLength >= 2, Errors.INVALID_SIZE); // at least 1 byte for option_type and 1 byte for verifier_idx\\n\\n                uint8 verifierIdx = _options.toUint8(cursor);\\n\\n                if (lastVerifierIdx == 255) {\\n                    lastVerifierIdx = verifierIdx;\\n                }\\n\\n                // verifierIdx must equal to the lastVerifierIdx for the first option\\n                // so it is always skipped in the first option\\n                // this operation slices out options whenever the the scan finds a different lastVerifierIdx\\n                if (verifierIdx != lastVerifierIdx) {\\n                    uint size = cursor - start - 3; // 3 is for worker_id and option_length\\n                    bytes memory op = _options.slice(start, size);\\n                    _insertVerifierOptions(verifierOptions, verifierIndices, lastVerifierIdx, op);\\n\\n                    // reset the start and lastVerifierIdx\\n                    start += size;\\n                    lastVerifierIdx = verifierIdx;\\n                }\\n\\n                cursor += optionLength;\\n\\n                // if we have reached the end of the options, we need to process the last verifier\\n                if (cursor == _options.length) {\\n                    uint size = cursor - start;\\n                    bytes memory op = _options.slice(start, size);\\n                    _insertVerifierOptions(verifierOptions, verifierIndices, verifierIdx, op);\\n                }\\n            }\\n            require(cursor == _options.length, Errors.INVALID_SIZE);\\n\\n            // revert verifierIndices to start from 0\\n            for (uint8 i = 0; i < numVerifiers; ++i) {\\n                --verifierIndices[i];\\n            }\\n        }\\n    }\\n\\n    function _insertVerifierOptions(\\n        bytes[] memory _verifierOptions,\\n        uint8[] memory _verifierIndices,\\n        uint8 _verifierIdx,\\n        bytes memory _newOptions\\n    ) internal pure {\\n        // verifierIdx starts from 0 but default value of verifierIndices is 0, so we tell if the slot is empty by adding 1 to verifierIdx\\n        require(_verifierIdx < 255, Errors.INVALID_VERIFIERS);\\n        uint8 verifierIdxAdj = _verifierIdx + 1;\\n\\n        for (uint8 j = 0; j < _verifierIndices.length; ++j) {\\n            uint8 index = _verifierIndices[j];\\n            if (verifierIdxAdj == index) {\\n                _verifierOptions[j] = abi.encodePacked(_verifierOptions[j], _newOptions);\\n                break;\\n            } else if (index == 0) {\\n                // empty slot, that means it is the first time we see this verifier\\n                _verifierIndices[j] = verifierIdxAdj;\\n                _verifierOptions[j] = _newOptions;\\n                break;\\n            }\\n        }\\n    }\\n\\n    /// @dev get the number of unique verifiers\\n    /// @param _options the format is the same as groupVerifierOptionsByIdx\\n    function getNumVerifiers(bytes memory _options) internal pure returns (uint8 numVerifiers) {\\n        uint cursor;\\n        BitMaps.BitMap256 bitmap;\\n\\n        // find number of unique verifier_idx\\n        unchecked {\\n            while (cursor < _options.length) {\\n                ++cursor; // skip worker_id\\n\\n                uint16 optionLength = _options.toUint16(cursor);\\n                cursor += 2;\\n                require(optionLength >= 2, Errors.INVALID_SIZE); // at least 1 byte for verifier_idx and 1 byte for option_type\\n\\n                uint8 verifierIdx = _options.toUint8(cursor);\\n\\n                // verifierIdx starts from 0, add one for bitmap check/set\\n                require(verifierIdx < 255, Errors.INVALID_VERIFIERS);\\n                uint8 verifierIdxAdj = verifierIdx + 1;\\n\\n                // if verifierIdx is not set, increment numVerifiers\\n                if (!bitmap.get(verifierIdxAdj)) {\\n                    ++numVerifiers;\\n                    bitmap = bitmap.set(verifierIdxAdj);\\n                }\\n\\n                cursor += optionLength;\\n            }\\n        }\\n        require(cursor == _options.length, Errors.INVALID_SIZE);\\n    }\\n\\n    /// @dev decode the next verifier option from _options starting from the specified cursor\\n    /// @param _options the format is the same as groupVerifierOptionsByIdx\\n    /// @param _cursor the cursor to start decoding\\n    /// @return optionType the type of the option\\n    /// @return option the option\\n    /// @return cursor the cursor to start decoding the next option\\n    function nextVerifierOption(\\n        bytes calldata _options,\\n        uint _cursor\\n    ) internal pure returns (uint8 optionType, bytes calldata option, uint cursor) {\\n        unchecked {\\n            // skip worker id\\n            cursor = _cursor + 1;\\n\\n            // read option size\\n            uint16 size = _options.toU16(cursor);\\n            cursor += 2;\\n\\n            // read option type\\n            optionType = _options.toU8(cursor + 1); // skip verifier_idx\\n\\n            // startCursor and endCursor are used to slice the option from _options\\n            uint startCursor = cursor + 2; // skip option type and verifier_idx\\n            uint endCursor = cursor + size;\\n            option = _options[startCursor:endCursor];\\n            cursor += size;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x64ce5ceb89a26cdcddd34f2d90838cc41de88beb510c810247648de085492b31\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroComposer.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\ninterface ILayerZeroComposer {\\n    function lzCompose(\\n        address _receiver,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        address _caller,\\n        bytes calldata _extraData\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0x3e7e7e659a2e469eb7b0961d5bc36884a284e0a7b6b66230db7b72217b65f5df\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IMessageLibManager.sol\\\";\\nimport \\\"./IMessagingComposer.sol\\\";\\nimport \\\"./IMessagingChannel.sol\\\";\\nimport \\\"./IMessagingContext.sol\\\";\\nimport \\\"./IMessageOrigin.sol\\\";\\n\\ninterface ILayerZeroEndpointV2 is\\n    IMessageLibManager,\\n    IMessagingComposer,\\n    IMessagingChannel,\\n    IMessagingContext,\\n    IMessageOrigin\\n{\\n    struct MessagingParams {\\n        uint32 dstEid;\\n        bytes32 receiver;\\n        bytes message;\\n        bytes options;\\n    }\\n\\n    struct MessagingReceipt {\\n        bytes32 guid;\\n        uint64 nonce;\\n        MessagingFee fee;\\n    }\\n\\n    struct MessagingFee {\\n        uint nativeFee;\\n        uint lzTokenFee;\\n    }\\n\\n    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);\\n\\n    event PacketDelivered(MessageOrigin origin, address receiver, bytes32 payloadHash);\\n\\n    event PacketReceived(MessageOrigin origin, address receiver);\\n\\n    event LzReceiveFailed(MessageOrigin origin, address receiver, bytes reason);\\n\\n    event FeePaid(MessagingFee fee);\\n\\n    event LayerZeroTokenSet(address token);\\n\\n    function quote(\\n        address _sender,\\n        uint32 _dstEid,\\n        bytes calldata _message,\\n        bool _payInLzToken,\\n        bytes calldata _options\\n    ) external view returns (MessagingFee memory);\\n\\n    function send(\\n        MessagingParams calldata _params,\\n        uint _lzTokenFee,\\n        address payable _refundAddress\\n    ) external payable returns (MessagingReceipt memory);\\n\\n    function sendWithAlt(\\n        MessagingParams calldata _params,\\n        uint _lzTokenFee,\\n        uint _altTokenFee\\n    ) external returns (MessagingReceipt memory);\\n\\n    function deliver(MessageOrigin calldata _origin, address _receiver, bytes32 _payloadHash) external;\\n\\n    function deliverable(\\n        MessageOrigin calldata _origin,\\n        address _receiveLib,\\n        address _receiver\\n    ) external view returns (bool);\\n\\n    function lzReceive(\\n        MessageOrigin calldata _origin,\\n        address _receiver,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        bytes calldata _extraData\\n    ) external payable returns (bool, bytes memory);\\n\\n    // oapp can burn messages partially by calling this function with its own business logic if messages are delivered in order\\n    function clear(MessageOrigin calldata _origin, bytes32 _guid, bytes calldata _message) external;\\n\\n    function setLayerZeroToken(address _layerZeroToken) external;\\n\\n    function layerZeroToken() external view returns (address);\\n\\n    function altFeeToken() external view returns (address);\\n}\\n\",\"keccak256\":\"0x93a91a12df3614cabdd1964097718da66cb8487964ad7f013a6f5f2dd507f768\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IMessageOrigin.sol\\\";\\n\\ninterface ILayerZeroReceiver is IMessageOrigin {\\n    function nextNonce(uint32 _eid, bytes32 _sender) external view returns (uint64);\\n\\n    function lzReceive(\\n        MessageOrigin calldata _origin,\\n        bytes32 _guid,\\n        bytes memory _message,\\n        address _executor,\\n        bytes calldata _extraData\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0xe1e716f2016fe17aeeed4b41a37b6ce9a163e719a5c8e1c5e6be41d64fb701ee\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessageLibManager {\\n    struct SetConfigParam {\\n        uint32 configType;\\n        bytes config;\\n    }\\n\\n    struct Timeout {\\n        address lib;\\n        uint expiry;\\n    }\\n\\n    event LibraryRegistered(address newLib);\\n    event DefaultSendLibrarySet(uint32 eid, address newLib);\\n    event DefaultReceiveLibrarySet(uint32 eid, address oldLib, address newLib);\\n    event DefaultReceiveLibraryTimeoutSet(uint32 eid, address oldLib, uint expiry);\\n    event SendLibrarySet(address sender, uint32 eid, address newLib);\\n    event ReceiveLibrarySet(address receiver, uint32 eid, address oldLib, address newLib);\\n    event ReceiveLibraryTimoutSet(address receiver, uint32 eid, address oldLib, uint timeout);\\n\\n    function registerLibrary(address _lib) external;\\n\\n    function isRegisteredLibrary(address _lib) external view returns (bool);\\n\\n    function getRegisteredLibraries() external view returns (address[] memory);\\n\\n    function setDefaultSendLibrary(uint32 _eid, address _newLib) external;\\n\\n    function defaultSendLibrary(uint32 _eid) external view returns (address);\\n\\n    function setDefaultReceiveLibrary(uint32 _eid, address _newLib, uint _timeout) external;\\n\\n    function defaultReceiveLibrary(uint32 _eid) external view returns (address);\\n\\n    function setDefaultReceiveLibraryTimeout(uint32 _eid, address _lib, uint _expiry) external;\\n\\n    function defaultReceiveLibraryTimeout(uint32 _eid) external view returns (address lib, uint expiry);\\n\\n    function defaultConfig(address _lib, uint32 _eid, uint32 _configType) external view returns (bytes memory);\\n\\n    function isSupportedEid(uint32 _eid) external view returns (bool);\\n\\n    /// ------------------- OApp interfaces -------------------\\n    function setSendLibrary(uint32 _eid, address _newLib) external;\\n\\n    function getSendLibrary(address _sender, uint32 _eid) external view returns (address lib);\\n\\n    function isDefaultSendLibrary(address _sender, uint32 _eid) external view returns (bool);\\n\\n    function setReceiveLibrary(uint32 _eid, address _newLib, uint _gracePeriod) external;\\n\\n    function getReceiveLibrary(address _receiver, uint32 _eid) external view returns (address lib, bool isDefault);\\n\\n    function setReceiveLibraryTimeout(uint32 _eid, address _lib, uint _gracePeriod) external;\\n\\n    function receiveLibraryTimeout(address _receiver, uint32 _eid) external view returns (address lib, uint expiry);\\n\\n    function setConfig(address _lib, uint32 _eid, SetConfigParam[] calldata _params) external;\\n\\n    function getConfig(\\n        address _oapp,\\n        address _lib,\\n        uint32 _eid,\\n        uint32 _configType\\n    ) external view returns (bytes memory config, bool isDefault);\\n\\n    function snapshotConfig(address _lib, uint32[] calldata _eids) external;\\n\\n    function resetConfig(address _lib, uint32[] calldata _eids) external;\\n}\\n\",\"keccak256\":\"0xb013b61a9b8c4950aa5bfa966dc4876203dd8a3f55a890cd107f549edca41463\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageOrigin.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessageOrigin {\\n    struct MessageOrigin {\\n        uint32 srcEid;\\n        bytes32 sender;\\n        uint64 nonce;\\n    }\\n}\\n\",\"keccak256\":\"0x17fe98500a8ff512f22020c5a9522b676af101e6fc11a073ebf162ea02aa2f47\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessagingChannel {\\n    event InboundNonceSkipped(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce);\\n\\n    function eid() external view returns (uint32);\\n\\n    // this is an emergency function if a message can not be delivered for some reasons\\n    // required to provide _nextNonce to avoid race condition\\n    function skip(uint32 _srcEid, bytes32 _sender, uint64 _nonce) external;\\n\\n    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32);\\n\\n    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\\n\\n    function outboundNonce(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (uint64);\\n\\n    function inboundPayloadHash(\\n        address _receiver,\\n        uint32 _srcEid,\\n        bytes32 _sender,\\n        uint64 _nonce\\n    ) external view returns (bytes32);\\n\\n    function hasPayloadHash(\\n        address _receiver,\\n        uint32 _srcEid,\\n        bytes32 _sender,\\n        uint64 _nonce\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xe9c180ca201e8af11747079224729e0552addf70d65c60e7a61a4624a28d4e5c\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingComposer.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessagingComposer {\\n    event ComposedMessageDelivered(address receiver, address composer, bytes32 guid, bytes message);\\n    event ComposedMessageReceived(\\n        address receiver,\\n        address composer,\\n        bytes32 guid,\\n        bytes32 messageHash,\\n        address caller\\n    );\\n    event LzComposeFailed(\\n        address sender,\\n        address receiver,\\n        bytes32 guid,\\n        bytes32 messageHash,\\n        address caller,\\n        bytes reason\\n    );\\n\\n    function deliverComposedMessage(address _composer, bytes32 _guid, bytes calldata _message) external;\\n\\n    function lzCompose(\\n        address _receiver,\\n        address _composer,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        bytes calldata _extraData\\n    ) external payable returns (bool, bytes memory);\\n}\\n\",\"keccak256\":\"0x3993726690a51a8660c2145d3d1483e03d93de7a578afc4130467bf6804f6896\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingContext.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessagingContext {\\n    function isSendingMessage() external view returns (bool);\\n\\n    function getSendContext() external view returns (uint32, address);\\n}\\n\",\"keccak256\":\"0x6af87d5d41d060363fe554ff0ce9138f1ad8e20c1aaeec777d4132fc505e74e8\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nlibrary CalldataBytesLib {\\n    function toU8(bytes calldata _bytes, uint _start) internal pure returns (uint8) {\\n        return uint8(_bytes[_start]);\\n    }\\n\\n    function toU16(bytes calldata _bytes, uint _start) internal pure returns (uint16) {\\n        unchecked {\\n            uint end = _start + 2;\\n            return uint16(bytes2(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toU32(bytes calldata _bytes, uint _start) internal pure returns (uint32) {\\n        unchecked {\\n            uint end = _start + 4;\\n            return uint32(bytes4(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toU64(bytes calldata _bytes, uint _start) internal pure returns (uint64) {\\n        unchecked {\\n            uint end = _start + 8;\\n            return uint64(bytes8(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toU128(bytes calldata _bytes, uint _start) internal pure returns (uint128) {\\n        unchecked {\\n            uint end = _start + 16;\\n            return uint128(bytes16(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toU256(bytes calldata _bytes, uint _start) internal pure returns (uint256) {\\n        unchecked {\\n            uint end = _start + 32;\\n            return uint256(bytes32(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toAddr(bytes calldata _bytes, uint _start) internal pure returns (address) {\\n        unchecked {\\n            uint end = _start + 20;\\n            return address(bytes20(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toB32(bytes calldata _bytes, uint _start) internal pure returns (bytes32) {\\n        unchecked {\\n            uint end = _start + 32;\\n            return bytes32(_bytes[_start:end]);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6984a7e7f292ec4533ac684583e5d0505bee3bc4348776072413ceb521a6acc8\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Errors {\\n    // Invalid Argument (http: 400)\\n    string internal constant INVALID_ARGUMENT = \\\"LZ10000\\\";\\n    string internal constant ONLY_REGISTERED = \\\"LZ10001\\\";\\n    string internal constant ONLY_REGISTERED_OR_DEFAULT = \\\"LZ10002\\\";\\n    string internal constant INVALID_AMOUNT = \\\"LZ10003\\\";\\n    string internal constant INVALID_NONCE = \\\"LZ10004\\\";\\n    string internal constant SAME_VALUE = \\\"LZ10005\\\";\\n    string internal constant UNSORTED = \\\"LZ10006\\\";\\n    string internal constant INVALID_VERSION = \\\"LZ10007\\\";\\n    string internal constant INVALID_EID = \\\"LZ10008\\\";\\n    string internal constant INVALID_SIZE = \\\"LZ10009\\\";\\n    string internal constant ONLY_NON_DEFAULT = \\\"LZ10010\\\";\\n    string internal constant INVALID_VERIFIERS = \\\"LZ10011\\\";\\n    string internal constant DUPLICATED = \\\"LZ10012\\\";\\n    string internal constant INVALID_WORKER_ID = \\\"LZ10013\\\";\\n\\n    // Out of Range (http: 400)\\n    string internal constant OUT_OF_RANGE = \\\"LZ20000\\\";\\n\\n    // Invalid State (http: 400)\\n    string internal constant INVALID_STATE = \\\"LZ30000\\\";\\n    string internal constant SEND_REENTRANCY = \\\"LZ30001\\\";\\n    string internal constant RECEIVE_REENTRANCY = \\\"LZ30002\\\";\\n    string internal constant COMPOSE_REENTRANCY = \\\"LZ30003\\\";\\n\\n    // Permission Denied (http: 403)\\n    string internal constant PERMISSION_DENIED = \\\"LZ50000\\\";\\n\\n    // Not Found (http: 404)\\n    string internal constant NOT_FOUND = \\\"LZ60000\\\";\\n\\n    // Already Exists (http: 409)\\n    string internal constant ALREADY_EXISTS = \\\"LZ80000\\\";\\n\\n    // Not Implemented (http: 501)\\n    string internal constant NOT_IMPLEMENTED = \\\"LZC0000\\\";\\n    string internal constant UNSUPPORTED_INTERFACE = \\\"LZC0001\\\";\\n\\n    // Unavailable (http: 503)\\n    string internal constant UNAVAILABLE = \\\"LZD0000\\\";\\n    string internal constant NATIVE_COIN_UNAVAILABLE = \\\"LZD0001\\\";\\n    string internal constant TOKEN_UNAVAILABLE = \\\"LZD0002\\\";\\n    string internal constant DEFAULT_LIBRARY_UNAVAILABLE = \\\"LZD0003\\\";\\n    string internal constant VERIFIERS_UNAVAILABLE = \\\"LZD0004\\\";\\n}\\n\",\"keccak256\":\"0x00c68dee6968a14fa9a120a7447a3f568379c86f2a59d363e902128d4f361a6e\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/BitMaps.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\n// modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/BitMaps.sol\\npragma solidity ^0.8.19;\\n\\nlibrary BitMaps {\\n    type BitMap256 is uint;\\n\\n    /**\\n     * @dev Returns whether the bit at `index` is set.\\n     */\\n    function get(BitMap256 bitmap, uint8 index) internal pure returns (bool) {\\n        uint256 mask = 1 << (index & 0xff);\\n        return BitMap256.unwrap(bitmap) & mask != 0;\\n    }\\n\\n    /**\\n     * @dev Sets the bit at `index`.\\n     */\\n    function set(BitMap256 bitmap, uint8 index) internal pure returns (BitMap256) {\\n        uint256 mask = 1 << (index & 0xff);\\n        return BitMap256.wrap(BitMap256.unwrap(bitmap) | mask);\\n    }\\n}\\n\",\"keccak256\":\"0x29b1fb7dda9d3d6a699938da8610c0aa58d2eeb4244c6889a657eaf24117ac8e\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/ExecutorOptions.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../libs/Errors.sol\\\";\\nimport \\\"../../libs/CalldataBytesLib.sol\\\";\\n\\nlibrary ExecutorOptions {\\n    using CalldataBytesLib for bytes;\\n\\n    uint8 internal constant WORKER_ID = 1;\\n\\n    uint8 internal constant OPTION_TYPE_LZRECEIVE = 1;\\n    uint8 internal constant OPTION_TYPE_AIRDROP = 2;\\n    uint8 internal constant OPTION_TYPE_LZCOMPOSE = 3;\\n    uint8 internal constant OPTION_TYPE_ORDERED_EXECUTION = 4;\\n\\n    /// @dev decode the next executor option from the options starting from the specified cursor\\n    /// @param _options [executor_id][executor_option][executor_id][executor_option]...\\n    ///        executor_option = [option_size][option_type][option]\\n    ///        option_size = len(option_type) + len(option)\\n    ///        executor_id: uint8, option_size: uint16, option_type: uint8, option: bytes\\n    /// @param _cursor the cursor to start decoding from\\n    /// @return optionType the type of the option\\n    /// @return option the option of the executor\\n    /// @return cursor the cursor to start decoding the next executor option\\n    function nextExecutorOption(\\n        bytes calldata _options,\\n        uint _cursor\\n    ) internal pure returns (uint8 optionType, bytes calldata option, uint cursor) {\\n        unchecked {\\n            // skip worker id\\n            cursor = _cursor + 1;\\n\\n            // read option size\\n            uint16 size = _options.toU16(cursor);\\n            cursor += 2;\\n\\n            // read option type\\n            optionType = _options.toU8(cursor);\\n\\n            // startCursor and endCursor are used to slice the option from _options\\n            uint startCursor = cursor + 1; // skip option type and verifier_idx\\n            uint endCursor = cursor + size;\\n            option = _options[startCursor:endCursor];\\n            cursor += size;\\n        }\\n    }\\n\\n    function decodeLzReceiveOption(bytes calldata _option) internal pure returns (uint128 gas, uint128 value) {\\n        require(_option.length == 16 || _option.length == 32, Errors.INVALID_SIZE);\\n        gas = _option.toU128(0);\\n        value = _option.length == 32 ? _option.toU128(16) : 0;\\n    }\\n\\n    function decodeAirdropOption(bytes calldata _option) internal pure returns (uint128 amount, bytes32 receiver) {\\n        require(_option.length == 48, Errors.INVALID_SIZE);\\n        amount = _option.toU128(0);\\n        receiver = _option.toB32(16);\\n    }\\n\\n    function decodeLzComposeOption(bytes calldata _option) internal pure returns (uint128 gas, uint128 value) {\\n        require(_option.length == 16 || _option.length == 32, Errors.INVALID_SIZE);\\n        gas = _option.toU128(0);\\n        value = _option.length == 32 ? _option.toU128(16) : 0;\\n    }\\n\\n    function encodeLzReceiveOption(uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\\n        return _value == 0 ? abi.encodePacked(_gas) : abi.encodePacked(_gas, _value);\\n    }\\n\\n    function encodeAirdropOption(uint128 _amount, bytes32 _receiver) internal pure returns (bytes memory) {\\n        return abi.encodePacked(_amount, _receiver);\\n    }\\n\\n    function encodeLzComposeOption(uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\\n        return _value == 0 ? abi.encodePacked(_gas) : abi.encodePacked(_gas, _value);\\n    }\\n}\\n\",\"keccak256\":\"0x2d317c33c60f628c83625a2622a76891789b7388b06596564bd08ae6af11058a\",\"license\":\"BUSL-1.1\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xba43b97fba0d32eb4254f6a5a297b39a19a247082a02d6e69349e071e2946218\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x52a8cfb0f5239d11b457dcdd1b326992ef672714ca8da71a157255bddd13f3ad\",\"license\":\"MIT\"},\"contracts/OApp.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./interfaces/IOApp.sol\\\";\\nimport \\\"./interfaces/IPreCrime.sol\\\";\\n\\n/// @dev the template class for OApps. Refer to the OmniCounter for examples\\nabstract contract OApp is IOApp, Ownable {\\n    /// @dev we version the OApp to version the OApp Behaviours (e.g. future version might have different precrime interfaces)\\n    uint public constant override version = 1;\\n    ILayerZeroEndpointV2 public immutable endpoint;\\n    mapping(uint32 => bytes32) public peers;\\n\\n    IPreCrime public precrime;\\n\\n    constructor(address _endpoint) {\\n        endpoint = ILayerZeroEndpointV2(_endpoint);\\n    }\\n\\n    /// @dev the generic send interface to interact with the LayerZero EndpointV2.quote()\\n    function _quote(\\n        uint32 _eid,\\n        bytes memory _message,\\n        bool _useLZToken,\\n        bytes memory _options\\n    ) internal view virtual returns (uint nativeFee, uint lzTokenFee) {\\n        ILayerZeroEndpointV2.MessagingFee memory fee = endpoint.quote(\\n            address(this),\\n            _eid,\\n            _message,\\n            _useLZToken,\\n            _options\\n        );\\n        return (fee.nativeFee, fee.lzTokenFee);\\n    }\\n\\n    /// @dev the generic send interface to interact with the LayerZero EndpointV2.send()\\n    function _lzSend(\\n        ILayerZeroEndpointV2.MessagingParams memory _msgParams,\\n        ILayerZeroEndpointV2.MessagingFee memory _fee,\\n        address payable _refundAddress\\n    ) internal virtual returns (ILayerZeroEndpointV2.MessagingReceipt memory) {\\n        ILayerZeroEndpointV2.MessagingReceipt memory receipt = endpoint.send{value: _fee.nativeFee}(\\n            _msgParams,\\n            _fee.lzTokenFee,\\n            _refundAddress\\n        );\\n        return receipt;\\n    }\\n\\n    /// @dev Oapp can override this interface for custom logics (e.g. more assertion)\\n    function lzReceive(\\n        MessageOrigin calldata _origin,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        address _executor,\\n        bytes calldata _extraData\\n    ) public payable virtual {\\n        // assert the call is from the endpoint\\n        if (address(endpoint) != msg.sender) revert EndpointOnly(msg.sender);\\n        // assert that it is from a trusted peer\\n        if (safeGetPeer(_origin.srcEid) != _origin.sender) revert InvalidPeer(_origin.sender);\\n        // assert that the nonce is acceptable\\n        _acceptNonce(_origin.srcEid, _origin.sender, _origin.nonce);\\n\\n        // perform the state transition logic\\n        _lzReceive(_origin, _guid, _message, _executor, _extraData);\\n    }\\n\\n    /// @dev needs to be implemented by the OApp\\n    /// @dev basic security checks are already performed\\n    function _lzReceive(\\n        MessageOrigin calldata _origin,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        address _executor,\\n        bytes calldata _extraData\\n    ) internal virtual;\\n\\n    /// @dev a generic interface for precrime simulations\\n    /// @dev this function reverts at the end with the simulation results\\n    /// @dev value is provided as a lump sum, does not restrict how much each packet can consume\\n    function lzReceiveAndRevert(IPreCrime.Packet[] calldata _packets) external payable virtual override {\\n        if (address(precrime) != msg.sender) revert PreCrimeOnly(msg.sender);\\n\\n        for (uint i = 0; i < _packets.length; i++) {\\n            IPreCrime.Packet calldata packet = _packets[i];\\n            bytes32 peer = safeGetPeer(packet.origin.srcEid);\\n            if (peer != packet.origin.sender) {\\n                // packet from untrusted peer cannot be lzReceived, hence cannot change state\\n                continue;\\n            }\\n            // don't need to accept nonce, as by precrime protocol, all packets are sorted\\n            _lzReceive(packet.origin, packet.guid, packet.message, msg.sender, packet.callParams);\\n        }\\n        revert IPreCrime.LzReceiveRevert(1, precrime.simulationCallback());\\n    }\\n\\n    /// @dev path nonce starts from 1. if 0 it means that there is no specific nonce enforcement\\n    /// @dev only used to guide the executor actions if the app specify the msg execution to be ordered.\\n    function nextNonce(uint32 /*_srcEid*/, bytes32 /*_sender*/) public view virtual returns (uint64) {\\n        return 0;\\n    }\\n\\n    /// @dev if the app wants to enforce ordered execution, it should override this function to return the correct value\\n    /// @dev check OmniCounter for example\\n    function _acceptNonce(uint32 /*_srcEid*/, bytes32 /*_sender*/, uint64 /*_nonce*/) internal virtual {\\n        // do nth by default\\n    }\\n\\n    /// @dev receive native tokens. this might be used for the endpoint to refund\\n    receive() external payable virtual {}\\n\\n    /// ----------------------------- OAPP Config Functions -----------------------------\\n\\n    /// @dev set _peer to bytes32(0) (the default value) to \\\"untrust\\\"\\n    function setPeer(uint32 _eid, bytes32 _peer, bool _active) public virtual onlyOwner {\\n        bool currentlyActive = peers[_eid] != bytes32(0);\\n        if (currentlyActive == _active) revert InvalidPeerState();\\n\\n        peers[_eid] = _peer;\\n        emit SetPeer(_eid, _peer, _active);\\n    }\\n\\n    /// @dev check non-zero peer and return it\\n    function safeGetPeer(uint32 _eid) public view virtual returns (bytes32 peer) {\\n        peer = peers[_eid];\\n        if (peer == bytes32(0)) revert NoPeerSet(_eid);\\n    }\\n\\n    /// @dev set the precrime contract. can upgrade the precrime implementation overtime\\n    function setPrecrime(address _precrime) external onlyOwner {\\n        precrime = IPreCrime(_precrime);\\n        emit SetPrecrime(_precrime);\\n    }\\n\\n    /// @dev a generic interface to set the endpoint config\\n    /// @dev this is a low level interface, and should be used with caution\\n    /// @dev use our SDK to generate the properly abi.encoded config\\n    function setEndpointConfig(bytes calldata _config) public virtual onlyOwner {\\n        bytes4 functionSig = bytes4(_config);\\n        require(\\n            functionSig == IMessageLibManager.setConfig.selector ||\\n                functionSig == IMessageLibManager.snapshotConfig.selector ||\\n                functionSig == IMessageLibManager.resetConfig.selector ||\\n                functionSig == IMessageLibManager.setReceiveLibrary.selector ||\\n                functionSig == IMessageLibManager.setSendLibrary.selector ||\\n                functionSig == IMessageLibManager.setReceiveLibraryTimeout.selector,\\n            \\\"OApp: function not allowed\\\"\\n        );\\n\\n        (bool success, bytes memory reason) = address(endpoint).call(_config);\\n        if (!success) {\\n            assembly {\\n                revert(add(reason, 32), mload(reason))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xadc593b1f8410b831bc2c0b0b9fbbce8181fe79680c97fd9b7e792d7fc1251a1\",\"license\":\"MIT\"},\"contracts/examples/OmniCounter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../OApp.sol\\\";\\nimport \\\"../libs/OptionsBuilder.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroComposer.sol\\\";\\n\\nlibrary MsgCodec {\\n    uint8 internal constant VANILLA_TYPE = 1;\\n    uint8 internal constant COMPOSED_TYPE = 2;\\n    uint8 internal constant ABA_TYPE = 3;\\n    uint8 internal constant COMPOSED_ABA_TYPE = 4;\\n\\n    uint8 internal constant MSG_TYPE_OFFSET = 0;\\n    uint8 internal constant SRC_EID_OFFSET = 1;\\n\\n    function encode(uint8 _type, uint32 _srcEid) internal pure returns (bytes memory) {\\n        return abi.encodePacked(_type, _srcEid);\\n    }\\n\\n    function msgType(bytes calldata _message) internal pure returns (uint8) {\\n        return uint8(bytes1(_message[MSG_TYPE_OFFSET:SRC_EID_OFFSET]));\\n    }\\n\\n    function srcEid(bytes calldata _message) internal pure returns (uint32) {\\n        return uint32(bytes4(_message[SRC_EID_OFFSET:]));\\n    }\\n}\\n\\ncontract OmniCounter is ILayerZeroComposer, OApp {\\n    using MsgCodec for bytes;\\n    using OptionsBuilder for bytes;\\n\\n    uint public count;\\n    uint public composedCount;\\n\\n    address public admin;\\n    uint32 public eid;\\n\\n    mapping(uint32 srcEid => mapping(bytes32 sender => uint64 nonce)) private maxReceivedNonce;\\n    bool private orderedNonce;\\n\\n    // for global assertions\\n    mapping(uint32 srcEid => uint count) public inboundCount;\\n    mapping(uint32 dstEid => uint count) public outboundCount;\\n\\n    constructor(address _endpoint) OApp(_endpoint) {\\n        admin = msg.sender;\\n        eid = endpoint.eid();\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"only admin\\\");\\n        _;\\n    }\\n\\n    // -------------------------------\\n    // Only Admin\\n    function setAdmin(address _admin) external onlyAdmin {\\n        admin = _admin;\\n    }\\n\\n    function withdraw(address payable _to, uint _amount) external onlyAdmin {\\n        _to.transfer(_amount);\\n    }\\n\\n    // -------------------------------\\n    // Send\\n    function increment(uint32 _eid, uint8 _type, bytes calldata _options) external payable {\\n        _lzSend(\\n            ILayerZeroEndpointV2.MessagingParams(_eid, safeGetPeer(_eid), MsgCodec.encode(_type, eid), _options),\\n            ILayerZeroEndpointV2.MessagingFee(msg.value, 0),\\n            payable(msg.sender)\\n        );\\n        _incrementOutbound(_eid);\\n    }\\n\\n    // this is a broken function to skip incrementing outbound count\\n    // so that precrime will fail\\n    function brokenIncrement(uint32 _eid, uint8 _type, bytes calldata _options) external payable onlyAdmin {\\n        _lzSend(\\n            ILayerZeroEndpointV2.MessagingParams(_eid, safeGetPeer(_eid), MsgCodec.encode(_type, eid), _options),\\n            ILayerZeroEndpointV2.MessagingFee(msg.value, 0),\\n            payable(msg.sender)\\n        );\\n    }\\n\\n    function batchIncrement(\\n        uint32[] calldata _eids,\\n        uint8[] calldata _types,\\n        bytes[] calldata _options\\n    ) external payable {\\n        require(_eids.length == _options.length && _eids.length == _types.length, \\\"OmniCounter: length mismatch\\\");\\n\\n        ILayerZeroEndpointV2.MessagingReceipt memory receipt;\\n        uint providedFee = msg.value;\\n        for (uint i = 0; i < _eids.length; i++) {\\n            address refundAddress = i == _eids.length - 1 ? msg.sender : address(this);\\n            receipt = _lzSend(\\n                ILayerZeroEndpointV2.MessagingParams(\\n                    _eids[i],\\n                    safeGetPeer(_eids[i]),\\n                    MsgCodec.encode(_types[i], eid),\\n                    _options[i]\\n                ),\\n                ILayerZeroEndpointV2.MessagingFee(providedFee, 0),\\n                payable(refundAddress)\\n            );\\n            _incrementOutbound(_eids[i]);\\n            providedFee -= receipt.fee.nativeFee;\\n        }\\n    }\\n\\n    // -------------------------------\\n    // View\\n    function quote(\\n        uint32 _eid,\\n        uint8 _type,\\n        bytes calldata _options\\n    ) public view returns (uint nativeFee, uint zroFee) {\\n        return _quote(_eid, MsgCodec.encode(_type, eid), false, _options);\\n    }\\n\\n    // -------------------------------\\n    // Receive\\n    function _lzReceive(\\n        MessageOrigin calldata _origin,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        address /*_executor*/,\\n        bytes calldata /*_extraData*/\\n    ) internal override {\\n        uint8 messageType = _message.msgType();\\n\\n        if (messageType == MsgCodec.VANILLA_TYPE) {\\n            count++;\\n            _incrementInbound(_origin.srcEid);\\n        } else if (messageType == MsgCodec.COMPOSED_TYPE || messageType == MsgCodec.COMPOSED_ABA_TYPE) {\\n            count++;\\n            _incrementInbound(_origin.srcEid);\\n            endpoint.deliverComposedMessage(address(this), _guid, _message);\\n        } else if (messageType == MsgCodec.ABA_TYPE) {\\n            count++;\\n            _incrementInbound(_origin.srcEid);\\n\\n            // send back to the sender\\n            _incrementOutbound(_origin.srcEid);\\n            bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200000, 0);\\n            _lzSend(\\n                ILayerZeroEndpointV2.MessagingParams(\\n                    _origin.srcEid,\\n                    safeGetPeer(_origin.srcEid),\\n                    MsgCodec.encode(MsgCodec.VANILLA_TYPE, eid),\\n                    options\\n                ),\\n                ILayerZeroEndpointV2.MessagingFee(msg.value, 0),\\n                payable(address(this))\\n            );\\n        } else {\\n            revert(\\\"invalid message type\\\");\\n        }\\n    }\\n\\n    function _incrementInbound(uint32 _srcEid) internal {\\n        inboundCount[_srcEid]++;\\n    }\\n\\n    function _incrementOutbound(uint32 _dstEid) internal {\\n        outboundCount[_dstEid]++;\\n    }\\n\\n    function lzCompose(\\n        address /*_oapp*/,\\n        bytes32 /*_guid*/,\\n        bytes calldata _message,\\n        address,\\n        bytes calldata\\n    ) external payable override {\\n        require(msg.sender == address(endpoint), \\\"!endpoint\\\");\\n\\n        uint8 msgType = _message.msgType();\\n        if (msgType == MsgCodec.COMPOSED_TYPE) {\\n            composedCount += 1;\\n        } else if (msgType == MsgCodec.COMPOSED_ABA_TYPE) {\\n            composedCount += 1;\\n\\n            uint32 srcEid = _message.srcEid();\\n            _incrementOutbound(srcEid);\\n            bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200000, 0);\\n            _lzSend(\\n                ILayerZeroEndpointV2.MessagingParams(\\n                    srcEid,\\n                    safeGetPeer(srcEid),\\n                    MsgCodec.encode(MsgCodec.VANILLA_TYPE, eid),\\n                    options\\n                ),\\n                ILayerZeroEndpointV2.MessagingFee(msg.value, 0),\\n                payable(address(this))\\n            );\\n        } else {\\n            revert(\\\"invalid message type\\\");\\n        }\\n    }\\n\\n    // -------------------------------\\n    // Ordered OApp\\n    // this demonstrates how to build an app that requires execution nonce ordering\\n    // normally an app should decide ordered or not on contract construction\\n    // this is just a demo\\n    function setOrderedNonce(bool _orderedNonce) external onlyOwner {\\n        orderedNonce = _orderedNonce;\\n    }\\n\\n    function _acceptNonce(uint32 _srcEid, bytes32 _sender, uint64 _nonce) internal virtual override {\\n        uint64 currentNonce = maxReceivedNonce[_srcEid][_sender];\\n        if (orderedNonce) {\\n            require(_nonce == currentNonce + 1, \\\"OApp: invalid nonce\\\");\\n        }\\n        // update the max nonce anyway. once the ordered mode is turned on, missing early nonces will be rejected\\n        if (_nonce > currentNonce) {\\n            maxReceivedNonce[_srcEid][_sender] = _nonce;\\n        }\\n    }\\n\\n    function nextNonce(uint32 _srcEid, bytes32 _sender) public view virtual override returns (uint64) {\\n        if (orderedNonce) {\\n            return maxReceivedNonce[_srcEid][_sender] + 1;\\n        } else {\\n            return 0; // path nonce starts from 1. if 0 it means that there is no specific nonce enforcement\\n        }\\n    }\\n\\n    // a governance function to skip nonce\\n    function skipInboundNonce(uint32 _srcEid, bytes32 _sender, uint64 _nonce) public virtual onlyOwner {\\n        endpoint.skip(_srcEid, _sender, _nonce);\\n        if (orderedNonce) {\\n            maxReceivedNonce[_srcEid][_sender]++;\\n        }\\n    }\\n\\n    // be able to receive ether\\n    fallback() external payable {}\\n}\\n\",\"keccak256\":\"0x6b9352a710334c0afc99f23f1ad8df8b4e71eaa78ebf643dbfab812c7f09ce8b\",\"license\":\"MIT\"},\"contracts/interfaces/IOApp.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol\\\";\\nimport \\\"./IPreCrime.sol\\\";\\n\\ninterface IOApp is ILayerZeroReceiver {\\n    function setEndpointConfig(bytes calldata _config) external;\\n\\n    function nextNonce(uint32 _srcEid, bytes32 _sender) external view returns (uint64);\\n\\n    function version() external view returns (uint);\\n\\n    function lzReceiveAndRevert(IPreCrime.Packet[] calldata _packets) external payable;\\n\\n    error EndpointOnly(address addr);\\n    error PreCrimeOnly(address addr);\\n    error InvalidPeer(bytes32 addr);\\n    error InvalidPeerState();\\n    error NoPeerSet(uint32 eid);\\n\\n    event SetPeer(uint32 remoteEid, bytes32 peer, bool active);\\n    event SetPrecrime(address precrime);\\n}\\n\",\"keccak256\":\"0xdc1b904112f784f4c55bfb3465bed56d4831cae9a7ee09ce4433b73fd2ef4177\",\"license\":\"MIT\"},\"contracts/interfaces/IPreCrime.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageOrigin.sol\\\";\\n\\ninterface IPreCrime is IMessageOrigin {\\n    error LzReceiveRevert(uint16 code, bytes result);\\n\\n    struct Packet {\\n        MessageOrigin origin;\\n        bytes32 guid;\\n        bytes message;\\n        bytes callParams;\\n    }\\n\\n    function getPrecrimeConfig(Packet[] calldata _packets) external view returns (bytes memory);\\n\\n    function precrime(\\n        Packet[] calldata _packets,\\n        bytes[] calldata _simulation\\n    ) external view returns (uint16 code, bytes memory reason);\\n\\n    function precrimeVersion() external view returns (uint16);\\n\\n    function simulate(Packet[] calldata _packets) external payable returns (uint16 code, bytes memory result);\\n\\n    function simulateView(Packet[] calldata _packets) external view returns (uint16 code, bytes memory result);\\n\\n    function simulationCallback() external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0xfc56771ce13a2eeb40097ea2c05a64caa55d1125a7dd2b2e03633604d7bdc8d7\",\"license\":\"MIT\"},\"contracts/libs/OptionsBuilder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/ExecutorOptions.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/libs/VerifierOptions.sol\\\";\\n\\nlibrary OptionsBuilder {\\n    using SafeCast for uint;\\n    using BytesLib for bytes;\\n\\n    uint16 internal constant TYPE_1 = 1; // legacy options type 1\\n    uint16 internal constant TYPE_2 = 2; // legacy options type 2\\n    uint16 internal constant TYPE_3 = 3;\\n\\n    modifier onlyType3(bytes memory _options) {\\n        require(_options.toUint16(0) == TYPE_3, \\\"OptionsBuilder: invalid options type\\\");\\n        _;\\n    }\\n\\n    function newOptions() internal pure returns (bytes memory) {\\n        return abi.encodePacked(TYPE_3);\\n    }\\n\\n    function addExecutorLzReceiveOption(\\n        bytes memory _options,\\n        uint128 _gas,\\n        uint128 _value\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        bytes memory option = ExecutorOptions.encodeLzReceiveOption(_gas, _value);\\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZRECEIVE, option);\\n    }\\n\\n    function addExecutorAirdropOption(\\n        bytes memory _options,\\n        uint128 _amount,\\n        bytes32 _receiver\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        bytes memory option = ExecutorOptions.encodeAirdropOption(_amount, _receiver);\\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_AIRDROP, option);\\n    }\\n\\n    function addExecutorLzComposeOption(\\n        bytes memory _options,\\n        uint128 _gas,\\n        uint128 _value\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        bytes memory option = ExecutorOptions.encodeLzComposeOption(_gas, _value);\\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZCOMPOSE, option);\\n    }\\n\\n    function addExecutorOrderedExecutionOption(\\n        bytes memory _options\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_ORDERED_EXECUTION, bytes(\\\"\\\"));\\n    }\\n\\n    function addVerifierPrecrimeOption(\\n        bytes memory _options,\\n        uint8 _verifierIdx\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        return addVerifierOption(_options, _verifierIdx, VerifierOptions.OPTION_TYPE_PRECRIME, bytes(\\\"\\\"));\\n    }\\n\\n    function addExecutorOption(\\n        bytes memory _options,\\n        uint8 _optionType,\\n        bytes memory _option\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                _options,\\n                ExecutorOptions.WORKER_ID,\\n                _option.length.toUint16() + 1, // +1 for optionType\\n                _optionType,\\n                _option\\n            );\\n    }\\n\\n    function addVerifierOption(\\n        bytes memory _options,\\n        uint8 _verifierIdx,\\n        uint8 _optionType,\\n        bytes memory _option\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                _options,\\n                VerifierOptions.WORKER_ID,\\n                _option.length.toUint16() + 2, // +2 for optionType and verifierIdx\\n                _verifierIdx,\\n                _optionType,\\n                _option\\n            );\\n    }\\n\\n    function encodeLegacyOptionsType1(uint _executionGas) internal pure returns (bytes memory) {\\n        require(_executionGas <= type(uint128).max, Errors.INVALID_SIZE);\\n        return abi.encodePacked(TYPE_1, _executionGas);\\n    }\\n\\n    function encodeLegacyOptionsType2(\\n        uint _executionGas,\\n        uint _amount,\\n        bytes memory _receiver // use bytes instead of bytes32 in legacy type 2\\n    ) internal pure returns (bytes memory) {\\n        require(\\n            _executionGas <= type(uint128).max && _amount <= type(uint128).max && _receiver.length <= 32,\\n            Errors.INVALID_SIZE\\n        );\\n        return abi.encodePacked(TYPE_2, _executionGas, _amount, _receiver);\\n    }\\n}\\n\",\"keccak256\":\"0xb0b9666bd73151ace3988bf55c2c20317e7b8eca7182b174e0c7a7e48005174a\",\"license\":\"MIT\"},\"solidity-bytes-utils/contracts/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\\u00e7alo S\\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity >=0.8.0 <0.9.0;\\n\\n\\nlibrary BytesLib {\\n    function concat(\\n        bytes memory _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(0x40, and(\\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n              not(31) // Round down to the nearest 32 bytes.\\n            ))\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes.slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes.slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                                ),\\n                                // and now shift left the number of bytes to\\n                                // leave space for the length in the slot\\n                                exp(0x100, sub(32, newlength))\\n                            ),\\n                            // increase length by the double of the memory\\n                            // bytes length\\n                            mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(\\n                    sc,\\n                    add(\\n                        and(\\n                            fslot,\\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\\n                        ),\\n                        and(mload(mc), mask)\\n                    )\\n                )\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let mlengthmod := mod(mlength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n                for {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_bytes.length >= _start + 1 , \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\n        require(_bytes.length >= _start + 2, \\\"toUint16_outOfBounds\\\");\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\\n        require(_bytes.length >= _start + 4, \\\"toUint32_outOfBounds\\\");\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\\n        require(_bytes.length >= _start + 8, \\\"toUint64_outOfBounds\\\");\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\\n        require(_bytes.length >= _start + 12, \\\"toUint96_outOfBounds\\\");\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\\n        require(_bytes.length >= _start + 16, \\\"toUint128_outOfBounds\\\");\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n        require(_bytes.length >= _start + 32, \\\"toUint256_outOfBounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n        require(_bytes.length >= _start + 32, \\\"toBytes32_outOfBounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                // the next line is the loop condition:\\n                // while(uint256(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(\\n        bytes storage _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes.slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes.slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint256(mc < end) + cb == 2)\\n                        for {} eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n}\\n\",\"keccak256\":\"0xf75784dfc94ea43668eb195d5690a1dde1b6eda62017e73a3899721583821d29\",\"license\":\"Unlicense\"}},\"version\":1}",
  "bytecode": "0x60a06040523480156200001157600080fd5b506040516200307138038062003071833981016040819052620000349162000139565b806200004033620000e9565b6001600160a01b03166080819052600580546001600160a01b031916331790556040805163416ecebf60e01b8152905163416ecebf916004808201926020929091908290030181865afa1580156200009c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620000c291906200016b565b600560146101000a81548163ffffffff021916908363ffffffff1602179055505062000193565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6000602082840312156200014c57600080fd5b81516001600160a01b03811681146200016457600080fd5b9392505050565b6000602082840312156200017e57600080fd5b815163ffffffff811681146200016457600080fd5b608051612e91620001e0600039600081816102fa015281816105d101528181610bf001528181610dab01528181611199015281816119db01528181611c060152611eb70152612e916000f3fe6080604052600436106101ae5760003560e01c8063715018a6116100eb578063bb0b6a531161008f578063f2fde38b11610061578063f2fde38b1461054f578063f3fef3a31461056f578063f5c6ba5a1461058f578063f851a440146105a257005b8063bb0b6a53146104c7578063c95c55be146104f4578063d0a1026014610507578063d22446ce1461051a57005b80638da5cb5b116100c85780638da5cb5b1461043c578063950c8a7414610467578063b7abbb5d14610494578063baf3292d146104a757005b8063715018a6146103ce5780637624f505146103e35780637d25a05e1461040357005b806356a4728911610152578063622f17f61161012f578063622f17f614610341578063655f06381461036e578063704b6c021461038e5780637112f86f146103ae57005b806356a472891461029b5780635b849af6146102c85780635e280f11146102e857005b806326b27f841161018b57806326b27f8414610209578063416ecebf14610229578063542e7b561461027357806354fd4d501461028657005b806306661abd146101b757806313137d65146101e0578063257f4e05146101f357005b366101b557005b005b3480156101c357600080fd5b506101cd60035481565b6040519081526020015b60405180910390f35b6101b56101ee3660046122e6565b6105cf565b3480156101ff57600080fd5b506101cd60045481565b34801561021557600080fd5b506101cd6102243660046123a1565b6106d9565b34801561023557600080fd5b5060055461025e9074010000000000000000000000000000000000000000900463ffffffff1681565b60405163ffffffff90911681526020016101d7565b6101b5610281366004612401565b610733565b34801561029257600080fd5b506101cd600181565b3480156102a757600080fd5b506101cd6102b63660046123a1565b60086020526000908152604090205481565b3480156102d457600080fd5b506101b56102e33660046124ab565b610975565b3480156102f457600080fd5b5061031c7f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016101d7565b34801561034d57600080fd5b506101cd61035c3660046123a1565b60096020526000908152604090205481565b34801561037a57600080fd5b506101b56103893660046124c6565b6109ae565b34801561039a57600080fd5b506101b56103a9366004612508565b610c90565b3480156103ba57600080fd5b506101b56103c936600461253b565b610d58565b3480156103da57600080fd5b506101b5610e8c565b3480156103ef57600080fd5b506101b56103fe36600461257b565b610ea0565b34801561040f57600080fd5b5061042361041e3660046125b7565b610f59565b60405167ffffffffffffffff90911681526020016101d7565b34801561044857600080fd5b5060005473ffffffffffffffffffffffffffffffffffffffff1661031c565b34801561047357600080fd5b5060025461031c9073ffffffffffffffffffffffffffffffffffffffff1681565b6101b56104a23660046125f2565b610fae565b3480156104b357600080fd5b506101b56104c2366004612508565b61105c565b3480156104d357600080fd5b506101cd6104e23660046123a1565b60016020526000908152604090205481565b6101b56105023660046125f2565b6110dd565b6101b5610515366004612653565b611181565b34801561052657600080fd5b5061053a6105353660046125f2565b611403565b604080519283526020830191909152016101d7565b34801561055b57600080fd5b506101b561056a366004612508565b611471565b34801561057b57600080fd5b506101b561058a3660046126d4565b611528565b6101b561059d3660046126f2565b6115ec565b3480156105ae57600080fd5b5060055461031c9073ffffffffffffffffffffffffffffffffffffffff1681565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163314610645576040517fab08c09e0000000000000000000000000000000000000000000000000000000081523360048201526024015b60405180910390fd5b6020870180359061065a90610224908a6123a1565b14610697576040517fc59a4f640000000000000000000000000000000000000000000000000000000081526020880135600482015260240161063c565b6106c16106a760208901896123a1565b60208901356106bc60608b0160408c01612728565b6117c0565b6106d0878787878787876118f6565b50505050505050565b63ffffffff81166000908152600160205260409020548061072e576040517f196fb6c000000000000000000000000000000000000000000000000000000000815263ffffffff8316600482015260240161063c565b919050565b848114801561074157508483145b6107a7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f4f6d6e69436f756e7465723a206c656e677468206d69736d6174636800000000604482015260640161063c565b6107af612233565b3460005b8781101561096a5760006107c860018a612774565b82146107d457306107d6565b335b905061091360405180608001604052808c8c868181106107f8576107f8612787565b905060200201602081019061080d91906123a1565b63ffffffff1681526020016108428d8d8781811061082d5761082d612787565b905060200201602081019061022491906123a1565b81526020016108978b8b8781811061085c5761085c612787565b905060200201602081019061087191906127b6565b60055474010000000000000000000000000000000000000000900463ffffffff16611b3e565b81526020018888868181106108ae576108ae612787565b90506020028101906108c091906127d1565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920182905250939094525050604080518082019091528781526020810191909152905083611bb7565b93506109448a8a8481811061092a5761092a612787565b905060200201602081019061093f91906123a1565b611c89565b6040840151516109549084612774565b925050808061096290612836565b9150506107b3565b505050505050505050565b61097d611cb2565b600780547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016911515919091179055565b6109b6611cb2565b60006109c2828461286e565b90507fffffffff0000000000000000000000000000000000000000000000000000000081167fb8007ff6000000000000000000000000000000000000000000000000000000001480610a5557507fffffffff0000000000000000000000000000000000000000000000000000000081167f9e7fffcc00000000000000000000000000000000000000000000000000000000145b80610aa157507fffffffff0000000000000000000000000000000000000000000000000000000081167f0678327f00000000000000000000000000000000000000000000000000000000145b80610aed57507fffffffff0000000000000000000000000000000000000000000000000000000081167fb8849ac900000000000000000000000000000000000000000000000000000000145b80610b3957507fffffffff0000000000000000000000000000000000000000000000000000000081167fe16f964d00000000000000000000000000000000000000000000000000000000145b80610b8557507fffffffff0000000000000000000000000000000000000000000000000000000081167f66bf43d600000000000000000000000000000000000000000000000000000000145b610beb576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f4f4170703a2066756e6374696f6e206e6f7420616c6c6f776564000000000000604482015260640161063c565b6000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff168585604051610c359291906128b6565b6000604051808303816000865af19150503d8060008114610c72576040519150601f19603f3d011682016040523d82523d6000602084013e610c77565b606091505b509150915081610c8957805160208201fd5b5050505050565b60055473ffffffffffffffffffffffffffffffffffffffff163314610d11576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f6f6e6c792061646d696e00000000000000000000000000000000000000000000604482015260640161063c565b600580547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b610d60611cb2565b6040517feaeacd6300000000000000000000000000000000000000000000000000000000815263ffffffff841660048201526024810183905267ffffffffffffffff821660448201527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169063eaeacd6390606401600060405180830381600087803b158015610e0457600080fd5b505af1158015610e18573d6000803e3d6000fd5b505060075460ff16159150610e8790505763ffffffff831660009081526006602090815260408083208584529091528120805467ffffffffffffffff1691610e5f836128c6565b91906101000a81548167ffffffffffffffff021916908367ffffffffffffffff160217905550505b505050565b610e94611cb2565b610e9e6000611d33565b565b610ea8611cb2565b63ffffffff831660009081526001602052604090205415158115158103610efb576040517f9556766100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b63ffffffff84166000818152600160209081526040918290208690558151928352820185905283151582820152517fc55181d68816686be8ec55890d24aefed84c9a6a875145822aad2b2c950f027f9181900360600190a150505050565b60075460009060ff1615610fa45763ffffffff83166000908152600660209081526040808320858452909152902054610f9d9067ffffffffffffffff1660016128ed565b9050610fa8565b5060005b92915050565b61104c60405180608001604052808663ffffffff168152602001610fd1876106d9565b8152602001610ff286600560149054906101000a900463ffffffff16611b3e565b815260200184848080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920182905250939094525050604080518082019091523481526020810191909152905033611bb7565b5061105684611c89565b50505050565b611064611cb2565b600280547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040519081527f5db758e995a17ec1ad84bdef7e8c3293a0bd6179bcce400dff5d4c3d87db726b9060200160405180910390a150565b60055473ffffffffffffffffffffffffffffffffffffffff16331461115e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f6f6e6c792061646d696e00000000000000000000000000000000000000000000604482015260640161063c565b610c8960405180608001604052808663ffffffff168152602001610fd1876106d9565b3373ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001614611220576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f21656e64706f696e740000000000000000000000000000000000000000000000604482015260640161063c565b600061122c8686611da8565b90507ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe60ff8216016112765760016004600082825461126b9190612915565b909155506113f99050565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc60ff821601611397576001600460008282546112b39190612915565b90915550600090506112c58787611dca565b90506112d081611c89565b600061132362030d40600061131c604080517e03000000000000000000000000000000000000000000000000000000000000602082015281516002818303018152602290910190915290565b9190611dec565b905061138f60405180608001604052808463ffffffff168152602001611348856106d9565b815260200161136a6001600560149054906101000a900463ffffffff16611b3e565b8152602001838152506040518060400160405280348152602001600081525030611bb7565b5050506113f9565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f696e76616c6964206d6573736167652074797065000000000000000000000000604482015260640161063c565b5050505050505050565b6000806114648661142687600560149054906101000a900463ffffffff16611b3e565b600087878080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250611eb092505050565b9150915094509492505050565b611479611cb2565b73ffffffffffffffffffffffffffffffffffffffff811661151c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f6464726573730000000000000000000000000000000000000000000000000000606482015260840161063c565b61152581611d33565b50565b60055473ffffffffffffffffffffffffffffffffffffffff1633146115a9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f6f6e6c792061646d696e00000000000000000000000000000000000000000000604482015260640161063c565b60405173ffffffffffffffffffffffffffffffffffffffff83169082156108fc029083906000818181858888f19350505050158015610e87573d6000803e3d6000fd5b60025473ffffffffffffffffffffffffffffffffffffffff16331461163f576040517fc023811c00000000000000000000000000000000000000000000000000000000815233600482015260240161063c565b60005b818110156116d5573683838381811061165d5761165d612787565b905060200281019061166f9190612928565b9050600061168361022460208401846123a1565b9050602082013581146116975750506116c3565b6116c08260608101356116ad60808301836127d1565b336116bb60a08901896127d1565b6118f6565b50505b806116cd81612836565b915050611642565b50600254604080517fd2968d57000000000000000000000000000000000000000000000000000000008152905160019273ffffffffffffffffffffffffffffffffffffffff169163d2968d579160048083019260009291908290030181865afa158015611746573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820160405261178c91908101906129b9565b6040517f0a78da8f00000000000000000000000000000000000000000000000000000000815260040161063c929190612ace565b63ffffffff8316600090815260066020908152604080832085845290915290205460075467ffffffffffffffff9091169060ff1615611880576118048160016128ed565b67ffffffffffffffff168267ffffffffffffffff1614611880576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f4f4170703a20696e76616c6964206e6f6e636500000000000000000000000000604482015260640161063c565b8067ffffffffffffffff168267ffffffffffffffff1611156110565763ffffffff841660009081526006602090815260408083208684529091529020805467ffffffffffffffff84167fffffffffffffffffffffffffffffffffffffffffffffffff000000000000000090911617905550505050565b60006119028686611da8565b90507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60ff82160161195e576003805490600061193e83612836565b90915550611959905061195460208a018a6123a1565b611f6c565b6113f9565b60ff811660021480611973575060ff81166004145b15611a4d576003805490600061198883612836565b9091555061199e905061195460208a018a6123a1565b6040517f754d3b9c00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063754d3b9c90611a169030908b908b908b90600401612af3565b600060405180830381600087803b158015611a3057600080fd5b505af1158015611a44573d6000803e3d6000fd5b505050506113f9565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd60ff8216016113975760038054906000611a8783612836565b90915550611a9d905061195460208a018a6123a1565b611aad61093f60208a018a6123a1565b6000611af962030d40600061131c604080517e03000000000000000000000000000000000000000000000000000000000000602082015281516002818303018152602290910190915290565b6040805160808101909152909150611b379080611b1960208d018d6123a1565b63ffffffff16815260209081019061134890610224908e018e6123a1565b50506113f9565b6040517fff0000000000000000000000000000000000000000000000000000000000000060f884901b1660208201527fffffffff0000000000000000000000000000000000000000000000000000000060e083901b1660218201526060906025015b604051602081830303815290604052905092915050565b611bbf612233565b825160208401516040517faca1b45a00000000000000000000000000000000000000000000000000000000815260009273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169263aca1b45a92611c3d918a918990600401612b64565b60806040518083038185885af1158015611c5b573d6000803e3d6000fd5b50505050506040513d601f19601f82011682018060405250810190611c809190612c52565b95945050505050565b63ffffffff81166000908152600960205260408120805491611caa83612836565b919050555050565b60005473ffffffffffffffffffffffffffffffffffffffff163314610e9e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161063c565b6000805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6000611db76001828486612cba565b611dc091612ce4565b60f81c9392505050565b6000611dd98260018186612cba565b611de29161286e565b60e01c9392505050565b6060836003611dfc826000611f8d565b61ffff1614611e8c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526024808201527f4f7074696f6e734275696c6465723a20696e76616c6964206f7074696f6e732060448201527f7479706500000000000000000000000000000000000000000000000000000000606482015260840161063c565b6000611e98858561200d565b9050611ea6866001836120b4565b9695505050505050565b60008060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166383c4755930898989896040518663ffffffff1660e01b8152600401611f16959493929190612d2a565b6040805180830381865afa158015611f32573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f569190612d8b565b8051602090910151909890975095505050505050565b63ffffffff81166000908152600860205260408120805491611caa83612836565b6000611f9a826002612915565b83511015612004576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f746f55696e7431365f6f75744f66426f756e6473000000000000000000000000604482015260640161063c565b50016002015190565b60606fffffffffffffffffffffffffffffffff82161561207657604080517fffffffffffffffffffffffffffffffff00000000000000000000000000000000608086811b8216602084015285901b166030820152016040516020818303038152906040526120ad565b6040517fffffffffffffffffffffffffffffffff00000000000000000000000000000000608085901b166020820152603001611ba0565b9392505050565b60608360036120c4826000611f8d565b61ffff1614612154576040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526024808201527f4f7074696f6e734275696c6465723a20696e76616c6964206f7074696f6e732060448201527f7479706500000000000000000000000000000000000000000000000000000000606482015260840161063c565b846001612161855161219b565b61216c906001612da7565b8686604051602001612182959493929190612dc2565b6040516020818303038152906040529150509392505050565b600061ffff82111561222f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f53616665436173743a2076616c756520646f65736e27742066697420696e203160448201527f3620626974730000000000000000000000000000000000000000000000000000606482015260840161063c565b5090565b604051806060016040528060008019168152602001600067ffffffffffffffff168152602001612276604051806040016040528060008152602001600081525090565b905290565b60008083601f84011261228d57600080fd5b50813567ffffffffffffffff8111156122a557600080fd5b6020830191508360208285010111156122bd57600080fd5b9250929050565b73ffffffffffffffffffffffffffffffffffffffff8116811461152557600080fd5b600080600080600080600087890360e081121561230257600080fd5b606081121561231057600080fd5b5087965060608801359550608088013567ffffffffffffffff8082111561233657600080fd5b6123428b838c0161227b565b909750955060a08a01359150612357826122c4565b90935060c0890135908082111561236d57600080fd5b5061237a8a828b0161227b565b989b979a50959850939692959293505050565b803563ffffffff8116811461072e57600080fd5b6000602082840312156123b357600080fd5b6120ad8261238d565b60008083601f8401126123ce57600080fd5b50813567ffffffffffffffff8111156123e657600080fd5b6020830191508360208260051b85010111156122bd57600080fd5b6000806000806000806060878903121561241a57600080fd5b863567ffffffffffffffff8082111561243257600080fd5b61243e8a838b016123bc565b9098509650602089013591508082111561245757600080fd5b6124638a838b016123bc565b9096509450604089013591508082111561247c57600080fd5b5061248989828a016123bc565b979a9699509497509295939492505050565b8035801515811461072e57600080fd5b6000602082840312156124bd57600080fd5b6120ad8261249b565b600080602083850312156124d957600080fd5b823567ffffffffffffffff8111156124f057600080fd5b6124fc8582860161227b565b90969095509350505050565b60006020828403121561251a57600080fd5b81356120ad816122c4565b67ffffffffffffffff8116811461152557600080fd5b60008060006060848603121561255057600080fd5b6125598461238d565b925060208401359150604084013561257081612525565b809150509250925092565b60008060006060848603121561259057600080fd5b6125998461238d565b9250602084013591506125ae6040850161249b565b90509250925092565b600080604083850312156125ca57600080fd5b6125d38361238d565b946020939093013593505050565b803560ff8116811461072e57600080fd5b6000806000806060858703121561260857600080fd5b6126118561238d565b935061261f602086016125e1565b9250604085013567ffffffffffffffff81111561263b57600080fd5b6126478782880161227b565b95989497509550505050565b600080600080600080600060a0888a03121561266e57600080fd5b8735612679816122c4565b965060208801359550604088013567ffffffffffffffff8082111561269d57600080fd5b6126a98b838c0161227b565b909750955060608a013591506126be826122c4565b9093506080890135908082111561236d57600080fd5b600080604083850312156126e757600080fd5b82356125d3816122c4565b6000806020838503121561270557600080fd5b823567ffffffffffffffff81111561271c57600080fd5b6124fc858286016123bc565b60006020828403121561273a57600080fd5b81356120ad81612525565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b81810381811115610fa857610fa8612745565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000602082840312156127c857600080fd5b6120ad826125e1565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261280657600080fd5b83018035915067ffffffffffffffff82111561282157600080fd5b6020019150368190038213156122bd57600080fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361286757612867612745565b5060010190565b7fffffffff0000000000000000000000000000000000000000000000000000000081358181169160048510156128ae5780818660040360031b1b83161692505b505092915050565b8183823760009101908152919050565b600067ffffffffffffffff8083168181036128e3576128e3612745565b6001019392505050565b67ffffffffffffffff81811683821601908082111561290e5761290e612745565b5092915050565b80820180821115610fa857610fa8612745565b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff4183360301811261295c57600080fd5b9190910192915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60005b838110156129b0578181015183820152602001612998565b50506000910152565b6000602082840312156129cb57600080fd5b815167ffffffffffffffff808211156129e357600080fd5b818401915084601f8301126129f757600080fd5b815181811115612a0957612a09612966565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908382118183101715612a4f57612a4f612966565b81604052828152876020848701011115612a6857600080fd5b612a79836020830160208801612995565b979650505050505050565b60008151808452612a9c816020860160208601612995565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b61ffff83168152604060208201526000612aeb6040830184612a84565b949350505050565b73ffffffffffffffffffffffffffffffffffffffff8516815283602082015260606040820152816060820152818360808301376000818301608090810191909152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01601019392505050565b6060815263ffffffff84511660608201526020840151608082015260006040850151608060a0840152612b9a60e0840182612a84565b905060608601517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa08483030160c0850152612bd58282612a84565b9250505083602083015273ffffffffffffffffffffffffffffffffffffffff83166040830152949350505050565b600060408284031215612c1557600080fd5b6040516040810181811067ffffffffffffffff82111715612c3857612c38612966565b604052825181526020928301519281019290925250919050565b600060808284031215612c6457600080fd5b6040516060810181811067ffffffffffffffff82111715612c8757612c87612966565b604052825181526020830151612c9c81612525565b6020820152612cae8460408501612c03565b60408201529392505050565b60008085851115612cca57600080fd5b83861115612cd757600080fd5b5050820193919092039150565b7fff0000000000000000000000000000000000000000000000000000000000000081358181169160018510156128ae5760019490940360031b84901b1690921692915050565b73ffffffffffffffffffffffffffffffffffffffff8616815263ffffffff8516602082015260a060408201526000612d6560a0830186612a84565b84151560608401528281036080840152612d7f8185612a84565b98975050505050505050565b600060408284031215612d9d57600080fd5b6120ad8383612c03565b61ffff81811683821601908082111561290e5761290e612745565b60008651612dd4818460208b01612995565b80830190507fff00000000000000000000000000000000000000000000000000000000000000808860f81b1682527fffff0000000000000000000000000000000000000000000000000000000000008760f01b166001830152808660f81b166003830152508351612e4c816004840160208801612995565b0160040197965050505050505056fea264697066735822122059865556085428d89bf9ffe92d585666c056dc992b6c31f04fc27710a2cfbf6e64736f6c63430008130033",
  "deployedBytecode": "0x6080604052600436106101ae5760003560e01c8063715018a6116100eb578063bb0b6a531161008f578063f2fde38b11610061578063f2fde38b1461054f578063f3fef3a31461056f578063f5c6ba5a1461058f578063f851a440146105a257005b8063bb0b6a53146104c7578063c95c55be146104f4578063d0a1026014610507578063d22446ce1461051a57005b80638da5cb5b116100c85780638da5cb5b1461043c578063950c8a7414610467578063b7abbb5d14610494578063baf3292d146104a757005b8063715018a6146103ce5780637624f505146103e35780637d25a05e1461040357005b806356a4728911610152578063622f17f61161012f578063622f17f614610341578063655f06381461036e578063704b6c021461038e5780637112f86f146103ae57005b806356a472891461029b5780635b849af6146102c85780635e280f11146102e857005b806326b27f841161018b57806326b27f8414610209578063416ecebf14610229578063542e7b561461027357806354fd4d501461028657005b806306661abd146101b757806313137d65146101e0578063257f4e05146101f357005b366101b557005b005b3480156101c357600080fd5b506101cd60035481565b6040519081526020015b60405180910390f35b6101b56101ee3660046122e6565b6105cf565b3480156101ff57600080fd5b506101cd60045481565b34801561021557600080fd5b506101cd6102243660046123a1565b6106d9565b34801561023557600080fd5b5060055461025e9074010000000000000000000000000000000000000000900463ffffffff1681565b60405163ffffffff90911681526020016101d7565b6101b5610281366004612401565b610733565b34801561029257600080fd5b506101cd600181565b3480156102a757600080fd5b506101cd6102b63660046123a1565b60086020526000908152604090205481565b3480156102d457600080fd5b506101b56102e33660046124ab565b610975565b3480156102f457600080fd5b5061031c7f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016101d7565b34801561034d57600080fd5b506101cd61035c3660046123a1565b60096020526000908152604090205481565b34801561037a57600080fd5b506101b56103893660046124c6565b6109ae565b34801561039a57600080fd5b506101b56103a9366004612508565b610c90565b3480156103ba57600080fd5b506101b56103c936600461253b565b610d58565b3480156103da57600080fd5b506101b5610e8c565b3480156103ef57600080fd5b506101b56103fe36600461257b565b610ea0565b34801561040f57600080fd5b5061042361041e3660046125b7565b610f59565b60405167ffffffffffffffff90911681526020016101d7565b34801561044857600080fd5b5060005473ffffffffffffffffffffffffffffffffffffffff1661031c565b34801561047357600080fd5b5060025461031c9073ffffffffffffffffffffffffffffffffffffffff1681565b6101b56104a23660046125f2565b610fae565b3480156104b357600080fd5b506101b56104c2366004612508565b61105c565b3480156104d357600080fd5b506101cd6104e23660046123a1565b60016020526000908152604090205481565b6101b56105023660046125f2565b6110dd565b6101b5610515366004612653565b611181565b34801561052657600080fd5b5061053a6105353660046125f2565b611403565b604080519283526020830191909152016101d7565b34801561055b57600080fd5b506101b561056a366004612508565b611471565b34801561057b57600080fd5b506101b561058a3660046126d4565b611528565b6101b561059d3660046126f2565b6115ec565b3480156105ae57600080fd5b5060055461031c9073ffffffffffffffffffffffffffffffffffffffff1681565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163314610645576040517fab08c09e0000000000000000000000000000000000000000000000000000000081523360048201526024015b60405180910390fd5b6020870180359061065a90610224908a6123a1565b14610697576040517fc59a4f640000000000000000000000000000000000000000000000000000000081526020880135600482015260240161063c565b6106c16106a760208901896123a1565b60208901356106bc60608b0160408c01612728565b6117c0565b6106d0878787878787876118f6565b50505050505050565b63ffffffff81166000908152600160205260409020548061072e576040517f196fb6c000000000000000000000000000000000000000000000000000000000815263ffffffff8316600482015260240161063c565b919050565b848114801561074157508483145b6107a7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f4f6d6e69436f756e7465723a206c656e677468206d69736d6174636800000000604482015260640161063c565b6107af612233565b3460005b8781101561096a5760006107c860018a612774565b82146107d457306107d6565b335b905061091360405180608001604052808c8c868181106107f8576107f8612787565b905060200201602081019061080d91906123a1565b63ffffffff1681526020016108428d8d8781811061082d5761082d612787565b905060200201602081019061022491906123a1565b81526020016108978b8b8781811061085c5761085c612787565b905060200201602081019061087191906127b6565b60055474010000000000000000000000000000000000000000900463ffffffff16611b3e565b81526020018888868181106108ae576108ae612787565b90506020028101906108c091906127d1565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920182905250939094525050604080518082019091528781526020810191909152905083611bb7565b93506109448a8a8481811061092a5761092a612787565b905060200201602081019061093f91906123a1565b611c89565b6040840151516109549084612774565b925050808061096290612836565b9150506107b3565b505050505050505050565b61097d611cb2565b600780547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016911515919091179055565b6109b6611cb2565b60006109c2828461286e565b90507fffffffff0000000000000000000000000000000000000000000000000000000081167fb8007ff6000000000000000000000000000000000000000000000000000000001480610a5557507fffffffff0000000000000000000000000000000000000000000000000000000081167f9e7fffcc00000000000000000000000000000000000000000000000000000000145b80610aa157507fffffffff0000000000000000000000000000000000000000000000000000000081167f0678327f00000000000000000000000000000000000000000000000000000000145b80610aed57507fffffffff0000000000000000000000000000000000000000000000000000000081167fb8849ac900000000000000000000000000000000000000000000000000000000145b80610b3957507fffffffff0000000000000000000000000000000000000000000000000000000081167fe16f964d00000000000000000000000000000000000000000000000000000000145b80610b8557507fffffffff0000000000000000000000000000000000000000000000000000000081167f66bf43d600000000000000000000000000000000000000000000000000000000145b610beb576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f4f4170703a2066756e6374696f6e206e6f7420616c6c6f776564000000000000604482015260640161063c565b6000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff168585604051610c359291906128b6565b6000604051808303816000865af19150503d8060008114610c72576040519150601f19603f3d011682016040523d82523d6000602084013e610c77565b606091505b509150915081610c8957805160208201fd5b5050505050565b60055473ffffffffffffffffffffffffffffffffffffffff163314610d11576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f6f6e6c792061646d696e00000000000000000000000000000000000000000000604482015260640161063c565b600580547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b610d60611cb2565b6040517feaeacd6300000000000000000000000000000000000000000000000000000000815263ffffffff841660048201526024810183905267ffffffffffffffff821660448201527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169063eaeacd6390606401600060405180830381600087803b158015610e0457600080fd5b505af1158015610e18573d6000803e3d6000fd5b505060075460ff16159150610e8790505763ffffffff831660009081526006602090815260408083208584529091528120805467ffffffffffffffff1691610e5f836128c6565b91906101000a81548167ffffffffffffffff021916908367ffffffffffffffff160217905550505b505050565b610e94611cb2565b610e9e6000611d33565b565b610ea8611cb2565b63ffffffff831660009081526001602052604090205415158115158103610efb576040517f9556766100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b63ffffffff84166000818152600160209081526040918290208690558151928352820185905283151582820152517fc55181d68816686be8ec55890d24aefed84c9a6a875145822aad2b2c950f027f9181900360600190a150505050565b60075460009060ff1615610fa45763ffffffff83166000908152600660209081526040808320858452909152902054610f9d9067ffffffffffffffff1660016128ed565b9050610fa8565b5060005b92915050565b61104c60405180608001604052808663ffffffff168152602001610fd1876106d9565b8152602001610ff286600560149054906101000a900463ffffffff16611b3e565b815260200184848080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920182905250939094525050604080518082019091523481526020810191909152905033611bb7565b5061105684611c89565b50505050565b611064611cb2565b600280547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040519081527f5db758e995a17ec1ad84bdef7e8c3293a0bd6179bcce400dff5d4c3d87db726b9060200160405180910390a150565b60055473ffffffffffffffffffffffffffffffffffffffff16331461115e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f6f6e6c792061646d696e00000000000000000000000000000000000000000000604482015260640161063c565b610c8960405180608001604052808663ffffffff168152602001610fd1876106d9565b3373ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001614611220576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f21656e64706f696e740000000000000000000000000000000000000000000000604482015260640161063c565b600061122c8686611da8565b90507ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe60ff8216016112765760016004600082825461126b9190612915565b909155506113f99050565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc60ff821601611397576001600460008282546112b39190612915565b90915550600090506112c58787611dca565b90506112d081611c89565b600061132362030d40600061131c604080517e03000000000000000000000000000000000000000000000000000000000000602082015281516002818303018152602290910190915290565b9190611dec565b905061138f60405180608001604052808463ffffffff168152602001611348856106d9565b815260200161136a6001600560149054906101000a900463ffffffff16611b3e565b8152602001838152506040518060400160405280348152602001600081525030611bb7565b5050506113f9565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f696e76616c6964206d6573736167652074797065000000000000000000000000604482015260640161063c565b5050505050505050565b6000806114648661142687600560149054906101000a900463ffffffff16611b3e565b600087878080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250611eb092505050565b9150915094509492505050565b611479611cb2565b73ffffffffffffffffffffffffffffffffffffffff811661151c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f6464726573730000000000000000000000000000000000000000000000000000606482015260840161063c565b61152581611d33565b50565b60055473ffffffffffffffffffffffffffffffffffffffff1633146115a9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f6f6e6c792061646d696e00000000000000000000000000000000000000000000604482015260640161063c565b60405173ffffffffffffffffffffffffffffffffffffffff83169082156108fc029083906000818181858888f19350505050158015610e87573d6000803e3d6000fd5b60025473ffffffffffffffffffffffffffffffffffffffff16331461163f576040517fc023811c00000000000000000000000000000000000000000000000000000000815233600482015260240161063c565b60005b818110156116d5573683838381811061165d5761165d612787565b905060200281019061166f9190612928565b9050600061168361022460208401846123a1565b9050602082013581146116975750506116c3565b6116c08260608101356116ad60808301836127d1565b336116bb60a08901896127d1565b6118f6565b50505b806116cd81612836565b915050611642565b50600254604080517fd2968d57000000000000000000000000000000000000000000000000000000008152905160019273ffffffffffffffffffffffffffffffffffffffff169163d2968d579160048083019260009291908290030181865afa158015611746573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820160405261178c91908101906129b9565b6040517f0a78da8f00000000000000000000000000000000000000000000000000000000815260040161063c929190612ace565b63ffffffff8316600090815260066020908152604080832085845290915290205460075467ffffffffffffffff9091169060ff1615611880576118048160016128ed565b67ffffffffffffffff168267ffffffffffffffff1614611880576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f4f4170703a20696e76616c6964206e6f6e636500000000000000000000000000604482015260640161063c565b8067ffffffffffffffff168267ffffffffffffffff1611156110565763ffffffff841660009081526006602090815260408083208684529091529020805467ffffffffffffffff84167fffffffffffffffffffffffffffffffffffffffffffffffff000000000000000090911617905550505050565b60006119028686611da8565b90507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60ff82160161195e576003805490600061193e83612836565b90915550611959905061195460208a018a6123a1565b611f6c565b6113f9565b60ff811660021480611973575060ff81166004145b15611a4d576003805490600061198883612836565b9091555061199e905061195460208a018a6123a1565b6040517f754d3b9c00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063754d3b9c90611a169030908b908b908b90600401612af3565b600060405180830381600087803b158015611a3057600080fd5b505af1158015611a44573d6000803e3d6000fd5b505050506113f9565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd60ff8216016113975760038054906000611a8783612836565b90915550611a9d905061195460208a018a6123a1565b611aad61093f60208a018a6123a1565b6000611af962030d40600061131c604080517e03000000000000000000000000000000000000000000000000000000000000602082015281516002818303018152602290910190915290565b6040805160808101909152909150611b379080611b1960208d018d6123a1565b63ffffffff16815260209081019061134890610224908e018e6123a1565b50506113f9565b6040517fff0000000000000000000000000000000000000000000000000000000000000060f884901b1660208201527fffffffff0000000000000000000000000000000000000000000000000000000060e083901b1660218201526060906025015b604051602081830303815290604052905092915050565b611bbf612233565b825160208401516040517faca1b45a00000000000000000000000000000000000000000000000000000000815260009273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169263aca1b45a92611c3d918a918990600401612b64565b60806040518083038185885af1158015611c5b573d6000803e3d6000fd5b50505050506040513d601f19601f82011682018060405250810190611c809190612c52565b95945050505050565b63ffffffff81166000908152600960205260408120805491611caa83612836565b919050555050565b60005473ffffffffffffffffffffffffffffffffffffffff163314610e9e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161063c565b6000805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6000611db76001828486612cba565b611dc091612ce4565b60f81c9392505050565b6000611dd98260018186612cba565b611de29161286e565b60e01c9392505050565b6060836003611dfc826000611f8d565b61ffff1614611e8c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526024808201527f4f7074696f6e734275696c6465723a20696e76616c6964206f7074696f6e732060448201527f7479706500000000000000000000000000000000000000000000000000000000606482015260840161063c565b6000611e98858561200d565b9050611ea6866001836120b4565b9695505050505050565b60008060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166383c4755930898989896040518663ffffffff1660e01b8152600401611f16959493929190612d2a565b6040805180830381865afa158015611f32573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f569190612d8b565b8051602090910151909890975095505050505050565b63ffffffff81166000908152600860205260408120805491611caa83612836565b6000611f9a826002612915565b83511015612004576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f746f55696e7431365f6f75744f66426f756e6473000000000000000000000000604482015260640161063c565b50016002015190565b60606fffffffffffffffffffffffffffffffff82161561207657604080517fffffffffffffffffffffffffffffffff00000000000000000000000000000000608086811b8216602084015285901b166030820152016040516020818303038152906040526120ad565b6040517fffffffffffffffffffffffffffffffff00000000000000000000000000000000608085901b166020820152603001611ba0565b9392505050565b60608360036120c4826000611f8d565b61ffff1614612154576040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526024808201527f4f7074696f6e734275696c6465723a20696e76616c6964206f7074696f6e732060448201527f7479706500000000000000000000000000000000000000000000000000000000606482015260840161063c565b846001612161855161219b565b61216c906001612da7565b8686604051602001612182959493929190612dc2565b6040516020818303038152906040529150509392505050565b600061ffff82111561222f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f53616665436173743a2076616c756520646f65736e27742066697420696e203160448201527f3620626974730000000000000000000000000000000000000000000000000000606482015260840161063c565b5090565b604051806060016040528060008019168152602001600067ffffffffffffffff168152602001612276604051806040016040528060008152602001600081525090565b905290565b60008083601f84011261228d57600080fd5b50813567ffffffffffffffff8111156122a557600080fd5b6020830191508360208285010111156122bd57600080fd5b9250929050565b73ffffffffffffffffffffffffffffffffffffffff8116811461152557600080fd5b600080600080600080600087890360e081121561230257600080fd5b606081121561231057600080fd5b5087965060608801359550608088013567ffffffffffffffff8082111561233657600080fd5b6123428b838c0161227b565b909750955060a08a01359150612357826122c4565b90935060c0890135908082111561236d57600080fd5b5061237a8a828b0161227b565b989b979a50959850939692959293505050565b803563ffffffff8116811461072e57600080fd5b6000602082840312156123b357600080fd5b6120ad8261238d565b60008083601f8401126123ce57600080fd5b50813567ffffffffffffffff8111156123e657600080fd5b6020830191508360208260051b85010111156122bd57600080fd5b6000806000806000806060878903121561241a57600080fd5b863567ffffffffffffffff8082111561243257600080fd5b61243e8a838b016123bc565b9098509650602089013591508082111561245757600080fd5b6124638a838b016123bc565b9096509450604089013591508082111561247c57600080fd5b5061248989828a016123bc565b979a9699509497509295939492505050565b8035801515811461072e57600080fd5b6000602082840312156124bd57600080fd5b6120ad8261249b565b600080602083850312156124d957600080fd5b823567ffffffffffffffff8111156124f057600080fd5b6124fc8582860161227b565b90969095509350505050565b60006020828403121561251a57600080fd5b81356120ad816122c4565b67ffffffffffffffff8116811461152557600080fd5b60008060006060848603121561255057600080fd5b6125598461238d565b925060208401359150604084013561257081612525565b809150509250925092565b60008060006060848603121561259057600080fd5b6125998461238d565b9250602084013591506125ae6040850161249b565b90509250925092565b600080604083850312156125ca57600080fd5b6125d38361238d565b946020939093013593505050565b803560ff8116811461072e57600080fd5b6000806000806060858703121561260857600080fd5b6126118561238d565b935061261f602086016125e1565b9250604085013567ffffffffffffffff81111561263b57600080fd5b6126478782880161227b565b95989497509550505050565b600080600080600080600060a0888a03121561266e57600080fd5b8735612679816122c4565b965060208801359550604088013567ffffffffffffffff8082111561269d57600080fd5b6126a98b838c0161227b565b909750955060608a013591506126be826122c4565b9093506080890135908082111561236d57600080fd5b600080604083850312156126e757600080fd5b82356125d3816122c4565b6000806020838503121561270557600080fd5b823567ffffffffffffffff81111561271c57600080fd5b6124fc858286016123bc565b60006020828403121561273a57600080fd5b81356120ad81612525565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b81810381811115610fa857610fa8612745565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000602082840312156127c857600080fd5b6120ad826125e1565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261280657600080fd5b83018035915067ffffffffffffffff82111561282157600080fd5b6020019150368190038213156122bd57600080fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361286757612867612745565b5060010190565b7fffffffff0000000000000000000000000000000000000000000000000000000081358181169160048510156128ae5780818660040360031b1b83161692505b505092915050565b8183823760009101908152919050565b600067ffffffffffffffff8083168181036128e3576128e3612745565b6001019392505050565b67ffffffffffffffff81811683821601908082111561290e5761290e612745565b5092915050565b80820180821115610fa857610fa8612745565b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff4183360301811261295c57600080fd5b9190910192915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60005b838110156129b0578181015183820152602001612998565b50506000910152565b6000602082840312156129cb57600080fd5b815167ffffffffffffffff808211156129e357600080fd5b818401915084601f8301126129f757600080fd5b815181811115612a0957612a09612966565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908382118183101715612a4f57612a4f612966565b81604052828152876020848701011115612a6857600080fd5b612a79836020830160208801612995565b979650505050505050565b60008151808452612a9c816020860160208601612995565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b61ffff83168152604060208201526000612aeb6040830184612a84565b949350505050565b73ffffffffffffffffffffffffffffffffffffffff8516815283602082015260606040820152816060820152818360808301376000818301608090810191909152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01601019392505050565b6060815263ffffffff84511660608201526020840151608082015260006040850151608060a0840152612b9a60e0840182612a84565b905060608601517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa08483030160c0850152612bd58282612a84565b9250505083602083015273ffffffffffffffffffffffffffffffffffffffff83166040830152949350505050565b600060408284031215612c1557600080fd5b6040516040810181811067ffffffffffffffff82111715612c3857612c38612966565b604052825181526020928301519281019290925250919050565b600060808284031215612c6457600080fd5b6040516060810181811067ffffffffffffffff82111715612c8757612c87612966565b604052825181526020830151612c9c81612525565b6020820152612cae8460408501612c03565b60408201529392505050565b60008085851115612cca57600080fd5b83861115612cd757600080fd5b5050820193919092039150565b7fff0000000000000000000000000000000000000000000000000000000000000081358181169160018510156128ae5760019490940360031b84901b1690921692915050565b73ffffffffffffffffffffffffffffffffffffffff8616815263ffffffff8516602082015260a060408201526000612d6560a0830186612a84565b84151560608401528281036080840152612d7f8185612a84565b98975050505050505050565b600060408284031215612d9d57600080fd5b6120ad8383612c03565b61ffff81811683821601908082111561290e5761290e612745565b60008651612dd4818460208b01612995565b80830190507fff00000000000000000000000000000000000000000000000000000000000000808860f81b1682527fffff0000000000000000000000000000000000000000000000000000000000008760f01b166001830152808660f81b166003830152508351612e4c816004840160208801612995565b0160040197965050505050505056fea264697066735822122059865556085428d89bf9ffe92d585666c056dc992b6c31f04fc27710a2cfbf6e64736f6c63430008130033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "lzReceive((uint32,bytes32,uint64),bytes32,bytes,address,bytes)": {
        "details": "Oapp can override this interface for custom logics (e.g. more assertion)"
      },
      "lzReceiveAndRevert(((uint32,bytes32,uint64),bytes32,bytes,bytes)[])": {
        "details": "a generic interface for precrime simulationsthis function reverts at the end with the simulation resultsvalue is provided as a lump sum, does not restrict how much each packet can consume"
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
      },
      "safeGetPeer(uint32)": {
        "details": "check non-zero peer and return it"
      },
      "setEndpointConfig(bytes)": {
        "details": "a generic interface to set the endpoint configthis is a low level interface, and should be used with cautionuse our SDK to generate the properly abi.encoded config"
      },
      "setPeer(uint32,bytes32,bool)": {
        "details": "set _peer to bytes32(0) (the default value) to \"untrust\""
      },
      "setPrecrime(address)": {
        "details": "set the precrime contract. can upgrade the precrime implementation overtime"
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 1818,
        "contract": "contracts/examples/OmniCounter.sol:OmniCounter",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 6142,
        "contract": "contracts/examples/OmniCounter.sol:OmniCounter",
        "label": "peers",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_uint32,t_bytes32)"
      },
      {
        "astId": 6145,
        "contract": "contracts/examples/OmniCounter.sol:OmniCounter",
        "label": "precrime",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(IPreCrime)9540"
      },
      {
        "astId": 7578,
        "contract": "contracts/examples/OmniCounter.sol:OmniCounter",
        "label": "count",
        "offset": 0,
        "slot": "3",
        "type": "t_uint256"
      },
      {
        "astId": 7580,
        "contract": "contracts/examples/OmniCounter.sol:OmniCounter",
        "label": "composedCount",
        "offset": 0,
        "slot": "4",
        "type": "t_uint256"
      },
      {
        "astId": 7582,
        "contract": "contracts/examples/OmniCounter.sol:OmniCounter",
        "label": "admin",
        "offset": 0,
        "slot": "5",
        "type": "t_address"
      },
      {
        "astId": 7584,
        "contract": "contracts/examples/OmniCounter.sol:OmniCounter",
        "label": "eid",
        "offset": 20,
        "slot": "5",
        "type": "t_uint32"
      },
      {
        "astId": 7590,
        "contract": "contracts/examples/OmniCounter.sol:OmniCounter",
        "label": "maxReceivedNonce",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_uint32,t_mapping(t_bytes32,t_uint64))"
      },
      {
        "astId": 7592,
        "contract": "contracts/examples/OmniCounter.sol:OmniCounter",
        "label": "orderedNonce",
        "offset": 0,
        "slot": "7",
        "type": "t_bool"
      },
      {
        "astId": 7596,
        "contract": "contracts/examples/OmniCounter.sol:OmniCounter",
        "label": "inboundCount",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_uint32,t_uint256)"
      },
      {
        "astId": 7600,
        "contract": "contracts/examples/OmniCounter.sol:OmniCounter",
        "label": "outboundCount",
        "offset": 0,
        "slot": "9",
        "type": "t_mapping(t_uint32,t_uint256)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(IPreCrime)9540": {
        "encoding": "inplace",
        "label": "contract IPreCrime",
        "numberOfBytes": "20"
      },
      "t_mapping(t_bytes32,t_uint64)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint64)",
        "numberOfBytes": "32",
        "value": "t_uint64"
      },
      "t_mapping(t_uint32,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_uint32",
        "label": "mapping(uint32 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_mapping(t_uint32,t_mapping(t_bytes32,t_uint64))": {
        "encoding": "mapping",
        "key": "t_uint32",
        "label": "mapping(uint32 => mapping(bytes32 => uint64))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes32,t_uint64)"
      },
      "t_mapping(t_uint32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint32",
        "label": "mapping(uint32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      }
    }
  }
}