{
  "address": "0x76ca03a67C049477FfB09694dFeF00416dB69746",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address payable",
          "name": "_omniCounter",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "counter",
      "outputs": [
        {
          "internalType": "contract OmniCounter",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32[]",
          "name": "peerEids",
          "type": "uint32[]"
        }
      ],
      "name": "getCounts",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "eid",
              "type": "uint32"
            },
            {
              "internalType": "uint256",
              "name": "inboundCount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outboundCount",
              "type": "uint256"
            }
          ],
          "internalType": "struct OmniCounterViewer.Count[]",
          "name": "counts",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint32",
                  "name": "srcEid",
                  "type": "uint32"
                },
                {
                  "internalType": "bytes32",
                  "name": "sender",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint64",
                  "name": "nonce",
                  "type": "uint64"
                }
              ],
              "internalType": "struct Origin",
              "name": "origin",
              "type": "tuple"
            },
            {
              "internalType": "bytes32",
              "name": "guid",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "message",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "callParams",
              "type": "bytes"
            }
          ],
          "internalType": "struct IPreCrime.Packet",
          "name": "packet",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "eid",
              "type": "uint32"
            },
            {
              "internalType": "uint256",
              "name": "inboundCount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outboundCount",
              "type": "uint256"
            }
          ],
          "internalType": "struct OmniCounterViewer.Count[]",
          "name": "counts",
          "type": "tuple[]"
        }
      ],
      "name": "lzReceive",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "eid",
              "type": "uint32"
            },
            {
              "internalType": "uint256",
              "name": "inboundCount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outboundCount",
              "type": "uint256"
            }
          ],
          "internalType": "struct OmniCounterViewer.Count[]",
          "name": "",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x831cf851a149c3a546e9e5ff69bff135ec6563dc61d9f7a8ab543c7e080b6a46",
  "receipt": {
    "to": null,
    "from": "0x14dC79964da2C08b23698B3D3cc7Ca32193d9955",
    "contractAddress": "0x76ca03a67C049477FfB09694dFeF00416dB69746",
    "transactionIndex": 0,
    "gasUsed": "697498",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x723b273a5d77f7d6d375ae9307c00a315be5bac11f1eed950b6a1317a3ce341d",
    "transactionHash": "0x831cf851a149c3a546e9e5ff69bff135ec6563dc61d9f7a8ab543c7e080b6a46",
    "logs": [],
    "blockNumber": 16524337,
    "cumulativeGasUsed": "697498",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xef11D1c2aA48826D4c41e54ab82D1Ff5Ad8A64Ca"
  ],
  "numDeployments": 1,
  "solcInputHash": "7b29806b85282df4a83b429384afd158",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_omniCounter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"counter\",\"outputs\":[{\"internalType\":\"contract OmniCounter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"peerEids\",\"type\":\"uint32[]\"}],\"name\":\"getCounts\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"eid\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"inboundCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outboundCount\",\"type\":\"uint256\"}],\"internalType\":\"struct OmniCounterViewer.Count[]\",\"name\":\"counts\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"srcEid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"internalType\":\"struct Origin\",\"name\":\"origin\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"guid\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callParams\",\"type\":\"bytes\"}],\"internalType\":\"struct IPreCrime.Packet\",\"name\":\"packet\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"eid\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"inboundCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outboundCount\",\"type\":\"uint256\"}],\"internalType\":\"struct OmniCounterViewer.Count[]\",\"name\":\"counts\",\"type\":\"tuple[]\"}],\"name\":\"lzReceive\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"eid\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"inboundCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outboundCount\",\"type\":\"uint256\"}],\"internalType\":\"struct OmniCounterViewer.Count[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/examples/OmniCounterViewer.sol\":\"OmniCounterViewer\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":20000},\"remappings\":[]},\"sources\":{\"@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/libs/VerifierOptions.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"solidity-bytes-utils/contracts/BytesLib.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/BitMaps.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Errors.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol\\\";\\n\\nlibrary VerifierOptions {\\n    using BitMaps for BitMaps.BitMap256;\\n    using CalldataBytesLib for bytes;\\n    using BytesLib for bytes;\\n\\n    uint8 internal constant WORKER_ID = 2;\\n    uint8 internal constant OPTION_TYPE_PRECRIME = 1;\\n\\n    /// @dev group verifier options by its idx\\n    /// @param _options [verifier_id][verifier_option][verifier_id][verifier_option]...\\n    ///        verifier_option = [option_size][verifier_idx][option_type][option]\\n    ///        option_size = len(verifier_idx) + len(option_type) + len(option)\\n    ///        verifier_id: uint8, verifier_idx: uint8, option_size: uint16, option_type: uint8, option: bytes\\n    /// @return verifierOptions the grouped options, still share the same format of _options\\n    /// @return verifierIndices the verifier indices\\n    function groupVerifierOptionsByIdx(\\n        bytes memory _options\\n    ) internal pure returns (bytes[] memory verifierOptions, uint8[] memory verifierIndices) {\\n        if (_options.length == 0) return (verifierOptions, verifierIndices);\\n\\n        uint8 numVerifiers = getNumVerifiers(_options);\\n\\n        // if there is only 1 verifier, we can just return the whole options\\n        if (numVerifiers == 1) {\\n            verifierOptions = new bytes[](1);\\n            verifierOptions[0] = _options;\\n\\n            verifierIndices = new uint8[](1);\\n            verifierIndices[0] = _options.toUint8(3); // verifier idx\\n            return (verifierOptions, verifierIndices);\\n        }\\n\\n        // otherwise, we need to group the options by verifier_idx\\n        verifierIndices = new uint8[](numVerifiers);\\n        verifierOptions = new bytes[](numVerifiers);\\n        unchecked {\\n            uint cursor;\\n            uint start;\\n            uint8 lastVerifierIdx = 255; // 255 is an invalid verifier_idx\\n\\n            while (cursor < _options.length) {\\n                ++cursor; // skip worker_id\\n\\n                uint16 optionLength = _options.toUint16(cursor);\\n                cursor += 2;\\n                require(optionLength >= 2, Errors.INVALID_SIZE); // at least 1 byte for option_type and 1 byte for verifier_idx\\n\\n                uint8 verifierIdx = _options.toUint8(cursor);\\n\\n                if (lastVerifierIdx == 255) {\\n                    lastVerifierIdx = verifierIdx;\\n                }\\n\\n                // verifierIdx must equal to the lastVerifierIdx for the first option\\n                // so it is always skipped in the first option\\n                // this operation slices out options whenever the the scan finds a different lastVerifierIdx\\n                if (verifierIdx != lastVerifierIdx) {\\n                    uint size = cursor - start - 3; // 3 is for worker_id and option_length\\n                    bytes memory op = _options.slice(start, size);\\n                    _insertVerifierOptions(verifierOptions, verifierIndices, lastVerifierIdx, op);\\n\\n                    // reset the start and lastVerifierIdx\\n                    start += size;\\n                    lastVerifierIdx = verifierIdx;\\n                }\\n\\n                cursor += optionLength;\\n\\n                // if we have reached the end of the options, we need to process the last verifier\\n                if (cursor == _options.length) {\\n                    uint size = cursor - start;\\n                    bytes memory op = _options.slice(start, size);\\n                    _insertVerifierOptions(verifierOptions, verifierIndices, verifierIdx, op);\\n                }\\n            }\\n            require(cursor == _options.length, Errors.INVALID_SIZE);\\n\\n            // revert verifierIndices to start from 0\\n            for (uint8 i = 0; i < numVerifiers; ++i) {\\n                --verifierIndices[i];\\n            }\\n        }\\n    }\\n\\n    function _insertVerifierOptions(\\n        bytes[] memory _verifierOptions,\\n        uint8[] memory _verifierIndices,\\n        uint8 _verifierIdx,\\n        bytes memory _newOptions\\n    ) internal pure {\\n        // verifierIdx starts from 0 but default value of verifierIndices is 0, so we tell if the slot is empty by adding 1 to verifierIdx\\n        require(_verifierIdx < 255, Errors.INVALID_VERIFIERS);\\n        uint8 verifierIdxAdj = _verifierIdx + 1;\\n\\n        for (uint8 j = 0; j < _verifierIndices.length; ++j) {\\n            uint8 index = _verifierIndices[j];\\n            if (verifierIdxAdj == index) {\\n                _verifierOptions[j] = abi.encodePacked(_verifierOptions[j], _newOptions);\\n                break;\\n            } else if (index == 0) {\\n                // empty slot, that means it is the first time we see this verifier\\n                _verifierIndices[j] = verifierIdxAdj;\\n                _verifierOptions[j] = _newOptions;\\n                break;\\n            }\\n        }\\n    }\\n\\n    /// @dev get the number of unique verifiers\\n    /// @param _options the format is the same as groupVerifierOptionsByIdx\\n    function getNumVerifiers(bytes memory _options) internal pure returns (uint8 numVerifiers) {\\n        uint cursor;\\n        BitMaps.BitMap256 bitmap;\\n\\n        // find number of unique verifier_idx\\n        unchecked {\\n            while (cursor < _options.length) {\\n                ++cursor; // skip worker_id\\n\\n                uint16 optionLength = _options.toUint16(cursor);\\n                cursor += 2;\\n                require(optionLength >= 2, Errors.INVALID_SIZE); // at least 1 byte for verifier_idx and 1 byte for option_type\\n\\n                uint8 verifierIdx = _options.toUint8(cursor);\\n\\n                // verifierIdx starts from 0, add one for bitmap check/set\\n                require(verifierIdx < 255, Errors.INVALID_VERIFIERS);\\n                uint8 verifierIdxAdj = verifierIdx + 1;\\n\\n                // if verifierIdx is not set, increment numVerifiers\\n                if (!bitmap.get(verifierIdxAdj)) {\\n                    ++numVerifiers;\\n                    bitmap = bitmap.set(verifierIdxAdj);\\n                }\\n\\n                cursor += optionLength;\\n            }\\n        }\\n        require(cursor == _options.length, Errors.INVALID_SIZE);\\n    }\\n\\n    /// @dev decode the next verifier option from _options starting from the specified cursor\\n    /// @param _options the format is the same as groupVerifierOptionsByIdx\\n    /// @param _cursor the cursor to start decoding\\n    /// @return optionType the type of the option\\n    /// @return option the option\\n    /// @return cursor the cursor to start decoding the next option\\n    function nextVerifierOption(\\n        bytes calldata _options,\\n        uint _cursor\\n    ) internal pure returns (uint8 optionType, bytes calldata option, uint cursor) {\\n        unchecked {\\n            // skip worker id\\n            cursor = _cursor + 1;\\n\\n            // read option size\\n            uint16 size = _options.toU16(cursor);\\n            cursor += 2;\\n\\n            // read option type\\n            optionType = _options.toU8(cursor + 1); // skip verifier_idx\\n\\n            // startCursor and endCursor are used to slice the option from _options\\n            uint startCursor = cursor + 2; // skip option type and verifier_idx\\n            uint endCursor = cursor + size;\\n            option = _options[startCursor:endCursor];\\n            cursor += size;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x64ce5ceb89a26cdcddd34f2d90838cc41de88beb510c810247648de085492b31\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/MessagingStructs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\nstruct PacketForQuote {\\n    address sender;\\n    uint32 dstEid;\\n    bytes message;\\n}\\n\\nstruct Packet {\\n    uint64 nonce;\\n    uint32 srcEid;\\n    address sender;\\n    uint32 dstEid;\\n    bytes32 receiver;\\n    bytes32 guid;\\n    bytes message;\\n}\\n\\nstruct Origin {\\n    uint32 srcEid;\\n    bytes32 sender;\\n    uint64 nonce;\\n}\\n\",\"keccak256\":\"0x8a4a8eba63ff7313aee2d476b643fd05ec13e91fa0a7cea1b9af0f0d04aee645\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroComposer.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\ninterface ILayerZeroComposer {\\n    function lzCompose(\\n        address _receiver,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        address _caller,\\n        bytes calldata _extraData\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0x3e7e7e659a2e469eb7b0961d5bc36884a284e0a7b6b66230db7b72217b65f5df\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IMessageLibManager.sol\\\";\\nimport \\\"./IMessagingComposer.sol\\\";\\nimport \\\"./IMessagingChannel.sol\\\";\\nimport \\\"./IMessagingContext.sol\\\";\\nimport {Origin} from \\\"../MessagingStructs.sol\\\";\\n\\nstruct MessagingParams {\\n    uint32 dstEid;\\n    bytes32 receiver;\\n    bytes message;\\n    bytes options;\\n}\\n\\nstruct MessagingReceipt {\\n    bytes32 guid;\\n    uint64 nonce;\\n    MessagingFee fee;\\n}\\n\\nstruct MessagingFee {\\n    uint nativeFee;\\n    uint lzTokenFee;\\n}\\n\\ninterface ILayerZeroEndpointV2 is IMessageLibManager, IMessagingComposer, IMessagingChannel, IMessagingContext {\\n    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);\\n\\n    event PacketDelivered(Origin origin, address receiver, bytes32 payloadHash);\\n\\n    event PacketReceived(Origin origin, address receiver);\\n\\n    event LzReceiveFailed(Origin origin, address receiver, bytes reason);\\n\\n    event FeePaid(MessagingFee fee);\\n\\n    event LayerZeroTokenSet(address token);\\n\\n    function quote(\\n        address _sender,\\n        uint32 _dstEid,\\n        bytes calldata _message,\\n        bool _payInLzToken,\\n        bytes calldata _options\\n    ) external view returns (MessagingFee memory);\\n\\n    function send(\\n        MessagingParams calldata _params,\\n        uint _lzTokenFee,\\n        address payable _refundAddress\\n    ) external payable returns (MessagingReceipt memory);\\n\\n    function sendWithAlt(\\n        MessagingParams calldata _params,\\n        uint _lzTokenFee,\\n        uint _altTokenFee\\n    ) external returns (MessagingReceipt memory);\\n\\n    function deliver(Origin calldata _origin, address _receiver, bytes32 _payloadHash) external;\\n\\n    function deliverable(Origin calldata _origin, address _receiveLib, address _receiver) external view returns (bool);\\n\\n    function lzReceive(\\n        Origin calldata _origin,\\n        address _receiver,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        bytes calldata _extraData\\n    ) external payable returns (bool, bytes memory);\\n\\n    // oapp can burn messages partially by calling this function with its own business logic if messages are delivered in order\\n    function clear(Origin calldata _origin, bytes32 _guid, bytes calldata _message) external;\\n\\n    function setLayerZeroToken(address _layerZeroToken) external;\\n\\n    function layerZeroToken() external view returns (address);\\n\\n    function altFeeToken() external view returns (address);\\n}\\n\",\"keccak256\":\"0xd28654aeb9c0baf8ca04418b0e5af31a4d1b6e7a3d59ad54e57919bb241dffb3\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\nimport {Origin} from \\\"../MessagingStructs.sol\\\";\\n\\ninterface ILayerZeroReceiver {\\n    function nextNonce(uint32 _eid, bytes32 _sender) external view returns (uint64);\\n\\n    function lzReceive(\\n        Origin calldata _origin,\\n        bytes32 _guid,\\n        bytes memory _message,\\n        address _executor,\\n        bytes calldata _extraData\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0xf2f6095c492980f567f32950a8e033579642fb238e7e8fffd08143ff8fa652b3\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\nstruct SetConfigParam {\\n    uint32 configType;\\n    bytes config;\\n}\\n\\ninterface IMessageLibManager {\\n    struct Timeout {\\n        address lib;\\n        uint expiry;\\n    }\\n\\n    event LibraryRegistered(address newLib);\\n    event DefaultSendLibrarySet(uint32 eid, address newLib);\\n    event DefaultReceiveLibrarySet(uint32 eid, address oldLib, address newLib);\\n    event DefaultReceiveLibraryTimeoutSet(uint32 eid, address oldLib, uint expiry);\\n    event SendLibrarySet(address sender, uint32 eid, address newLib);\\n    event ReceiveLibrarySet(address receiver, uint32 eid, address oldLib, address newLib);\\n    event ReceiveLibraryTimoutSet(address receiver, uint32 eid, address oldLib, uint timeout);\\n\\n    function registerLibrary(address _lib) external;\\n\\n    function isRegisteredLibrary(address _lib) external view returns (bool);\\n\\n    function getRegisteredLibraries() external view returns (address[] memory);\\n\\n    function setDefaultSendLibrary(uint32 _eid, address _newLib) external;\\n\\n    function defaultSendLibrary(uint32 _eid) external view returns (address);\\n\\n    function setDefaultReceiveLibrary(uint32 _eid, address _newLib, uint _timeout) external;\\n\\n    function defaultReceiveLibrary(uint32 _eid) external view returns (address);\\n\\n    function setDefaultReceiveLibraryTimeout(uint32 _eid, address _lib, uint _expiry) external;\\n\\n    function defaultReceiveLibraryTimeout(uint32 _eid) external view returns (address lib, uint expiry);\\n\\n    function defaultConfig(address _lib, uint32 _eid, uint32 _configType) external view returns (bytes memory);\\n\\n    function isSupportedEid(uint32 _eid) external view returns (bool);\\n\\n    /// ------------------- OApp interfaces -------------------\\n    function setSendLibrary(uint32 _eid, address _newLib) external;\\n\\n    function getSendLibrary(address _sender, uint32 _eid) external view returns (address lib);\\n\\n    function isDefaultSendLibrary(address _sender, uint32 _eid) external view returns (bool);\\n\\n    function setReceiveLibrary(uint32 _eid, address _newLib, uint _gracePeriod) external;\\n\\n    function getReceiveLibrary(address _receiver, uint32 _eid) external view returns (address lib, bool isDefault);\\n\\n    function setReceiveLibraryTimeout(uint32 _eid, address _lib, uint _gracePeriod) external;\\n\\n    function receiveLibraryTimeout(address _receiver, uint32 _eid) external view returns (address lib, uint expiry);\\n\\n    function setConfig(address _lib, uint32 _eid, SetConfigParam[] calldata _params) external;\\n\\n    function getConfig(\\n        address _oapp,\\n        address _lib,\\n        uint32 _eid,\\n        uint32 _configType\\n    ) external view returns (bytes memory config, bool isDefault);\\n\\n    function snapshotConfig(address _lib, uint32[] calldata _eids) external;\\n\\n    function resetConfig(address _lib, uint32[] calldata _eids) external;\\n}\\n\",\"keccak256\":\"0xf5a21fd6499c96c7cd5998a3c4cb6bea41ff3ec1be212dfdac368d428803091f\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessagingChannel {\\n    event InboundNonceSkipped(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce);\\n\\n    function eid() external view returns (uint32);\\n\\n    // this is an emergency function if a message can not be delivered for some reasons\\n    // required to provide _nextNonce to avoid race condition\\n    function skip(uint32 _srcEid, bytes32 _sender, uint64 _nonce) external;\\n\\n    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32);\\n\\n    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\\n\\n    function outboundNonce(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (uint64);\\n\\n    function inboundPayloadHash(\\n        address _receiver,\\n        uint32 _srcEid,\\n        bytes32 _sender,\\n        uint64 _nonce\\n    ) external view returns (bytes32);\\n\\n    function hasPayloadHash(\\n        address _receiver,\\n        uint32 _srcEid,\\n        bytes32 _sender,\\n        uint64 _nonce\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xe9c180ca201e8af11747079224729e0552addf70d65c60e7a61a4624a28d4e5c\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingComposer.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessagingComposer {\\n    event ComposedMessageDelivered(address receiver, address composer, bytes32 guid, bytes message);\\n    event ComposedMessageReceived(\\n        address receiver,\\n        address composer,\\n        bytes32 guid,\\n        bytes32 messageHash,\\n        address caller\\n    );\\n    event LzComposeFailed(\\n        address sender,\\n        address receiver,\\n        bytes32 guid,\\n        bytes32 messageHash,\\n        address caller,\\n        bytes reason\\n    );\\n\\n    function deliverComposedMessage(address _composer, bytes32 _guid, bytes calldata _message) external;\\n\\n    function lzCompose(\\n        address _receiver,\\n        address _composer,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        bytes calldata _extraData\\n    ) external payable returns (bool, bytes memory);\\n}\\n\",\"keccak256\":\"0x3993726690a51a8660c2145d3d1483e03d93de7a578afc4130467bf6804f6896\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingContext.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessagingContext {\\n    function isSendingMessage() external view returns (bool);\\n\\n    function getSendContext() external view returns (uint32, address);\\n}\\n\",\"keccak256\":\"0x6af87d5d41d060363fe554ff0ce9138f1ad8e20c1aaeec777d4132fc505e74e8\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nlibrary CalldataBytesLib {\\n    function toU8(bytes calldata _bytes, uint _start) internal pure returns (uint8) {\\n        return uint8(_bytes[_start]);\\n    }\\n\\n    function toU16(bytes calldata _bytes, uint _start) internal pure returns (uint16) {\\n        unchecked {\\n            uint end = _start + 2;\\n            return uint16(bytes2(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toU32(bytes calldata _bytes, uint _start) internal pure returns (uint32) {\\n        unchecked {\\n            uint end = _start + 4;\\n            return uint32(bytes4(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toU64(bytes calldata _bytes, uint _start) internal pure returns (uint64) {\\n        unchecked {\\n            uint end = _start + 8;\\n            return uint64(bytes8(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toU128(bytes calldata _bytes, uint _start) internal pure returns (uint128) {\\n        unchecked {\\n            uint end = _start + 16;\\n            return uint128(bytes16(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toU256(bytes calldata _bytes, uint _start) internal pure returns (uint256) {\\n        unchecked {\\n            uint end = _start + 32;\\n            return uint256(bytes32(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toAddr(bytes calldata _bytes, uint _start) internal pure returns (address) {\\n        unchecked {\\n            uint end = _start + 20;\\n            return address(bytes20(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toB32(bytes calldata _bytes, uint _start) internal pure returns (bytes32) {\\n        unchecked {\\n            uint end = _start + 32;\\n            return bytes32(_bytes[_start:end]);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6984a7e7f292ec4533ac684583e5d0505bee3bc4348776072413ceb521a6acc8\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Errors {\\n    // Invalid Argument (http: 400)\\n    string internal constant INVALID_ARGUMENT = \\\"LZ10000\\\";\\n    string internal constant ONLY_REGISTERED = \\\"LZ10001\\\";\\n    string internal constant ONLY_REGISTERED_OR_DEFAULT = \\\"LZ10002\\\";\\n    string internal constant INVALID_AMOUNT = \\\"LZ10003\\\";\\n    string internal constant INVALID_NONCE = \\\"LZ10004\\\";\\n    string internal constant SAME_VALUE = \\\"LZ10005\\\";\\n    string internal constant UNSORTED = \\\"LZ10006\\\";\\n    string internal constant INVALID_VERSION = \\\"LZ10007\\\";\\n    string internal constant INVALID_EID = \\\"LZ10008\\\";\\n    string internal constant INVALID_SIZE = \\\"LZ10009\\\";\\n    string internal constant ONLY_NON_DEFAULT = \\\"LZ10010\\\";\\n    string internal constant INVALID_VERIFIERS = \\\"LZ10011\\\";\\n    string internal constant DUPLICATED = \\\"LZ10012\\\";\\n    string internal constant INVALID_WORKER_ID = \\\"LZ10013\\\";\\n\\n    // Out of Range (http: 400)\\n    string internal constant OUT_OF_RANGE = \\\"LZ20000\\\";\\n\\n    // Invalid State (http: 400)\\n    string internal constant INVALID_STATE = \\\"LZ30000\\\";\\n    string internal constant SEND_REENTRANCY = \\\"LZ30001\\\";\\n    string internal constant RECEIVE_REENTRANCY = \\\"LZ30002\\\";\\n    string internal constant COMPOSE_REENTRANCY = \\\"LZ30003\\\";\\n\\n    // Permission Denied (http: 403)\\n    string internal constant PERMISSION_DENIED = \\\"LZ50000\\\";\\n\\n    // Not Found (http: 404)\\n    string internal constant NOT_FOUND = \\\"LZ60000\\\";\\n\\n    // Already Exists (http: 409)\\n    string internal constant ALREADY_EXISTS = \\\"LZ80000\\\";\\n\\n    // Not Implemented (http: 501)\\n    string internal constant NOT_IMPLEMENTED = \\\"LZC0000\\\";\\n    string internal constant UNSUPPORTED_INTERFACE = \\\"LZC0001\\\";\\n\\n    // Unavailable (http: 503)\\n    string internal constant UNAVAILABLE = \\\"LZD0000\\\";\\n    string internal constant NATIVE_COIN_UNAVAILABLE = \\\"LZD0001\\\";\\n    string internal constant TOKEN_UNAVAILABLE = \\\"LZD0002\\\";\\n    string internal constant DEFAULT_LIBRARY_UNAVAILABLE = \\\"LZD0003\\\";\\n    string internal constant VERIFIERS_UNAVAILABLE = \\\"LZD0004\\\";\\n}\\n\",\"keccak256\":\"0x00c68dee6968a14fa9a120a7447a3f568379c86f2a59d363e902128d4f361a6e\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/BitMaps.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\n// modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/BitMaps.sol\\npragma solidity ^0.8.19;\\n\\nlibrary BitMaps {\\n    type BitMap256 is uint;\\n\\n    /**\\n     * @dev Returns whether the bit at `index` is set.\\n     */\\n    function get(BitMap256 bitmap, uint8 index) internal pure returns (bool) {\\n        uint256 mask = 1 << (index & 0xff);\\n        return BitMap256.unwrap(bitmap) & mask != 0;\\n    }\\n\\n    /**\\n     * @dev Sets the bit at `index`.\\n     */\\n    function set(BitMap256 bitmap, uint8 index) internal pure returns (BitMap256) {\\n        uint256 mask = 1 << (index & 0xff);\\n        return BitMap256.wrap(BitMap256.unwrap(bitmap) | mask);\\n    }\\n}\\n\",\"keccak256\":\"0x29b1fb7dda9d3d6a699938da8610c0aa58d2eeb4244c6889a657eaf24117ac8e\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/ExecutorOptions.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../libs/Errors.sol\\\";\\nimport \\\"../../libs/CalldataBytesLib.sol\\\";\\n\\nlibrary ExecutorOptions {\\n    using CalldataBytesLib for bytes;\\n\\n    uint8 internal constant WORKER_ID = 1;\\n\\n    uint8 internal constant OPTION_TYPE_LZRECEIVE = 1;\\n    uint8 internal constant OPTION_TYPE_AIRDROP = 2;\\n    uint8 internal constant OPTION_TYPE_LZCOMPOSE = 3;\\n    uint8 internal constant OPTION_TYPE_ORDERED_EXECUTION = 4;\\n\\n    /// @dev decode the next executor option from the options starting from the specified cursor\\n    /// @param _options [executor_id][executor_option][executor_id][executor_option]...\\n    ///        executor_option = [option_size][option_type][option]\\n    ///        option_size = len(option_type) + len(option)\\n    ///        executor_id: uint8, option_size: uint16, option_type: uint8, option: bytes\\n    /// @param _cursor the cursor to start decoding from\\n    /// @return optionType the type of the option\\n    /// @return option the option of the executor\\n    /// @return cursor the cursor to start decoding the next executor option\\n    function nextExecutorOption(\\n        bytes calldata _options,\\n        uint _cursor\\n    ) internal pure returns (uint8 optionType, bytes calldata option, uint cursor) {\\n        unchecked {\\n            // skip worker id\\n            cursor = _cursor + 1;\\n\\n            // read option size\\n            uint16 size = _options.toU16(cursor);\\n            cursor += 2;\\n\\n            // read option type\\n            optionType = _options.toU8(cursor);\\n\\n            // startCursor and endCursor are used to slice the option from _options\\n            uint startCursor = cursor + 1; // skip option type and verifier_idx\\n            uint endCursor = cursor + size;\\n            option = _options[startCursor:endCursor];\\n            cursor += size;\\n        }\\n    }\\n\\n    function decodeLzReceiveOption(bytes calldata _option) internal pure returns (uint128 gas, uint128 value) {\\n        require(_option.length == 16 || _option.length == 32, Errors.INVALID_SIZE);\\n        gas = _option.toU128(0);\\n        value = _option.length == 32 ? _option.toU128(16) : 0;\\n    }\\n\\n    function decodeAirdropOption(bytes calldata _option) internal pure returns (uint128 amount, bytes32 receiver) {\\n        require(_option.length == 48, Errors.INVALID_SIZE);\\n        amount = _option.toU128(0);\\n        receiver = _option.toB32(16);\\n    }\\n\\n    function decodeLzComposeOption(bytes calldata _option) internal pure returns (uint128 gas, uint128 value) {\\n        require(_option.length == 16 || _option.length == 32, Errors.INVALID_SIZE);\\n        gas = _option.toU128(0);\\n        value = _option.length == 32 ? _option.toU128(16) : 0;\\n    }\\n\\n    function encodeLzReceiveOption(uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\\n        return _value == 0 ? abi.encodePacked(_gas) : abi.encodePacked(_gas, _value);\\n    }\\n\\n    function encodeAirdropOption(uint128 _amount, bytes32 _receiver) internal pure returns (bytes memory) {\\n        return abi.encodePacked(_amount, _receiver);\\n    }\\n\\n    function encodeLzComposeOption(uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\\n        return _value == 0 ? abi.encodePacked(_gas) : abi.encodePacked(_gas, _value);\\n    }\\n}\\n\",\"keccak256\":\"0x2d317c33c60f628c83625a2622a76891789b7388b06596564bd08ae6af11058a\",\"license\":\"BUSL-1.1\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xba43b97fba0d32eb4254f6a5a297b39a19a247082a02d6e69349e071e2946218\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x52a8cfb0f5239d11b457dcdd1b326992ef672714ca8da71a157255bddd13f3ad\",\"license\":\"MIT\"},\"contracts/OApp.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {Origin} from \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/MessagingStructs.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./interfaces/IOApp.sol\\\";\\nimport \\\"./interfaces/IPreCrime.sol\\\";\\n\\n/// @dev the template class for OApps. Refer to the OmniCounter for examples\\nabstract contract OApp is IOApp, Ownable {\\n    /// @dev we version the OApp to version the OApp Behaviours (e.g. future version might have different precrime interfaces)\\n    uint public constant override version = 1;\\n    ILayerZeroEndpointV2 public immutable endpoint;\\n    mapping(uint32 => bytes32) public peers;\\n\\n    // @dev These enforced options can vary as the potential options/execution on remote may differ\\n    // eg. Amount of lzReceive gas necessary to deliver a composed message adds overhear you dont want to pay\\n    // if you are only make a standard crosschain call (no deliver compose)\\n    // enforcedOptions[eid][executionType] = enforcedOptions\\n    // The \\\"msgType\\\" should be defined in the child contract\\n    mapping(uint32 eid => mapping(uint16 msgType => bytes)) internal enforcedOptions;\\n\\n    IPreCrime public precrime;\\n\\n    constructor(address _endpoint) {\\n        endpoint = ILayerZeroEndpointV2(_endpoint);\\n    }\\n\\n    function setEnforcedOptions(EnforcedOptionParam[] calldata _enforcedOptions) public virtual onlyOwner {\\n        for (uint i = 0; i < _enforcedOptions.length; i++) {\\n            enforcedOptions[_enforcedOptions[i].eid][_enforcedOptions[i].msgType] = _enforcedOptions[i].options;\\n        }\\n\\n        emit SetEnforcedOption(_enforcedOptions);\\n    }\\n\\n    /// @dev the generic send interface to interact with the LayerZero EndpointV2.quote()\\n    function _quote(\\n        uint32 _eid,\\n        bytes memory _message,\\n        bool _useLZToken,\\n        bytes memory _options\\n    ) internal view virtual returns (uint nativeFee, uint lzTokenFee) {\\n        MessagingFee memory fee = endpoint.quote(address(this), _eid, _message, _useLZToken, _options);\\n        return (fee.nativeFee, fee.lzTokenFee);\\n    }\\n\\n    /// @dev the generic send interface to interact with the LayerZero EndpointV2.send()\\n    function _lzSend(\\n        MessagingParams memory _msgParams,\\n        MessagingFee memory _fee,\\n        address payable _refundAddress\\n    ) internal virtual returns (MessagingReceipt memory) {\\n        MessagingReceipt memory receipt = endpoint.send{value: _fee.nativeFee}(\\n            _msgParams,\\n            _fee.lzTokenFee,\\n            _refundAddress\\n        );\\n        return receipt;\\n    }\\n\\n    /// @dev Oapp can override this interface for custom logics (e.g. more assertion)\\n    function lzReceive(\\n        Origin calldata _origin,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        address _executor,\\n        bytes calldata _extraData\\n    ) public payable virtual {\\n        // assert the call is from the endpoint\\n        if (address(endpoint) != msg.sender) revert EndpointOnly(msg.sender);\\n        // assert that it is from a trusted peer\\n        if (safeGetPeer(_origin.srcEid) != _origin.sender) revert InvalidPeer(_origin.sender);\\n        // assert that the nonce is acceptable\\n        _acceptNonce(_origin.srcEid, _origin.sender, _origin.nonce);\\n\\n        // perform the state transition logic\\n        _lzReceive(_origin, _guid, _message, _executor, _extraData);\\n    }\\n\\n    /// @dev needs to be implemented by the OApp\\n    /// @dev basic security checks are already performed\\n    function _lzReceive(\\n        Origin calldata _origin,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        address _executor,\\n        bytes calldata _extraData\\n    ) internal virtual;\\n\\n    /// @dev a generic interface for precrime simulations\\n    /// @dev this function reverts at the end with the simulation results\\n    /// @dev value is provided as a lump sum, does not restrict how much each packet can consume\\n    function lzReceiveAndRevert(IPreCrime.Packet[] calldata _packets) external payable virtual override {\\n        if (address(precrime) != msg.sender) revert PreCrimeOnly(msg.sender);\\n\\n        for (uint i = 0; i < _packets.length; i++) {\\n            IPreCrime.Packet calldata packet = _packets[i];\\n            bytes32 peer = safeGetPeer(packet.origin.srcEid);\\n            if (peer != packet.origin.sender) {\\n                // packet from untrusted peer cannot be lzReceived, hence cannot change state\\n                continue;\\n            }\\n            // don't need to accept nonce, as by precrime protocol, all packets are sorted\\n            _lzReceive(packet.origin, packet.guid, packet.message, msg.sender, packet.callParams);\\n        }\\n        revert IPreCrime.LzReceiveRevert(1, precrime.simulationCallback());\\n    }\\n\\n    /// @dev path nonce starts from 1. if 0 it means that there is no specific nonce enforcement\\n    /// @dev only used to guide the executor actions if the app specify the msg execution to be ordered.\\n    function nextNonce(uint32 /*_srcEid*/, bytes32 /*_sender*/) public view virtual returns (uint64) {\\n        return 0;\\n    }\\n\\n    /// @dev if the app wants to enforce ordered execution, it should override this function to return the correct value\\n    /// @dev check OmniCounter for example\\n    function _acceptNonce(uint32 /*_srcEid*/, bytes32 /*_sender*/, uint64 /*_nonce*/) internal virtual {\\n        // do nth by default\\n    }\\n\\n    /// @dev receive native tokens. this might be used for the endpoint to refund\\n    receive() external payable virtual {}\\n\\n    /// ----------------------------- OAPP Config Functions -----------------------------\\n\\n    /// @dev set _peer to bytes32(0) (the default value) to \\\"untrust\\\"\\n    function setPeer(uint32 _eid, bytes32 _peer) public virtual onlyOwner {\\n        if (peers[_eid] == _peer) revert InvalidPeerState();\\n        peers[_eid] = _peer;\\n        emit SetPeer(_eid, _peer);\\n    }\\n\\n    /// @dev check non-zero peer and return it\\n    function safeGetPeer(uint32 _eid) public view virtual returns (bytes32 peer) {\\n        peer = peers[_eid];\\n        if (peer == bytes32(0)) revert NoPeerSet(_eid);\\n    }\\n\\n    /// @dev set the precrime contract. can upgrade the precrime implementation overtime\\n    function setPrecrime(address _precrime) external onlyOwner {\\n        precrime = IPreCrime(_precrime);\\n        emit SetPrecrime(_precrime);\\n    }\\n\\n    /// @dev a generic interface to set the endpoint config\\n    /// @dev this is a low level interface, and should be used with caution\\n    /// @dev use our SDK to generate the properly abi.encoded config\\n    function callEndpoint(bytes calldata _callData) public virtual onlyOwner {\\n        bytes4 functionSig = bytes4(_callData);\\n        require(\\n            functionSig == IMessageLibManager.setConfig.selector ||\\n                functionSig == IMessageLibManager.snapshotConfig.selector ||\\n                functionSig == IMessageLibManager.resetConfig.selector ||\\n                functionSig == IMessageLibManager.setReceiveLibrary.selector ||\\n                functionSig == IMessageLibManager.setSendLibrary.selector ||\\n                functionSig == IMessageLibManager.setReceiveLibraryTimeout.selector ||\\n                functionSig == ILayerZeroEndpointV2.clear.selector ||\\n                functionSig == IMessagingChannel.skip.selector,\\n            \\\"OApp: function not allowed\\\"\\n        );\\n\\n        (bool success, bytes memory reason) = address(endpoint).call(_callData);\\n        if (!success) {\\n            assembly {\\n                revert(add(reason, 32), mload(reason))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0c7cca227fdc21ef8d8a2d9e159ae55274b1dca6e83011b8efb702d969265dca\",\"license\":\"MIT\"},\"contracts/examples/OmniCounter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../OApp.sol\\\";\\nimport \\\"../libs/OptionsBuilder.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroComposer.sol\\\";\\nimport {Origin} from \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/MessagingStructs.sol\\\";\\n\\nlibrary MsgCodec {\\n    uint8 internal constant VANILLA_TYPE = 1;\\n    uint8 internal constant COMPOSED_TYPE = 2;\\n    uint8 internal constant ABA_TYPE = 3;\\n    uint8 internal constant COMPOSED_ABA_TYPE = 4;\\n\\n    uint8 internal constant MSG_TYPE_OFFSET = 0;\\n    uint8 internal constant SRC_EID_OFFSET = 1;\\n\\n    function encode(uint8 _type, uint32 _srcEid) internal pure returns (bytes memory) {\\n        return abi.encodePacked(_type, _srcEid);\\n    }\\n\\n    function msgType(bytes calldata _message) internal pure returns (uint8) {\\n        return uint8(bytes1(_message[MSG_TYPE_OFFSET:SRC_EID_OFFSET]));\\n    }\\n\\n    function srcEid(bytes calldata _message) internal pure returns (uint32) {\\n        return uint32(bytes4(_message[SRC_EID_OFFSET:]));\\n    }\\n}\\n\\ncontract OmniCounter is ILayerZeroComposer, OApp {\\n    using MsgCodec for bytes;\\n    using OptionsBuilder for bytes;\\n\\n    uint public count;\\n    uint public composedCount;\\n\\n    address public admin;\\n    uint32 public eid;\\n\\n    mapping(uint32 srcEid => mapping(bytes32 sender => uint64 nonce)) private maxReceivedNonce;\\n    bool private orderedNonce;\\n\\n    // for global assertions\\n    mapping(uint32 srcEid => uint count) public inboundCount;\\n    mapping(uint32 dstEid => uint count) public outboundCount;\\n\\n    constructor(address _endpoint) OApp(_endpoint) {\\n        admin = msg.sender;\\n        eid = endpoint.eid();\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"only admin\\\");\\n        _;\\n    }\\n\\n    // -------------------------------\\n    // Only Admin\\n    function setAdmin(address _admin) external onlyAdmin {\\n        admin = _admin;\\n    }\\n\\n    function withdraw(address payable _to, uint _amount) external onlyAdmin {\\n        _to.transfer(_amount);\\n    }\\n\\n    // -------------------------------\\n    // Send\\n    function increment(uint32 _eid, uint8 _type, bytes calldata _options) external payable {\\n        _lzSend(\\n            MessagingParams(_eid, safeGetPeer(_eid), MsgCodec.encode(_type, eid), _options),\\n            MessagingFee(msg.value, 0),\\n            payable(msg.sender)\\n        );\\n        _incrementOutbound(_eid);\\n    }\\n\\n    // this is a broken function to skip incrementing outbound count\\n    // so that precrime will fail\\n    function brokenIncrement(uint32 _eid, uint8 _type, bytes calldata _options) external payable onlyAdmin {\\n        _lzSend(\\n            MessagingParams(_eid, safeGetPeer(_eid), MsgCodec.encode(_type, eid), _options),\\n            MessagingFee(msg.value, 0),\\n            payable(msg.sender)\\n        );\\n    }\\n\\n    function batchIncrement(\\n        uint32[] calldata _eids,\\n        uint8[] calldata _types,\\n        bytes[] calldata _options\\n    ) external payable {\\n        require(_eids.length == _options.length && _eids.length == _types.length, \\\"OmniCounter: length mismatch\\\");\\n\\n        MessagingReceipt memory receipt;\\n        uint providedFee = msg.value;\\n        for (uint i = 0; i < _eids.length; i++) {\\n            address refundAddress = i == _eids.length - 1 ? msg.sender : address(this);\\n            receipt = _lzSend(\\n                MessagingParams(_eids[i], safeGetPeer(_eids[i]), MsgCodec.encode(_types[i], eid), _options[i]),\\n                MessagingFee(providedFee, 0),\\n                payable(refundAddress)\\n            );\\n            _incrementOutbound(_eids[i]);\\n            providedFee -= receipt.fee.nativeFee;\\n        }\\n    }\\n\\n    // -------------------------------\\n    // View\\n    function quote(\\n        uint32 _eid,\\n        uint8 _type,\\n        bytes calldata _options\\n    ) public view returns (uint nativeFee, uint zroFee) {\\n        return _quote(_eid, MsgCodec.encode(_type, eid), false, _options);\\n    }\\n\\n    // -------------------------------\\n    // Receive\\n    function _lzReceive(\\n        Origin calldata _origin,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        address /*_executor*/,\\n        bytes calldata /*_extraData*/\\n    ) internal override {\\n        uint8 messageType = _message.msgType();\\n\\n        if (messageType == MsgCodec.VANILLA_TYPE) {\\n            count++;\\n            _incrementInbound(_origin.srcEid);\\n        } else if (messageType == MsgCodec.COMPOSED_TYPE || messageType == MsgCodec.COMPOSED_ABA_TYPE) {\\n            count++;\\n            _incrementInbound(_origin.srcEid);\\n            endpoint.deliverComposedMessage(address(this), _guid, _message);\\n        } else if (messageType == MsgCodec.ABA_TYPE) {\\n            count++;\\n            _incrementInbound(_origin.srcEid);\\n\\n            // send back to the sender\\n            _incrementOutbound(_origin.srcEid);\\n            bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200000, 0);\\n            _lzSend(\\n                MessagingParams(\\n                    _origin.srcEid,\\n                    safeGetPeer(_origin.srcEid),\\n                    MsgCodec.encode(MsgCodec.VANILLA_TYPE, eid),\\n                    options\\n                ),\\n                MessagingFee(msg.value, 0),\\n                payable(address(this))\\n            );\\n        } else {\\n            revert(\\\"invalid message type\\\");\\n        }\\n    }\\n\\n    function _incrementInbound(uint32 _srcEid) internal {\\n        inboundCount[_srcEid]++;\\n    }\\n\\n    function _incrementOutbound(uint32 _dstEid) internal {\\n        outboundCount[_dstEid]++;\\n    }\\n\\n    function lzCompose(\\n        address /*_oapp*/,\\n        bytes32 /*_guid*/,\\n        bytes calldata _message,\\n        address,\\n        bytes calldata\\n    ) external payable override {\\n        require(msg.sender == address(endpoint), \\\"!endpoint\\\");\\n\\n        uint8 msgType = _message.msgType();\\n        if (msgType == MsgCodec.COMPOSED_TYPE) {\\n            composedCount += 1;\\n        } else if (msgType == MsgCodec.COMPOSED_ABA_TYPE) {\\n            composedCount += 1;\\n\\n            uint32 srcEid = _message.srcEid();\\n            _incrementOutbound(srcEid);\\n            bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200000, 0);\\n            _lzSend(\\n                MessagingParams(srcEid, safeGetPeer(srcEid), MsgCodec.encode(MsgCodec.VANILLA_TYPE, eid), options),\\n                MessagingFee(msg.value, 0),\\n                payable(address(this))\\n            );\\n        } else {\\n            revert(\\\"invalid message type\\\");\\n        }\\n    }\\n\\n    // -------------------------------\\n    // Ordered OApp\\n    // this demonstrates how to build an app that requires execution nonce ordering\\n    // normally an app should decide ordered or not on contract construction\\n    // this is just a demo\\n    function setOrderedNonce(bool _orderedNonce) external onlyOwner {\\n        orderedNonce = _orderedNonce;\\n    }\\n\\n    function _acceptNonce(uint32 _srcEid, bytes32 _sender, uint64 _nonce) internal virtual override {\\n        uint64 currentNonce = maxReceivedNonce[_srcEid][_sender];\\n        if (orderedNonce) {\\n            require(_nonce == currentNonce + 1, \\\"OApp: invalid nonce\\\");\\n        }\\n        // update the max nonce anyway. once the ordered mode is turned on, missing early nonces will be rejected\\n        if (_nonce > currentNonce) {\\n            maxReceivedNonce[_srcEid][_sender] = _nonce;\\n        }\\n    }\\n\\n    function nextNonce(uint32 _srcEid, bytes32 _sender) public view virtual override returns (uint64) {\\n        if (orderedNonce) {\\n            return maxReceivedNonce[_srcEid][_sender] + 1;\\n        } else {\\n            return 0; // path nonce starts from 1. if 0 it means that there is no specific nonce enforcement\\n        }\\n    }\\n\\n    // a governance function to skip nonce\\n    function skipInboundNonce(uint32 _srcEid, bytes32 _sender, uint64 _nonce) public virtual onlyOwner {\\n        endpoint.skip(_srcEid, _sender, _nonce);\\n        if (orderedNonce) {\\n            maxReceivedNonce[_srcEid][_sender]++;\\n        }\\n    }\\n\\n    // be able to receive ether\\n    fallback() external payable {}\\n}\\n\",\"keccak256\":\"0xb1f0f546754248f670ec55473b2702b82142a80dfa829a1e3aafa7d319afb2ce\",\"license\":\"MIT\"},\"contracts/examples/OmniCounterViewer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./OmniCounter.sol\\\";\\nimport \\\"../interfaces/IPreCrime.sol\\\";\\n\\ncontract OmniCounterViewer {\\n    using MsgCodec for bytes;\\n\\n    struct Count {\\n        uint32 eid;\\n        uint inboundCount;\\n        uint outboundCount;\\n    }\\n\\n    OmniCounter public counter;\\n\\n    constructor(address payable _omniCounter) {\\n        counter = OmniCounter(_omniCounter);\\n    }\\n\\n    function getCounts(uint32[] calldata peerEids) public view returns (Count[] memory counts) {\\n        counts = new Count[](peerEids.length);\\n        for (uint i = 0; i < peerEids.length; i++) {\\n            uint32 eid = peerEids[i];\\n            counts[i] = Count(eid, counter.inboundCount(eid), counter.outboundCount(eid));\\n        }\\n    }\\n\\n    function lzReceive(IPreCrime.Packet calldata packet, Count[] memory counts) public view returns (Count[] memory) {\\n        bool isTrustedRemote = counter.peers(packet.origin.srcEid) == packet.origin.sender;\\n        require(isTrustedRemote, \\\"OmniCounterViewer: not trusted remote\\\");\\n\\n        // do receive logic\\n        uint index = _getCountStateIndex(counts, packet.origin.srcEid);\\n        uint8 messageType = packet.message.msgType();\\n\\n        if (messageType == MsgCodec.VANILLA_TYPE) {\\n            counts[index].inboundCount++;\\n        } else if (messageType == MsgCodec.COMPOSED_TYPE || messageType == MsgCodec.COMPOSED_ABA_TYPE) {\\n            counts[index].inboundCount++;\\n        } else if (messageType == MsgCodec.ABA_TYPE) {\\n            counts[index].inboundCount++;\\n            counts[index].outboundCount++;\\n        } else {\\n            revert(\\\"invalid message type\\\");\\n        }\\n        return counts;\\n    }\\n\\n    function _getCountStateIndex(Count[] memory counts, uint32 eid) internal pure returns (uint) {\\n        for (uint i = 0; i < counts.length; i++) {\\n            if (counts[i].eid == eid) {\\n                return i;\\n            }\\n        }\\n        revert(\\\"not found\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x1c3106ff04941565f60ba89ab50f9ef0895ed4f85d63920a4190f9552d9f6164\",\"license\":\"MIT\"},\"contracts/interfaces/IOApp.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol\\\";\\nimport \\\"./IPreCrime.sol\\\";\\n\\ninterface IOApp is ILayerZeroReceiver {\\n    struct EnforcedOptionParam {\\n        uint16 msgType;\\n        uint32 eid;\\n        bytes options;\\n    }\\n\\n    event SetEnforcedOption(EnforcedOptionParam[] _enforcedOptions);\\n\\n    function callEndpoint(bytes calldata _callData) external;\\n\\n    function nextNonce(uint32 _srcEid, bytes32 _sender) external view returns (uint64);\\n\\n    function version() external view returns (uint);\\n\\n    function lzReceiveAndRevert(IPreCrime.Packet[] calldata _packets) external payable;\\n\\n    error EndpointOnly(address addr);\\n    error PreCrimeOnly(address addr);\\n    error InvalidPeer(bytes32 addr);\\n    error InvalidPeerState();\\n    error NoPeerSet(uint32 eid);\\n\\n    event SetPeer(uint32 remoteEid, bytes32 peer);\\n    event SetPrecrime(address precrime);\\n}\\n\",\"keccak256\":\"0x715c1da9d496a4c2892c4cb93864658df74f24a6001e259cc02634ec1a5d93d4\",\"license\":\"MIT\"},\"contracts/interfaces/IPreCrime.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport {Origin} from \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/MessagingStructs.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol\\\";\\n\\ninterface IPreCrime {\\n    error LzReceiveRevert(uint16 code, bytes result);\\n\\n    struct Packet {\\n        Origin origin;\\n        bytes32 guid;\\n        bytes message;\\n        bytes callParams;\\n    }\\n\\n    function getPrecrimeConfig(Packet[] calldata _packets) external view returns (bytes memory);\\n\\n    function precrime(\\n        Packet[] calldata _packets,\\n        bytes[] calldata _simulation\\n    ) external view returns (uint16 code, bytes memory reason);\\n\\n    function precrimeVersion() external view returns (uint16);\\n\\n    function simulate(Packet[] calldata _packets) external payable returns (uint16 code, bytes memory result);\\n\\n    function simulateView(Packet[] calldata _packets) external view returns (uint16 code, bytes memory result);\\n\\n    function simulationCallback() external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x007ebfe122841988a7a33576e52675bab7ea61fd6b05fd2a504d8429aa0d87e4\",\"license\":\"MIT\"},\"contracts/libs/OptionsBuilder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/ExecutorOptions.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/libs/VerifierOptions.sol\\\";\\n\\nlibrary OptionsBuilder {\\n    using SafeCast for uint;\\n    using BytesLib for bytes;\\n\\n    uint16 internal constant TYPE_1 = 1; // legacy options type 1\\n    uint16 internal constant TYPE_2 = 2; // legacy options type 2\\n    uint16 internal constant TYPE_3 = 3;\\n\\n    modifier onlyType3(bytes memory _options) {\\n        require(_options.toUint16(0) == TYPE_3, \\\"OptionsBuilder: invalid options type\\\");\\n        _;\\n    }\\n\\n    function newOptions() internal pure returns (bytes memory) {\\n        return abi.encodePacked(TYPE_3);\\n    }\\n\\n    function addExecutorLzReceiveOption(\\n        bytes memory _options,\\n        uint128 _gas,\\n        uint128 _value\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        bytes memory option = ExecutorOptions.encodeLzReceiveOption(_gas, _value);\\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZRECEIVE, option);\\n    }\\n\\n    function addExecutorAirdropOption(\\n        bytes memory _options,\\n        uint128 _amount,\\n        bytes32 _receiver\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        bytes memory option = ExecutorOptions.encodeAirdropOption(_amount, _receiver);\\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_AIRDROP, option);\\n    }\\n\\n    function addExecutorLzComposeOption(\\n        bytes memory _options,\\n        uint128 _gas,\\n        uint128 _value\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        bytes memory option = ExecutorOptions.encodeLzComposeOption(_gas, _value);\\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZCOMPOSE, option);\\n    }\\n\\n    function addExecutorOrderedExecutionOption(\\n        bytes memory _options\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_ORDERED_EXECUTION, bytes(\\\"\\\"));\\n    }\\n\\n    function addVerifierPrecrimeOption(\\n        bytes memory _options,\\n        uint8 _verifierIdx\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        return addVerifierOption(_options, _verifierIdx, VerifierOptions.OPTION_TYPE_PRECRIME, bytes(\\\"\\\"));\\n    }\\n\\n    function addExecutorOption(\\n        bytes memory _options,\\n        uint8 _optionType,\\n        bytes memory _option\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                _options,\\n                ExecutorOptions.WORKER_ID,\\n                _option.length.toUint16() + 1, // +1 for optionType\\n                _optionType,\\n                _option\\n            );\\n    }\\n\\n    function addVerifierOption(\\n        bytes memory _options,\\n        uint8 _verifierIdx,\\n        uint8 _optionType,\\n        bytes memory _option\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                _options,\\n                VerifierOptions.WORKER_ID,\\n                _option.length.toUint16() + 2, // +2 for optionType and verifierIdx\\n                _verifierIdx,\\n                _optionType,\\n                _option\\n            );\\n    }\\n\\n    function encodeLegacyOptionsType1(uint _executionGas) internal pure returns (bytes memory) {\\n        require(_executionGas <= type(uint128).max, Errors.INVALID_SIZE);\\n        return abi.encodePacked(TYPE_1, _executionGas);\\n    }\\n\\n    function encodeLegacyOptionsType2(\\n        uint _executionGas,\\n        uint _amount,\\n        bytes memory _receiver // use bytes instead of bytes32 in legacy type 2\\n    ) internal pure returns (bytes memory) {\\n        require(\\n            _executionGas <= type(uint128).max && _amount <= type(uint128).max && _receiver.length <= 32,\\n            Errors.INVALID_SIZE\\n        );\\n        return abi.encodePacked(TYPE_2, _executionGas, _amount, _receiver);\\n    }\\n}\\n\",\"keccak256\":\"0xb0b9666bd73151ace3988bf55c2c20317e7b8eca7182b174e0c7a7e48005174a\",\"license\":\"MIT\"},\"solidity-bytes-utils/contracts/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\\u00e7alo S\\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity >=0.8.0 <0.9.0;\\n\\n\\nlibrary BytesLib {\\n    function concat(\\n        bytes memory _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(0x40, and(\\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n              not(31) // Round down to the nearest 32 bytes.\\n            ))\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes.slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes.slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                                ),\\n                                // and now shift left the number of bytes to\\n                                // leave space for the length in the slot\\n                                exp(0x100, sub(32, newlength))\\n                            ),\\n                            // increase length by the double of the memory\\n                            // bytes length\\n                            mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(\\n                    sc,\\n                    add(\\n                        and(\\n                            fslot,\\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\\n                        ),\\n                        and(mload(mc), mask)\\n                    )\\n                )\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let mlengthmod := mod(mlength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n                for {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_bytes.length >= _start + 1 , \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\n        require(_bytes.length >= _start + 2, \\\"toUint16_outOfBounds\\\");\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\\n        require(_bytes.length >= _start + 4, \\\"toUint32_outOfBounds\\\");\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\\n        require(_bytes.length >= _start + 8, \\\"toUint64_outOfBounds\\\");\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\\n        require(_bytes.length >= _start + 12, \\\"toUint96_outOfBounds\\\");\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\\n        require(_bytes.length >= _start + 16, \\\"toUint128_outOfBounds\\\");\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n        require(_bytes.length >= _start + 32, \\\"toUint256_outOfBounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n        require(_bytes.length >= _start + 32, \\\"toBytes32_outOfBounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                // the next line is the loop condition:\\n                // while(uint256(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(\\n        bytes storage _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes.slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes.slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint256(mc < end) + cb == 2)\\n                        for {} eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n}\\n\",\"keccak256\":\"0xf75784dfc94ea43668eb195d5690a1dde1b6eda62017e73a3899721583821d29\",\"license\":\"Unlicense\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50604051610bdb380380610bdb83398101604081905261002f91610054565b600080546001600160a01b0319166001600160a01b0392909216919091179055610084565b60006020828403121561006657600080fd5b81516001600160a01b038116811461007d57600080fd5b9392505050565b610b48806100936000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c806330b317911461004657806361bc221a1461006f5780636874141b146100b4575b600080fd5b610059610054366004610790565b6100c7565b6040516100669190610897565b60405180910390f35b60005461008f9073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610066565b6100596100c23660046108f6565b6103bf565b60008054606091906020850180359173ffffffffffffffffffffffffffffffffffffffff169063bb0b6a53906100fd908861096b565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815263ffffffff919091166004820152602401602060405180830381865afa158015610157573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061017b919061098d565b14905080610210576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f4f6d6e69436f756e7465725669657765723a206e6f742074727573746564207260448201527f656d6f746500000000000000000000000000000000000000000000000000000060648201526084015b60405180910390fd5b600061022884610223602088018861096b565b6105f5565b9050600061024161023c60808801886109a6565b6106ae565b90507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60ff8216016102a05784828151811061027f5761027f610a12565b6020026020010151602001805180919061029890610a41565b9052506103b2565b60ff8116600214806102b5575060ff81166004145b156102cc5784828151811061027f5761027f610a12565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd60ff8216016103505784828151811061030857610308610a12565b6020026020010151602001805180919061032190610a41565b8152505084828151811061033757610337610a12565b6020026020010151604001805180919061029890610a41565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f696e76616c6964206d65737361676520747970650000000000000000000000006044820152606401610207565b8493505050505b92915050565b60608167ffffffffffffffff8111156103da576103da6106d0565b60405190808252806020026020018201604052801561043557816020015b6104226040518060600160405280600063ffffffff16815260200160008152602001600081525090565b8152602001906001900390816103f85790505b50905060005b828110156105ee57600084848381811061045757610457610a12565b905060200201602081019061046c919061096b565b6040805160608101825263ffffffff831680825260005492517f56a47289000000000000000000000000000000000000000000000000000000008152600481019190915292935091602083019173ffffffffffffffffffffffffffffffffffffffff16906356a4728990602401602060405180830381865afa1580156104f6573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061051a919061098d565b81526000546040517f622f17f600000000000000000000000000000000000000000000000000000000815263ffffffff8516600482015260209092019173ffffffffffffffffffffffffffffffffffffffff9091169063622f17f690602401602060405180830381865afa158015610596573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ba919061098d565b8152508383815181106105cf576105cf610a12565b60200260200101819052505080806105e690610a41565b91505061043b565b5092915050565b6000805b835181101561064b578263ffffffff1684828151811061061b5761061b610a12565b60200260200101516000015163ffffffff16036106395790506103b9565b8061064381610a41565b9150506105f9565b506040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f6e6f7420666f756e6400000000000000000000000000000000000000000000006044820152606401610207565b60006106bd6001828486610aa0565b6106c691610aca565b60f81c9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040516060810167ffffffffffffffff81118282101715610722576107226106d0565b60405290565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff8111828210171561076f5761076f6106d0565b604052919050565b803563ffffffff8116811461078b57600080fd5b919050565b60008060408084860312156107a457600080fd5b833567ffffffffffffffff808211156107bc57600080fd5b9085019060c082880312156107d057600080fd5b90935060209085820135818111156107e757600080fd5b8601601f810188136107f857600080fd5b80358281111561080a5761080a6106d0565b610818848260051b01610728565b8181528481019350606091820283018501918a83111561083757600080fd5b928501925b828410156108865780848c0312156108545760008081fd5b61085c6106ff565b61086585610777565b8152848701358782015287850135888201528552938501939283019261083c565b508096505050505050509250929050565b602080825282518282018190526000919060409081850190868401855b828110156108e9578151805163ffffffff168552868101518786015285015185850152606090930192908501906001016108b4565b5091979650505050505050565b6000806020838503121561090957600080fd5b823567ffffffffffffffff8082111561092157600080fd5b818501915085601f83011261093557600080fd5b81358181111561094457600080fd5b8660208260051b850101111561095957600080fd5b60209290920196919550909350505050565b60006020828403121561097d57600080fd5b61098682610777565b9392505050565b60006020828403121561099f57600080fd5b5051919050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18436030181126109db57600080fd5b83018035915067ffffffffffffffff8211156109f657600080fd5b602001915036819003821315610a0b57600080fd5b9250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203610a99577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b5060010190565b60008085851115610ab057600080fd5b83861115610abd57600080fd5b5050820193919092039150565b7fff000000000000000000000000000000000000000000000000000000000000008135818116916001851015610b0a5780818660010360031b1b83161692505b50509291505056fea2646970667358221220adc586eef470a1a1ed27842bdbbcaaee1c0f85a1b5306e11c8f1348602b4c31e64736f6c63430008130033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100415760003560e01c806330b317911461004657806361bc221a1461006f5780636874141b146100b4575b600080fd5b610059610054366004610790565b6100c7565b6040516100669190610897565b60405180910390f35b60005461008f9073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610066565b6100596100c23660046108f6565b6103bf565b60008054606091906020850180359173ffffffffffffffffffffffffffffffffffffffff169063bb0b6a53906100fd908861096b565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815263ffffffff919091166004820152602401602060405180830381865afa158015610157573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061017b919061098d565b14905080610210576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f4f6d6e69436f756e7465725669657765723a206e6f742074727573746564207260448201527f656d6f746500000000000000000000000000000000000000000000000000000060648201526084015b60405180910390fd5b600061022884610223602088018861096b565b6105f5565b9050600061024161023c60808801886109a6565b6106ae565b90507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60ff8216016102a05784828151811061027f5761027f610a12565b6020026020010151602001805180919061029890610a41565b9052506103b2565b60ff8116600214806102b5575060ff81166004145b156102cc5784828151811061027f5761027f610a12565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd60ff8216016103505784828151811061030857610308610a12565b6020026020010151602001805180919061032190610a41565b8152505084828151811061033757610337610a12565b6020026020010151604001805180919061029890610a41565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f696e76616c6964206d65737361676520747970650000000000000000000000006044820152606401610207565b8493505050505b92915050565b60608167ffffffffffffffff8111156103da576103da6106d0565b60405190808252806020026020018201604052801561043557816020015b6104226040518060600160405280600063ffffffff16815260200160008152602001600081525090565b8152602001906001900390816103f85790505b50905060005b828110156105ee57600084848381811061045757610457610a12565b905060200201602081019061046c919061096b565b6040805160608101825263ffffffff831680825260005492517f56a47289000000000000000000000000000000000000000000000000000000008152600481019190915292935091602083019173ffffffffffffffffffffffffffffffffffffffff16906356a4728990602401602060405180830381865afa1580156104f6573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061051a919061098d565b81526000546040517f622f17f600000000000000000000000000000000000000000000000000000000815263ffffffff8516600482015260209092019173ffffffffffffffffffffffffffffffffffffffff9091169063622f17f690602401602060405180830381865afa158015610596573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ba919061098d565b8152508383815181106105cf576105cf610a12565b60200260200101819052505080806105e690610a41565b91505061043b565b5092915050565b6000805b835181101561064b578263ffffffff1684828151811061061b5761061b610a12565b60200260200101516000015163ffffffff16036106395790506103b9565b8061064381610a41565b9150506105f9565b506040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f6e6f7420666f756e6400000000000000000000000000000000000000000000006044820152606401610207565b60006106bd6001828486610aa0565b6106c691610aca565b60f81c9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040516060810167ffffffffffffffff81118282101715610722576107226106d0565b60405290565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff8111828210171561076f5761076f6106d0565b604052919050565b803563ffffffff8116811461078b57600080fd5b919050565b60008060408084860312156107a457600080fd5b833567ffffffffffffffff808211156107bc57600080fd5b9085019060c082880312156107d057600080fd5b90935060209085820135818111156107e757600080fd5b8601601f810188136107f857600080fd5b80358281111561080a5761080a6106d0565b610818848260051b01610728565b8181528481019350606091820283018501918a83111561083757600080fd5b928501925b828410156108865780848c0312156108545760008081fd5b61085c6106ff565b61086585610777565b8152848701358782015287850135888201528552938501939283019261083c565b508096505050505050509250929050565b602080825282518282018190526000919060409081850190868401855b828110156108e9578151805163ffffffff168552868101518786015285015185850152606090930192908501906001016108b4565b5091979650505050505050565b6000806020838503121561090957600080fd5b823567ffffffffffffffff8082111561092157600080fd5b818501915085601f83011261093557600080fd5b81358181111561094457600080fd5b8660208260051b850101111561095957600080fd5b60209290920196919550909350505050565b60006020828403121561097d57600080fd5b61098682610777565b9392505050565b60006020828403121561099f57600080fd5b5051919050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18436030181126109db57600080fd5b83018035915067ffffffffffffffff8211156109f657600080fd5b602001915036819003821315610a0b57600080fd5b9250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203610a99577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b5060010190565b60008085851115610ab057600080fd5b83861115610abd57600080fd5b5050820193919092039150565b7fff000000000000000000000000000000000000000000000000000000000000008135818116916001851015610b0a5780818660010360031b1b83161692505b50509291505056fea2646970667358221220adc586eef470a1a1ed27842bdbbcaaee1c0f85a1b5306e11c8f1348602b4c31e64736f6c63430008130033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 9233,
        "contract": "contracts/examples/OmniCounterViewer.sol:OmniCounterViewer",
        "label": "counter",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(OmniCounter)8315"
      }
    ],
    "types": {
      "t_contract(OmniCounter)8315": {
        "encoding": "inplace",
        "label": "contract OmniCounter",
        "numberOfBytes": "20"
      }
    }
  }
}