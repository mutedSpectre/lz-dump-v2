{
  "address": "0x94B75AA39bEC4cB15e7B9593C315aF203B7B847f",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract ILayerZeroPriceFeed",
          "name": "_priceFeed",
          "type": "address"
        },
        {
          "internalType": "uint32",
          "name": "_dstEid",
          "type": "uint32"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_calldataSize",
          "type": "uint256"
        },
        {
          "internalType": "uint16",
          "name": "_defaultMultiplierBps",
          "type": "uint16"
        },
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "baseGas",
              "type": "uint64"
            },
            {
              "internalType": "uint16",
              "name": "multiplierBps",
              "type": "uint16"
            },
            {
              "internalType": "uint128",
              "name": "floorMarginUSD",
              "type": "uint128"
            },
            {
              "internalType": "uint128",
              "name": "airdropCap",
              "type": "uint128"
            }
          ],
          "internalType": "struct IRelayer.DstConfig",
          "name": "_dstConfig",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "_options",
          "type": "bytes"
        }
      ],
      "name": "getFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "fee",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x81940bde2959b6f89ff3c86388506a4fc2f2066ba111f30e61edd41c4ba6ad3a",
  "receipt": {
    "to": null,
    "from": "0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC",
    "contractAddress": "0x94B75AA39bEC4cB15e7B9593C315aF203B7B847f",
    "transactionIndex": 0,
    "gasUsed": "947200",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xac78bdad2a5ea59cbc0b6c6f20d270a97137d1712de9859e6d4be4efee1cfbdf",
    "transactionHash": "0x81940bde2959b6f89ff3c86388506a4fc2f2066ba111f30e61edd41c4ba6ad3a",
    "logs": [],
    "blockNumber": 114,
    "cumulativeGasUsed": "947200",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "f4e8736b759ec283a614e6b3dfdfade8",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract ILayerZeroPriceFeed\",\"name\":\"_priceFeed\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_dstEid\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_calldataSize\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_defaultMultiplierBps\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"baseGas\",\"type\":\"uint64\"},{\"internalType\":\"uint16\",\"name\":\"multiplierBps\",\"type\":\"uint16\"},{\"internalType\":\"uint128\",\"name\":\"floorMarginUSD\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"airdropCap\",\"type\":\"uint128\"}],\"internalType\":\"struct IRelayer.DstConfig\",\"name\":\"_dstConfig\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"_options\",\"type\":\"bytes\"}],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/RelayerFeeLib.sol\":\"RelayerFeeLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":2000},\"remappings\":[]},\"sources\":{\"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/Options.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"solidity-bytes-utils/contracts/BytesLib.sol\\\";\\n\\nlibrary Options {\\n    using BytesLib for bytes;\\n\\n    struct WorkerOptions {\\n        uint16 workerId;\\n        bytes options;\\n    }\\n\\n    struct Option {\\n        uint16 optionType;\\n        bytes params;\\n    }\\n\\n    uint16 public constant RELAYER_WORKER_ID = 1; // matches RelayerOptions WORKER_ID\\n\\n    uint16 public constant TYPE_1 = 1; // simple option type 1\\n    uint16 public constant TYPE_2 = 2; // simple option type 2\\n    uint16 public constant TYPE_3 = 3; // cannot overlap with simple option types\\n\\n    /// ======================= Decoding Functions =======================\\n    function decodeOptions(bytes memory _options) internal pure returns (WorkerOptions[] memory) {\\n        uint16 formatType = _options.toUint16(0);\\n        if (formatType == TYPE_1 || formatType == TYPE_2) {\\n            WorkerOptions[] memory options = _convert(formatType, _options);\\n            return options;\\n        }\\n\\n        // new format type 3\\n        // [type3][numWorkers][workerOps][workerOps]...\\n        // [workerOps] -> [workerId][size][options]\\n        if (formatType == 3) {\\n            uint16 numWorkers = _options.toUint16(2);\\n            WorkerOptions[] memory options = new WorkerOptions[](numWorkers);\\n\\n            // parse options for each worker\\n            uint cursor = 4;\\n            uint16 lastWorkerId;\\n            for (uint i = 0; i < uint(numWorkers); i++) {\\n                // must be ascending order\\n                uint16 workerId = _options.toUint16(cursor);\\n                cursor += 2;\\n\\n                // no duplicated worker id, and the first worker id can be 0 because of enum type\\n                require(i == 0 || workerId > lastWorkerId, \\\"LZ10006\\\");\\n                lastWorkerId = workerId;\\n\\n                // option size\\n                uint16 size = _options.toUint16(cursor);\\n                cursor += 2;\\n\\n                options[i] = WorkerOptions(workerId, _options.slice(cursor, size));\\n                cursor += size;\\n            }\\n            require(cursor == _options.length, \\\"LZ10009\\\");\\n            return options;\\n        }\\n\\n        revert(\\\"LZC0000\\\");\\n    }\\n\\n    /// @dev decode worker options\\n    function decodeWorkerOptions(bytes memory _options) internal pure returns (Option[] memory) {\\n        uint cursor = 0;\\n        uint16 numOptions = _options.toUint16(cursor);\\n        cursor += 2;\\n\\n        Option[] memory options = new Option[](numOptions);\\n        uint16 lastOptionType;\\n        for (uint16 i = 0; i < numOptions; i++) {\\n            uint16 optionType = _options.toUint16(cursor);\\n            cursor += 2;\\n            // no duplicated option type\\n            require(optionType > lastOptionType, \\\"LZ10006\\\");\\n            lastOptionType = optionType;\\n\\n            uint16 paramSize = _options.toUint16(cursor);\\n            cursor += 2;\\n\\n            bytes memory param = _options.slice(cursor, paramSize);\\n            cursor += paramSize;\\n            options[i] = Option(optionType, param);\\n        }\\n        return options;\\n    }\\n\\n    // relayer only\\n    // legacy type 1\\n    // bytes  [32      ]\\n    // fields [extraGas]\\n    // legacy type 2\\n    // bytes  [32        32            bytes[]         ]\\n    // fields [extraGas  dstNativeAmt  dstNativeAddress]\\n    function _convert(\\n        uint _optionType,\\n        bytes memory _options\\n    ) private pure returns (WorkerOptions[] memory workerOptions) {\\n        workerOptions = new WorkerOptions[](1);\\n        bytes memory options;\\n\\n        if (_optionType == TYPE_1) {\\n            require(_options.length == 34, \\\"LZ10009\\\");\\n\\n            // execution gas\\n            uint executionGas = _options.toUint256(2);\\n            require(executionGas <= type(uint128).max, \\\"LZ10009\\\");\\n\\n            options = abi.encodePacked(uint16(1)); // option num\\n            options = abi.encodePacked(options, TYPE_1, uint16(16), uint128(executionGas));\\n        } else if (_optionType == TYPE_2) {\\n            require(_options.length > 66 && _options.length <= 98, \\\"LZ10009\\\");\\n\\n            // execution gas\\n            uint executionGas = _options.toUint256(2);\\n            require(executionGas <= type(uint128).max, \\\"LZ10009\\\");\\n\\n            // airdrop (amount + receiver)\\n            uint amount = _options.toUint256(34);\\n            require(amount <= type(uint128).max, \\\"LZ10009\\\");\\n\\n            uint receiverLen = _options.length - 66;\\n            bytes32 receiver = bytes32(_options.slice(66, receiverLen));\\n            receiver = receiver >> (8 * (32 - receiverLen)); // padding 0 to the left\\n            bytes memory airdrop = abi.encodePacked(uint128(amount), receiver);\\n\\n            options = abi.encodePacked(uint16(2)); // option num\\n            options = abi.encodePacked(options, TYPE_1, uint16(16), uint128(executionGas));\\n            options = abi.encodePacked(options, TYPE_2, uint16(airdrop.length), airdrop);\\n        } else {\\n            revert(\\\"LZC0000\\\");\\n        }\\n\\n        workerOptions[0] = WorkerOptions(RELAYER_WORKER_ID, options);\\n    }\\n\\n    /// ======================= Encoding Functions =======================\\n\\n    function encodeWorkerOptions(Option memory _option) internal pure returns (bytes memory) {\\n        Option[] memory options = new Option[](1);\\n        options[0] = _option;\\n        return encodeWorkerOptions(options);\\n    }\\n\\n    function encodeWorkerOptions(Option[] memory _options) internal pure returns (bytes memory) {\\n        require(_options.length > 0, \\\"LZ10009\\\");\\n        uint16 numOptions = _safeToUint16(_options.length);\\n        bytes memory options = abi.encodePacked(numOptions);\\n\\n        uint16 lastOptionType;\\n        for (uint i = 0; i < numOptions; i++) {\\n            // no duplicated option type\\n            uint16 optionType = _options[i].optionType;\\n            require(i == 0 || optionType > lastOptionType, \\\"LZ10006\\\");\\n            lastOptionType = optionType;\\n\\n            uint16 paramSize = _safeToUint16(_options[i].params.length);\\n            bytes memory option = abi.encodePacked(_options[i].optionType, paramSize, _options[i].params);\\n\\n            options = options.concat(option);\\n        }\\n\\n        return options;\\n    }\\n\\n    function encodeOptions(WorkerOptions[] memory _workerOptions) internal pure returns (bytes memory) {\\n        uint16 numWorkers = _safeToUint16(_workerOptions.length);\\n        bytes memory options = abi.encodePacked(TYPE_3, numWorkers);\\n\\n        uint16 lastWorkerId;\\n        for (uint i = 0; i < numWorkers; i++) {\\n            uint16 workerId = uint16(_workerOptions[i].workerId);\\n            // prevent duplicated worker id\\n            require(i == 0 || workerId > lastWorkerId, \\\"LZ10006\\\");\\n\\n            uint16 optionSize = _safeToUint16(_workerOptions[i].options.length);\\n            options = abi.encodePacked(options, workerId, optionSize, _workerOptions[i].options);\\n\\n            lastWorkerId = workerId;\\n        }\\n\\n        return options;\\n    }\\n\\n    function encodeSimpleOptionsType1(uint256 _executionGas) internal pure returns (bytes memory) {\\n        require(_executionGas <= type(uint128).max, \\\"LZ10009\\\");\\n        return abi.encodePacked(TYPE_1, _executionGas);\\n    }\\n\\n    function encodeSimpleOptionsType2(\\n        uint256 _executionGas,\\n        uint256 _amount,\\n        bytes32 _receiver\\n    ) internal pure returns (bytes memory) {\\n        require(_executionGas <= type(uint128).max && _amount <= type(uint128).max, \\\"LZ10009\\\");\\n        return abi.encodePacked(TYPE_2, _executionGas, _amount, _receiver);\\n    }\\n\\n    /// ======================= Getter Functions =======================\\n\\n    function getWorkerOptionsByWorkerId(\\n        WorkerOptions[] memory _workerOptions,\\n        uint16 _workerId\\n    ) internal pure returns (bool, uint, bytes memory) {\\n        for (uint i = 0; i < _workerOptions.length; i++) {\\n            if (_workerOptions[i].workerId == _workerId) {\\n                return (true, i, _workerOptions[i].options);\\n            }\\n        }\\n        return (false, 0, bytes(\\\"\\\"));\\n    }\\n\\n    function getOptionByOptionType(\\n        Option[] memory _options,\\n        uint16 _optionType\\n    ) internal pure returns (bool, uint, bytes memory) {\\n        for (uint i = 0; i < _options.length; i++) {\\n            if (_options[i].optionType == _optionType) {\\n                return (true, i, _options[i].params);\\n            }\\n        }\\n        return (false, 0, bytes(\\\"\\\"));\\n    }\\n\\n    function getOptionByWorkerIdAndOptionType(\\n        WorkerOptions[] memory _workerOptions,\\n        uint16 _workerId,\\n        uint16 _optionType\\n    ) internal pure returns (bool, bytes memory) {\\n        (bool found, , bytes memory options) = getWorkerOptionsByWorkerId(_workerOptions, _workerId);\\n        if (!found) {\\n            return (false, bytes(\\\"\\\"));\\n        }\\n\\n        (found, , options) = getOptionByOptionType(decodeWorkerOptions(options), _optionType);\\n        return (found, options);\\n    }\\n\\n    function _safeToUint16(uint _value) private pure returns (uint16) {\\n        require(_value <= type(uint16).max, \\\"LZ10009\\\");\\n        return uint16(_value);\\n    }\\n}\\n\",\"keccak256\":\"0xbe0e01a6cee250828a058200a572f65f2189b9448af8c8e8553186cd0e11afe3\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/RelayerOptions.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"solidity-bytes-utils/contracts/BytesLib.sol\\\";\\nimport \\\"./Options.sol\\\";\\n\\nlibrary RelayerOptions {\\n    using BytesLib for bytes;\\n\\n    uint16 public constant WORKER_ID = 1;\\n\\n    uint16 public constant OPTION_TYPE_LZRECEIVE = 1;\\n    uint16 public constant OPTION_TYPE_AIRDROP = 2;\\n    uint16 public constant OPTION_TYPE_LZCOMPOSE = 3;\\n    uint16 public constant OPTION_TYPE_ORDERED_EXECUTION = 4;\\n\\n    function decodeLzReceiveParams(bytes memory _params) internal pure returns (uint gas, uint value) {\\n        require(_params.length == 16 || _params.length == 32, \\\"LZ10009\\\");\\n        gas = _params.toUint128(0);\\n        value = _params.length == 32 ? _params.toUint128(16) : 0;\\n    }\\n\\n    function decodeAirdropParams(bytes memory _params) internal pure returns (uint amount, bytes32 receiver) {\\n        require(_params.length == 48, \\\"LZ10009\\\");\\n        amount = _params.toUint128(0);\\n        receiver = _params.toBytes32(16);\\n    }\\n\\n    function decodeLzComposeParams(bytes memory _params) internal pure returns (uint gas, uint value) {\\n        require(_params.length == 32, \\\"LZ10009\\\");\\n        gas = _params.toUint128(0);\\n        value = _params.toUint128(16);\\n    }\\n\\n    function encodeLzReceiveOption(uint128 _gas, uint128 _value) internal pure returns (Options.Option memory) {\\n        bytes memory params = _value == 0 ? abi.encodePacked(_gas) : abi.encodePacked(_gas, _value);\\n        return Options.Option(OPTION_TYPE_LZRECEIVE, params);\\n    }\\n\\n    function encodeAirdropOption(uint128 _amount, bytes32 _receiver) internal pure returns (Options.Option memory) {\\n        return Options.Option(OPTION_TYPE_AIRDROP, abi.encodePacked(_amount, _receiver));\\n    }\\n\\n    function encodeLzComposeOption(uint128 _gas, uint128 _value) internal pure returns (Options.Option memory) {\\n        return Options.Option(OPTION_TYPE_LZCOMPOSE, abi.encodePacked(_gas, _value));\\n    }\\n\\n    function encodeOrderedExecutionOption() internal pure returns (Options.Option memory) {\\n        return Options.Option(OPTION_TYPE_ORDERED_EXECUTION, \\\"\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x14d10fc9f507b3cc7fd32c29e2e13b2aee6c01f334a580797a2ef18383a48eb6\",\"license\":\"BUSL-1.1\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/RelayerFeeLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/Options.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/RelayerOptions.sol\\\";\\n\\nimport \\\"./interfaces/ILayerZeroPriceFeed.sol\\\";\\nimport \\\"./interfaces/IRelayerFeeLib.sol\\\";\\n\\ncontract RelayerFeeLib is IRelayerFeeLib, ERC165 {\\n    uint constant NATIVE_DECIMALS_RATE = 1e18;\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IRelayerFeeLib).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    function getFee(\\n        ILayerZeroPriceFeed _priceFeed,\\n        uint32 _dstEid,\\n        address,\\n        uint _calldataSize,\\n        uint16 _defaultMultiplierBps,\\n        IRelayer.DstConfig memory _dstConfig,\\n        bytes calldata _options\\n    ) external view returns (uint fee) {\\n        require(_options.length > 0, \\\"RelayerFeeLib: no options provided\\\");\\n\\n        // stack too deep\\n        IRelayer.DstConfig memory dstConfig = _dstConfig;\\n        uint32 dstEid = _dstEid;\\n        ILayerZeroPriceFeed priceFeed = _priceFeed;\\n        uint calldataSize = _calldataSize;\\n        uint16 defaultMultiplierBps = _defaultMultiplierBps;\\n\\n        (uint totalDstAmount, uint totalGas) = _decodeRelayerOptions(dstConfig.baseGas, dstConfig.airdropCap, _options);\\n\\n        (uint totalGasFee, uint128 priceRatio, uint128 priceRatioDenominator, uint128 nativePriceUSD) = priceFeed\\n            .estimateFeeByChain(dstEid, calldataSize, totalGas);\\n\\n        fee = _getTxFee(\\n            totalGasFee,\\n            dstConfig.multiplierBps == 0 ? defaultMultiplierBps : dstConfig.multiplierBps,\\n            dstConfig.floorMarginUSD,\\n            nativePriceUSD\\n        );\\n\\n        if (totalDstAmount > 0) {\\n            fee = fee + (((totalDstAmount * priceRatio) / priceRatioDenominator) * defaultMultiplierBps) / 10000;\\n        }\\n    }\\n\\n    function _decodeRelayerOptions(\\n        uint64 _baseGas,\\n        uint128 _airdropCap,\\n        bytes calldata _options\\n    ) private pure returns (uint dstAmount, uint totalGas) {\\n        Options.Option[] memory options = Options.decodeWorkerOptions(_options);\\n\\n        bool ordered = false;\\n        totalGas = _baseGas;\\n        for (uint i = 0; i < options.length; i++) {\\n            if (options[i].optionType == RelayerOptions.OPTION_TYPE_AIRDROP) {\\n                (uint airdropAmount, ) = RelayerOptions.decodeAirdropParams(options[i].params);\\n                require(airdropAmount <= _airdropCap, \\\"RelayerFeeLib: airdrop amount exceeds cap\\\");\\n                dstAmount += airdropAmount;\\n            } else if (options[i].optionType == RelayerOptions.OPTION_TYPE_LZRECEIVE) {\\n                (uint gas, uint value) = RelayerOptions.decodeLzReceiveParams(options[i].params);\\n                dstAmount += value;\\n                totalGas += gas;\\n            } else if (options[i].optionType == RelayerOptions.OPTION_TYPE_LZCOMPOSE) {\\n                (uint gas, uint value) = RelayerOptions.decodeLzComposeParams(options[i].params);\\n                dstAmount += value;\\n                totalGas += gas;\\n            } else if (options[i].optionType == RelayerOptions.OPTION_TYPE_ORDERED_EXECUTION) {\\n                ordered = true;\\n            } else {\\n                revert(\\\"RelayerFeeLib: invalid option type\\\");\\n            }\\n        }\\n        if (ordered) {\\n            // todo: finalize the premium for ordered\\n            totalGas = (totalGas * 102) / 100;\\n        }\\n    }\\n\\n    function _getTxFee(\\n        uint _fee,\\n        uint16 _multiplierBps,\\n        uint128 _floorMarginUSD,\\n        uint128 _nativePriceUSD\\n    ) private pure returns (uint) {\\n        uint feeWithMultiplier = (_fee * _multiplierBps) / 10000;\\n\\n        if (_nativePriceUSD == 0 || _floorMarginUSD == 0) {\\n            return feeWithMultiplier;\\n        }\\n        uint feeWithMargin = (_floorMarginUSD * NATIVE_DECIMALS_RATE) / _nativePriceUSD + _fee;\\n        return feeWithMargin > feeWithMultiplier ? feeWithMargin : feeWithMultiplier;\\n    }\\n}\\n\",\"keccak256\":\"0xb5d6e0d4d418f400c0f0f8ccf083d02bd0805455ecd6f26b3f0ddc1f038763f8\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/ILayerZeroPriceFeed.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.7.0;\\npragma abicoder v2;\\n\\ninterface ILayerZeroPriceFeed {\\n    /**\\n     * @dev\\n     * priceRatio: (USD price of 1 unit of remote native token in unit of local native token) * PRICE_RATIO_DENOMINATOR\\n     */\\n\\n    struct Price {\\n        uint128 priceRatio; // float value * 10 ^ 20, decimal awared. for aptos to evm, the basis would be (10^18 / 10^8) * 10 ^20 = 10 ^ 30.\\n        uint64 gasPriceInUnit; // for evm, it is in wei, for aptos, it is in octas.\\n        uint32 gasPerByte;\\n    }\\n\\n    struct UpdatePrice {\\n        uint32 eid;\\n        Price price;\\n    }\\n\\n    /**\\n     * @dev\\n     *    ArbGasInfo.go:GetPricesInArbGas\\n     *\\n     */\\n    struct ArbitrumPriceExt {\\n        uint64 gasPerL2Tx; // L2 overhead\\n        uint32 gasPerL1CallDataByte;\\n    }\\n\\n    struct UpdatePriceExt {\\n        uint32 eid;\\n        Price price;\\n        ArbitrumPriceExt extend;\\n    }\\n\\n    function getPrice(uint32 _dstEid) external view returns (Price memory);\\n\\n    function getPriceRatioDenominator() external view returns (uint128);\\n\\n    function estimateFeeByChain(\\n        uint32 _dstEid,\\n        uint _callDataSize,\\n        uint _gas\\n    ) external view returns (uint fee, uint128 priceRatio, uint128 priceRatioDenominator, uint128 nativePriceUSD);\\n}\\n\",\"keccak256\":\"0x08173fe1d18f24cdc111c02c7cd3110f0b7b51233e1eb69524c655875ab89f28\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/ILayerZeroRelayer.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\ninterface ILayerZeroRelayer {\\n    // @notice query price and assign jobs at the same time\\n    // @param _dstEid - the destination endpoint identifier\\n    // @param _sender - the source sending contract address. relayers may apply price discrimination to senders\\n    // @param _calldataSize - dynamic data size of message + caller params\\n    // @param _options - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain\\n    function assignJob(\\n        uint32 _dstEid,\\n        address _sender,\\n        uint _calldataSize,\\n        bytes calldata _options\\n    ) external payable returns (uint price);\\n\\n    // @notice query the relayer price for relaying the payload and its proof to the destination chain\\n    // @param _dstEid - the destination endpoint identifier\\n    // @param _sender - the source sending contract address. relayers may apply price discrimination to senders\\n    // @param _calldataSize - dynamic data size of message + caller params\\n    // @param _options - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain\\n    function getFee(\\n        uint32 _dstEid,\\n        address _sender,\\n        uint _calldataSize,\\n        bytes calldata _options\\n    ) external view returns (uint price);\\n}\\n\",\"keccak256\":\"0xe812872b6abc631148b9c3c47c109f186cdbf769510bae83b0068321294b0fa1\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IRelayer.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IWorker.sol\\\";\\nimport \\\"./ILayerZeroRelayer.sol\\\";\\n\\ninterface IRelayer is IWorker, ILayerZeroRelayer {\\n    struct DstConfigParam {\\n        uint32 dstEid;\\n        uint64 baseGas;\\n        uint16 multiplierBps;\\n        uint128 floorMarginUSD;\\n        uint128 airdropCap;\\n    }\\n\\n    struct DstConfig {\\n        uint64 baseGas; // for delivering / fixed calldata overhead\\n        uint16 multiplierBps;\\n        uint128 floorMarginUSD;\\n        uint128 airdropCap;\\n    }\\n\\n    event SetDstConfig(DstConfigParam[] params);\\n\\n    function dstConfig(uint32 _dstEid) external view returns (uint64, uint16, uint128, uint128);\\n}\\n\",\"keccak256\":\"0xe72b1e7daef4a3083145665c96e867695135b9e26242e7aa8b53fd553cc6e24b\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IRelayerFeeLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./ILayerZeroPriceFeed.sol\\\";\\nimport \\\"./IRelayer.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\ninterface IRelayerFeeLib is IERC165 {\\n    function getFee(\\n        ILayerZeroPriceFeed _priceFeed,\\n        uint32 _dstEid,\\n        address _sender,\\n        uint _calldataSize,\\n        uint16 _defaultMultiplierBps,\\n        IRelayer.DstConfig memory _dstConfig,\\n        bytes calldata _options\\n    ) external view returns (uint fee);\\n}\\n\",\"keccak256\":\"0xed8f903fbc12238a9683ad14226d5b7e282b4dcf237168d96a31b6eff26d47f8\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IWorker.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./ILayerZeroPriceFeed.sol\\\";\\n\\ninterface IWorker {\\n    event SetWorkerLib(address workerLib);\\n    event SetPriceFeed(address priceFeed);\\n    event SetDefaultMultiplierBps(uint16 multiplierBps);\\n    event Withdraw(address lib, address to, uint amount);\\n\\n    function priceFeed() external view returns (ILayerZeroPriceFeed);\\n\\n    function setDefaultMultiplierBps(uint16 _multiplierBps) external;\\n\\n    function withdrawFee(address _lib, address payable _to, uint _amount) external;\\n\\n    function defaultMultiplierBps() external view returns (uint16);\\n}\\n\",\"keccak256\":\"0x0d103ee813a8f118601ce039af5b15ce7fb0808cd7162f32ebed97136d1ff1d7\",\"license\":\"BUSL-1.1\"},\"solidity-bytes-utils/contracts/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\\u00e7alo S\\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity >=0.8.0 <0.9.0;\\n\\n\\nlibrary BytesLib {\\n    function concat(\\n        bytes memory _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(0x40, and(\\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n              not(31) // Round down to the nearest 32 bytes.\\n            ))\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes.slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes.slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                                ),\\n                                // and now shift left the number of bytes to\\n                                // leave space for the length in the slot\\n                                exp(0x100, sub(32, newlength))\\n                            ),\\n                            // increase length by the double of the memory\\n                            // bytes length\\n                            mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(\\n                    sc,\\n                    add(\\n                        and(\\n                            fslot,\\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\\n                        ),\\n                        and(mload(mc), mask)\\n                    )\\n                )\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let mlengthmod := mod(mlength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n                for {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_bytes.length >= _start + 1 , \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\n        require(_bytes.length >= _start + 2, \\\"toUint16_outOfBounds\\\");\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\\n        require(_bytes.length >= _start + 4, \\\"toUint32_outOfBounds\\\");\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\\n        require(_bytes.length >= _start + 8, \\\"toUint64_outOfBounds\\\");\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\\n        require(_bytes.length >= _start + 12, \\\"toUint96_outOfBounds\\\");\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\\n        require(_bytes.length >= _start + 16, \\\"toUint128_outOfBounds\\\");\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n        require(_bytes.length >= _start + 32, \\\"toUint256_outOfBounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n        require(_bytes.length >= _start + 32, \\\"toBytes32_outOfBounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                // the next line is the loop condition:\\n                // while(uint256(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(\\n        bytes storage _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes.slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes.slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint256(mc < end) + cb == 2)\\n                        for {} eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n}\\n\",\"keccak256\":\"0xf75784dfc94ea43668eb195d5690a1dde1b6eda62017e73a3899721583821d29\",\"license\":\"Unlicense\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5061103e806100206000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c806301ffc9a71461003b5780635017cfd214610063575b600080fd5b61004e610049366004610c80565b610084565b60405190151581526020015b60405180910390f35b610076610071366004610d8d565b61011d565b60405190815260200161005a565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f5017cfd200000000000000000000000000000000000000000000000000000000148061011757507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b92915050565b6000816101975760405162461bcd60e51b815260206004820152602260248201527f52656c617965724665654c69623a206e6f206f7074696f6e732070726f76696460448201527f656400000000000000000000000000000000000000000000000000000000000060648201526084015b60405180910390fd5b8351606085015185918a918c918a918a9160009182916101b8918c8c61031e565b6040517fd5c7155000000000000000000000000000000000000000000000000000000000815263ffffffff891660048201526024810187905260448101829052919350915060009081908190819073ffffffffffffffffffffffffffffffffffffffff8a169063d5c7155090606401608060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610ee2565b935093509350935061029b848c6020015161ffff1660001461028e578c60200151610290565b885b8d6040015184610623565b9b508515610307576127108761ffff16836fffffffffffffffffffffffffffffffff16856fffffffffffffffffffffffffffffffff16896102dc9190610f4d565b6102e69190610f64565b6102f09190610f4d565b6102fa9190610f64565b610304908d610f86565b9b505b505050505050505050505098975050505050505050565b600080600061036285858080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506106ec92505050565b905060008767ffffffffffffffff16925060005b82518110156105f757600261ffff1683828151811061039757610397610f99565b60200260200101516000015161ffff16036104715760006103d48483815181106103c3576103c3610f99565b602002602001015160200151610894565b509050886fffffffffffffffffffffffffffffffff1681111561045f5760405162461bcd60e51b815260206004820152602960248201527f52656c617965724665654c69623a2061697264726f7020616d6f756e7420657860448201527f6365656473206361700000000000000000000000000000000000000000000000606482015260840161018e565b6104698187610f86565b9550506105e5565b600161ffff1683828151811061048957610489610f99565b60200260200101516000015161ffff16036104eb576000806104c78584815181106104b6576104b6610f99565b602002602001015160200151610903565b90925090506104d68188610f86565b96506104e28287610f86565b955050506105e5565b600361ffff1683828151811061050357610503610f99565b60200260200101516000015161ffff1603610541576000806104c785848151811061053057610530610f99565b6020026020010151602001516109a0565b600461ffff1683828151811061055957610559610f99565b60200260200101516000015161ffff160361057757600191506105e5565b60405162461bcd60e51b815260206004820152602260248201527f52656c617965724665654c69623a20696e76616c6964206f7074696f6e20747960448201527f7065000000000000000000000000000000000000000000000000000000000000606482015260840161018e565b806105ef81610faf565b915050610376565b50801561061857606461060b846066610f4d565b6106159190610f64565b92505b505094509492505050565b60008061271061063761ffff871688610f4d565b6106419190610f64565b90506fffffffffffffffffffffffffffffffff8316158061067257506fffffffffffffffffffffffffffffffff8416155b1561067e5790506106e4565b600086846fffffffffffffffffffffffffffffffff16670de0b6b3a7640000876fffffffffffffffffffffffffffffffff166106ba9190610f4d565b6106c49190610f64565b6106ce9190610f86565b90508181116106dd57816106df565b805b925050505b949350505050565b60606000806106fb8482610a08565b9050610708600283610f86565b915060008161ffff1667ffffffffffffffff81111561072957610729610d05565b60405190808252806020026020018201604052801561076f57816020015b6040805180820190915260008152606060208201528152602001906001900390816107475790505b5090506000805b8361ffff168161ffff1610156108895760006107928887610a08565b905061079f600287610f86565b95508261ffff168161ffff16116107f85760405162461bcd60e51b815260206004820152600760248201527f4c5a313030303600000000000000000000000000000000000000000000000000604482015260640161018e565b91508160006108078988610a08565b9050610814600288610f86565b965060006108278a8961ffff8516610a6e565b905061083761ffff831689610f86565b975060405180604001604052808461ffff16815260200182815250868561ffff168151811061086857610868610f99565b6020026020010181905250505050808061088190610fe7565b915050610776565b509095945050505050565b60008082516030146108d25760405162461bcd60e51b81526020600482015260076024820152664c5a313030303960c81b604482015260640161018e565b6108dd836000610bb4565b6fffffffffffffffffffffffffffffffff1691506108fc836010610c1a565b9050915091565b600080825160101480610917575082516020145b61094d5760405162461bcd60e51b81526020600482015260076024820152664c5a313030303960c81b604482015260640161018e565b610958836000610bb4565b6fffffffffffffffffffffffffffffffff169150825160201461097c576000610987565b610987836010610bb4565b6fffffffffffffffffffffffffffffffff169050915091565b60008082516020146109de5760405162461bcd60e51b81526020600482015260076024820152664c5a313030303960c81b604482015260640161018e565b6109e9836000610bb4565b6fffffffffffffffffffffffffffffffff169150610987836010610bb4565b6000610a15826002610f86565b83511015610a655760405162461bcd60e51b815260206004820152601460248201527f746f55696e7431365f6f75744f66426f756e6473000000000000000000000000604482015260640161018e565b50016002015190565b606081610a7c81601f610f86565b1015610aca5760405162461bcd60e51b815260206004820152600e60248201527f736c6963655f6f766572666c6f77000000000000000000000000000000000000604482015260640161018e565b610ad48284610f86565b84511015610b245760405162461bcd60e51b815260206004820152601160248201527f736c6963655f6f75744f66426f756e6473000000000000000000000000000000604482015260640161018e565b606082158015610b435760405191506000825260208201604052610bab565b6040519150601f8416801560200281840101858101878315602002848b0101015b81831015610b7c578051835260209283019201610b64565b5050858452601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016604052505b50949350505050565b6000610bc1826010610f86565b83511015610c115760405162461bcd60e51b815260206004820152601560248201527f746f55696e743132385f6f75744f66426f756e64730000000000000000000000604482015260640161018e565b50016010015190565b6000610c27826020610f86565b83511015610c775760405162461bcd60e51b815260206004820152601560248201527f746f427974657333325f6f75744f66426f756e64730000000000000000000000604482015260640161018e565b50016020015190565b600060208284031215610c9257600080fd5b81357fffffffff0000000000000000000000000000000000000000000000000000000081168114610cc257600080fd5b9392505050565b73ffffffffffffffffffffffffffffffffffffffff81168114610ceb57600080fd5b50565b803561ffff81168114610d0057600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b6fffffffffffffffffffffffffffffffff81168114610ceb57600080fd5b8035610d0081610d1b565b60008083601f840112610d5657600080fd5b50813567ffffffffffffffff811115610d6e57600080fd5b602083019150836020828501011115610d8657600080fd5b9250929050565b600080600080600080600080888a03610140811215610dab57600080fd5b8935610db681610cc9565b985060208a013563ffffffff81168114610dcf57600080fd5b975060408a0135610ddf81610cc9565b965060608a01359550610df460808b01610cee565b945060807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6082011215610e2657600080fd5b506040516080810167ffffffffffffffff8282108183111715610e5957634e487b7160e01b600052604160045260246000fd5b8160405260a08c013591508082168214610e7257600080fd5b818352610e8160c08d01610cee565b6020840152610e9260e08d01610d39565b6040840152610ea46101008d01610d39565b60608401529194506101208b01359180831115610ec057600080fd5b5050610ece8b828c01610d44565b999c989b5096995094979396929594505050565b60008060008060808587031215610ef857600080fd5b845193506020850151610f0a81610d1b565b6040860151909350610f1b81610d1b565b6060860151909250610f2c81610d1b565b939692955090935050565b634e487b7160e01b600052601160045260246000fd5b808202811582820484141761011757610117610f37565b600082610f8157634e487b7160e01b600052601260045260246000fd5b500490565b8082018082111561011757610117610f37565b634e487b7160e01b600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203610fe057610fe0610f37565b5060010190565b600061ffff808316818103610ffe57610ffe610f37565b600101939250505056fea264697066735822122048a59abf2cd287f491a5572fb2e12442e3b5493e87a4c4db57ad13bc289742ce64736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100365760003560e01c806301ffc9a71461003b5780635017cfd214610063575b600080fd5b61004e610049366004610c80565b610084565b60405190151581526020015b60405180910390f35b610076610071366004610d8d565b61011d565b60405190815260200161005a565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f5017cfd200000000000000000000000000000000000000000000000000000000148061011757507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b92915050565b6000816101975760405162461bcd60e51b815260206004820152602260248201527f52656c617965724665654c69623a206e6f206f7074696f6e732070726f76696460448201527f656400000000000000000000000000000000000000000000000000000000000060648201526084015b60405180910390fd5b8351606085015185918a918c918a918a9160009182916101b8918c8c61031e565b6040517fd5c7155000000000000000000000000000000000000000000000000000000000815263ffffffff891660048201526024810187905260448101829052919350915060009081908190819073ffffffffffffffffffffffffffffffffffffffff8a169063d5c7155090606401608060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610ee2565b935093509350935061029b848c6020015161ffff1660001461028e578c60200151610290565b885b8d6040015184610623565b9b508515610307576127108761ffff16836fffffffffffffffffffffffffffffffff16856fffffffffffffffffffffffffffffffff16896102dc9190610f4d565b6102e69190610f64565b6102f09190610f4d565b6102fa9190610f64565b610304908d610f86565b9b505b505050505050505050505098975050505050505050565b600080600061036285858080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506106ec92505050565b905060008767ffffffffffffffff16925060005b82518110156105f757600261ffff1683828151811061039757610397610f99565b60200260200101516000015161ffff16036104715760006103d48483815181106103c3576103c3610f99565b602002602001015160200151610894565b509050886fffffffffffffffffffffffffffffffff1681111561045f5760405162461bcd60e51b815260206004820152602960248201527f52656c617965724665654c69623a2061697264726f7020616d6f756e7420657860448201527f6365656473206361700000000000000000000000000000000000000000000000606482015260840161018e565b6104698187610f86565b9550506105e5565b600161ffff1683828151811061048957610489610f99565b60200260200101516000015161ffff16036104eb576000806104c78584815181106104b6576104b6610f99565b602002602001015160200151610903565b90925090506104d68188610f86565b96506104e28287610f86565b955050506105e5565b600361ffff1683828151811061050357610503610f99565b60200260200101516000015161ffff1603610541576000806104c785848151811061053057610530610f99565b6020026020010151602001516109a0565b600461ffff1683828151811061055957610559610f99565b60200260200101516000015161ffff160361057757600191506105e5565b60405162461bcd60e51b815260206004820152602260248201527f52656c617965724665654c69623a20696e76616c6964206f7074696f6e20747960448201527f7065000000000000000000000000000000000000000000000000000000000000606482015260840161018e565b806105ef81610faf565b915050610376565b50801561061857606461060b846066610f4d565b6106159190610f64565b92505b505094509492505050565b60008061271061063761ffff871688610f4d565b6106419190610f64565b90506fffffffffffffffffffffffffffffffff8316158061067257506fffffffffffffffffffffffffffffffff8416155b1561067e5790506106e4565b600086846fffffffffffffffffffffffffffffffff16670de0b6b3a7640000876fffffffffffffffffffffffffffffffff166106ba9190610f4d565b6106c49190610f64565b6106ce9190610f86565b90508181116106dd57816106df565b805b925050505b949350505050565b60606000806106fb8482610a08565b9050610708600283610f86565b915060008161ffff1667ffffffffffffffff81111561072957610729610d05565b60405190808252806020026020018201604052801561076f57816020015b6040805180820190915260008152606060208201528152602001906001900390816107475790505b5090506000805b8361ffff168161ffff1610156108895760006107928887610a08565b905061079f600287610f86565b95508261ffff168161ffff16116107f85760405162461bcd60e51b815260206004820152600760248201527f4c5a313030303600000000000000000000000000000000000000000000000000604482015260640161018e565b91508160006108078988610a08565b9050610814600288610f86565b965060006108278a8961ffff8516610a6e565b905061083761ffff831689610f86565b975060405180604001604052808461ffff16815260200182815250868561ffff168151811061086857610868610f99565b6020026020010181905250505050808061088190610fe7565b915050610776565b509095945050505050565b60008082516030146108d25760405162461bcd60e51b81526020600482015260076024820152664c5a313030303960c81b604482015260640161018e565b6108dd836000610bb4565b6fffffffffffffffffffffffffffffffff1691506108fc836010610c1a565b9050915091565b600080825160101480610917575082516020145b61094d5760405162461bcd60e51b81526020600482015260076024820152664c5a313030303960c81b604482015260640161018e565b610958836000610bb4565b6fffffffffffffffffffffffffffffffff169150825160201461097c576000610987565b610987836010610bb4565b6fffffffffffffffffffffffffffffffff169050915091565b60008082516020146109de5760405162461bcd60e51b81526020600482015260076024820152664c5a313030303960c81b604482015260640161018e565b6109e9836000610bb4565b6fffffffffffffffffffffffffffffffff169150610987836010610bb4565b6000610a15826002610f86565b83511015610a655760405162461bcd60e51b815260206004820152601460248201527f746f55696e7431365f6f75744f66426f756e6473000000000000000000000000604482015260640161018e565b50016002015190565b606081610a7c81601f610f86565b1015610aca5760405162461bcd60e51b815260206004820152600e60248201527f736c6963655f6f766572666c6f77000000000000000000000000000000000000604482015260640161018e565b610ad48284610f86565b84511015610b245760405162461bcd60e51b815260206004820152601160248201527f736c6963655f6f75744f66426f756e6473000000000000000000000000000000604482015260640161018e565b606082158015610b435760405191506000825260208201604052610bab565b6040519150601f8416801560200281840101858101878315602002848b0101015b81831015610b7c578051835260209283019201610b64565b5050858452601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016604052505b50949350505050565b6000610bc1826010610f86565b83511015610c115760405162461bcd60e51b815260206004820152601560248201527f746f55696e743132385f6f75744f66426f756e64730000000000000000000000604482015260640161018e565b50016010015190565b6000610c27826020610f86565b83511015610c775760405162461bcd60e51b815260206004820152601560248201527f746f427974657333325f6f75744f66426f756e64730000000000000000000000604482015260640161018e565b50016020015190565b600060208284031215610c9257600080fd5b81357fffffffff0000000000000000000000000000000000000000000000000000000081168114610cc257600080fd5b9392505050565b73ffffffffffffffffffffffffffffffffffffffff81168114610ceb57600080fd5b50565b803561ffff81168114610d0057600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b6fffffffffffffffffffffffffffffffff81168114610ceb57600080fd5b8035610d0081610d1b565b60008083601f840112610d5657600080fd5b50813567ffffffffffffffff811115610d6e57600080fd5b602083019150836020828501011115610d8657600080fd5b9250929050565b600080600080600080600080888a03610140811215610dab57600080fd5b8935610db681610cc9565b985060208a013563ffffffff81168114610dcf57600080fd5b975060408a0135610ddf81610cc9565b965060608a01359550610df460808b01610cee565b945060807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6082011215610e2657600080fd5b506040516080810167ffffffffffffffff8282108183111715610e5957634e487b7160e01b600052604160045260246000fd5b8160405260a08c013591508082168214610e7257600080fd5b818352610e8160c08d01610cee565b6020840152610e9260e08d01610d39565b6040840152610ea46101008d01610d39565b60608401529194506101208b01359180831115610ec057600080fd5b5050610ece8b828c01610d44565b999c989b5096995094979396929594505050565b60008060008060808587031215610ef857600080fd5b845193506020850151610f0a81610d1b565b6040860151909350610f1b81610d1b565b6060860151909250610f2c81610d1b565b939692955090935050565b634e487b7160e01b600052601160045260246000fd5b808202811582820484141761011757610117610f37565b600082610f8157634e487b7160e01b600052601260045260246000fd5b500490565b8082018082111561011757610117610f37565b634e487b7160e01b600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203610fe057610fe0610f37565b5060010190565b600061ffff808316818103610ffe57610ffe610f37565b600101939250505056fea264697066735822122048a59abf2cd287f491a5572fb2e12442e3b5493e87a4c4db57ad13bc289742ce64736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}