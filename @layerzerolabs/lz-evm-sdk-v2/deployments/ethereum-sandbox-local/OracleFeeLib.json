{
  "address": "0x93C7a6D00849c44Ef3E92E95DCEFfccd447909Ae",
  "abi": [
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "priceFeed",
              "type": "address"
            },
            {
              "internalType": "uint32",
              "name": "dstEid",
              "type": "uint32"
            },
            {
              "internalType": "uint64",
              "name": "confirmations",
              "type": "uint64"
            },
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "uint64",
              "name": "quorum",
              "type": "uint64"
            },
            {
              "internalType": "uint16",
              "name": "defaultMultiplierBps",
              "type": "uint16"
            }
          ],
          "internalType": "struct IOracleFeeLib.FeeParams",
          "name": "_params",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "gas",
              "type": "uint64"
            },
            {
              "internalType": "uint16",
              "name": "multiplierBps",
              "type": "uint16"
            },
            {
              "internalType": "uint128",
              "name": "floorMarginUSD",
              "type": "uint128"
            }
          ],
          "internalType": "struct IOracle.DstConfig",
          "name": "_dstConfig",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "getFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract ILayerZeroPriceFeed",
          "name": "_priceFeed",
          "type": "address"
        },
        {
          "internalType": "uint32",
          "name": "_dstEid",
          "type": "uint32"
        }
      ],
      "name": "getPrice",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "",
          "type": "uint128"
        },
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xb074312515d90c01482569ecf1d8b10389aacb096193d0129afc3dd59fb9d5c4",
  "receipt": {
    "to": null,
    "from": "0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65",
    "contractAddress": "0x93C7a6D00849c44Ef3E92E95DCEFfccd447909Ae",
    "transactionIndex": 0,
    "gasUsed": "562571",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x8ced251aa9f79c2bbd4f9671e94d7b0e32498e7522088369d3f04c4b208e7736",
    "transactionHash": "0xb074312515d90c01482569ecf1d8b10389aacb096193d0129afc3dd59fb9d5c4",
    "logs": [],
    "blockNumber": 232,
    "cumulativeGasUsed": "562571",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "5ffde9e3e6b2b0a4f1d21e15c800c066",
  "metadata": "{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"priceFeed\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"dstEid\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"confirmations\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"quorum\",\"type\":\"uint64\"},{\"internalType\":\"uint16\",\"name\":\"defaultMultiplierBps\",\"type\":\"uint16\"}],\"internalType\":\"struct IOracleFeeLib.FeeParams\",\"name\":\"_params\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"gas\",\"type\":\"uint64\"},{\"internalType\":\"uint16\",\"name\":\"multiplierBps\",\"type\":\"uint16\"},{\"internalType\":\"uint128\",\"name\":\"floorMarginUSD\",\"type\":\"uint128\"}],\"internalType\":\"struct IOracle.DstConfig\",\"name\":\"_dstConfig\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILayerZeroPriceFeed\",\"name\":\"_priceFeed\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_dstEid\",\"type\":\"uint32\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/uln/OracleFeeLib.sol\":\"OracleFeeLib\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":20000},\"remappings\":[]},\"sources\":{\"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/Options.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"solidity-bytes-utils/contracts/BytesLib.sol\\\";\\n\\nlibrary Options {\\n    using BytesLib for bytes;\\n\\n    struct WorkerOptions {\\n        uint16 workerId;\\n        bytes options;\\n    }\\n\\n    struct Option {\\n        uint16 optionType;\\n        bytes params;\\n    }\\n\\n    uint16 internal constant EXECUTOR_WORKER_ID = 1; // matches ExecutorOptions WORKER_ID\\n\\n    uint16 internal constant TYPE_1 = 1; // simple option type 1\\n    uint16 internal constant TYPE_2 = 2; // simple option type 2\\n    uint16 internal constant TYPE_3 = 3; // cannot overlap with simple option types\\n\\n    /// ======================= Decoding Functions =======================\\n    function decodeOptions(bytes memory _options) internal pure returns (WorkerOptions[] memory) {\\n        uint16 formatType = _options.toUint16(0);\\n        if (formatType == TYPE_1 || formatType == TYPE_2) {\\n            WorkerOptions[] memory options = _convert(formatType, _options);\\n            return options;\\n        }\\n\\n        // new format type 3\\n        // [type3][numWorkers][workerOps][workerOps]...\\n        // [workerOps] -> [workerId][size][options]\\n        if (formatType == 3) {\\n            uint16 numWorkers = _options.toUint16(2);\\n            WorkerOptions[] memory options = new WorkerOptions[](numWorkers);\\n\\n            // parse options for each worker\\n            uint cursor = 4;\\n            uint16 lastWorkerId;\\n            for (uint i = 0; i < uint(numWorkers); i++) {\\n                // must be ascending order\\n                uint16 workerId = _options.toUint16(cursor);\\n                cursor += 2;\\n\\n                // no duplicated worker id, and the first worker id can be 0 because of enum type\\n                require(i == 0 || workerId > lastWorkerId, \\\"LZ10006\\\");\\n                lastWorkerId = workerId;\\n\\n                // option size\\n                uint16 size = _options.toUint16(cursor);\\n                cursor += 2;\\n\\n                options[i] = WorkerOptions(workerId, _options.slice(cursor, size));\\n                cursor += size;\\n            }\\n            require(cursor == _options.length, \\\"LZ10009\\\");\\n            return options;\\n        }\\n\\n        revert(\\\"LZC0000\\\");\\n    }\\n\\n    /// @dev decode worker options\\n    function decodeWorkerOptions(bytes memory _options) internal pure returns (Option[] memory) {\\n        uint cursor = 0;\\n        uint16 numOptions = _options.toUint16(cursor);\\n        cursor += 2;\\n\\n        Option[] memory options = new Option[](numOptions);\\n        uint16 lastOptionType;\\n        for (uint16 i = 0; i < numOptions; i++) {\\n            uint16 optionType = _options.toUint16(cursor);\\n            cursor += 2;\\n            // no duplicated option type\\n            require(optionType > lastOptionType, \\\"LZ10006\\\");\\n            lastOptionType = optionType;\\n\\n            uint16 paramSize = _options.toUint16(cursor);\\n            cursor += 2;\\n\\n            bytes memory param = _options.slice(cursor, paramSize);\\n            cursor += paramSize;\\n            options[i] = Option(optionType, param);\\n        }\\n        return options;\\n    }\\n\\n    // executor only\\n    // legacy type 1\\n    // bytes  [32      ]\\n    // fields [extraGas]\\n    // legacy type 2\\n    // bytes  [32        32            bytes[]         ]\\n    // fields [extraGas  dstNativeAmt  dstNativeAddress]\\n    function _convert(\\n        uint _optionType,\\n        bytes memory _options\\n    ) private pure returns (WorkerOptions[] memory workerOptions) {\\n        workerOptions = new WorkerOptions[](1);\\n        bytes memory options;\\n\\n        if (_optionType == TYPE_1) {\\n            require(_options.length == 34, \\\"LZ10009\\\");\\n\\n            // execution gas\\n            uint executionGas = _options.toUint256(2);\\n            require(executionGas <= type(uint128).max, \\\"LZ10009\\\");\\n\\n            options = abi.encodePacked(uint16(1)); // option num\\n            options = abi.encodePacked(options, TYPE_1, uint16(16), uint128(executionGas));\\n        } else if (_optionType == TYPE_2) {\\n            require(_options.length > 66 && _options.length <= 98, \\\"LZ10009\\\");\\n\\n            // execution gas\\n            uint executionGas = _options.toUint256(2);\\n            require(executionGas <= type(uint128).max, \\\"LZ10009\\\");\\n\\n            // airdrop (amount + receiver)\\n            uint amount = _options.toUint256(34);\\n            require(amount <= type(uint128).max, \\\"LZ10009\\\");\\n\\n            uint receiverLen = _options.length - 66;\\n            bytes32 receiver = bytes32(_options.slice(66, receiverLen));\\n            receiver = receiver >> (8 * (32 - receiverLen)); // padding 0 to the left\\n            bytes memory airdrop = abi.encodePacked(uint128(amount), receiver);\\n\\n            options = abi.encodePacked(uint16(2)); // option num\\n            options = abi.encodePacked(options, TYPE_1, uint16(16), uint128(executionGas));\\n            options = abi.encodePacked(options, TYPE_2, uint16(airdrop.length), airdrop);\\n        } else {\\n            revert(\\\"LZC0000\\\");\\n        }\\n\\n        workerOptions[0] = WorkerOptions(EXECUTOR_WORKER_ID, options);\\n    }\\n\\n    /// ======================= Encoding Functions =======================\\n\\n    function encodeWorkerOptions(Option memory _option) internal pure returns (bytes memory) {\\n        Option[] memory options = new Option[](1);\\n        options[0] = _option;\\n        return encodeWorkerOptions(options);\\n    }\\n\\n    function encodeWorkerOptions(Option[] memory _options) internal pure returns (bytes memory) {\\n        require(_options.length > 0, \\\"LZ10009\\\");\\n        uint16 numOptions = _safeToUint16(_options.length);\\n        bytes memory options = abi.encodePacked(numOptions);\\n\\n        uint16 lastOptionType;\\n        for (uint i = 0; i < numOptions; i++) {\\n            // no duplicated option type\\n            uint16 optionType = _options[i].optionType;\\n            require(i == 0 || optionType > lastOptionType, \\\"LZ10006\\\");\\n            lastOptionType = optionType;\\n\\n            uint16 paramSize = _safeToUint16(_options[i].params.length);\\n            bytes memory option = abi.encodePacked(_options[i].optionType, paramSize, _options[i].params);\\n\\n            options = options.concat(option);\\n        }\\n\\n        return options;\\n    }\\n\\n    function encodeOptions(WorkerOptions[] memory _workerOptions) internal pure returns (bytes memory) {\\n        uint16 numWorkers = _safeToUint16(_workerOptions.length);\\n        bytes memory options = abi.encodePacked(TYPE_3, numWorkers);\\n\\n        uint16 lastWorkerId;\\n        for (uint i = 0; i < numWorkers; i++) {\\n            uint16 workerId = uint16(_workerOptions[i].workerId);\\n            // prevent duplicated worker id\\n            require(i == 0 || workerId > lastWorkerId, \\\"LZ10006\\\");\\n\\n            uint16 optionSize = _safeToUint16(_workerOptions[i].options.length);\\n            options = abi.encodePacked(options, workerId, optionSize, _workerOptions[i].options);\\n\\n            lastWorkerId = workerId;\\n        }\\n\\n        return options;\\n    }\\n\\n    function encodeSimpleOptionsType1(uint256 _executionGas) internal pure returns (bytes memory) {\\n        require(_executionGas <= type(uint128).max, \\\"LZ10009\\\");\\n        return abi.encodePacked(TYPE_1, _executionGas);\\n    }\\n\\n    function encodeSimpleOptionsType2(\\n        uint256 _executionGas,\\n        uint256 _amount,\\n        bytes32 _receiver\\n    ) internal pure returns (bytes memory) {\\n        require(_executionGas <= type(uint128).max && _amount <= type(uint128).max, \\\"LZ10009\\\");\\n        return abi.encodePacked(TYPE_2, _executionGas, _amount, _receiver);\\n    }\\n\\n    /// ======================= Getter Functions =======================\\n\\n    function getWorkerOptionsByWorkerId(\\n        WorkerOptions[] memory _workerOptions,\\n        uint16 _workerId\\n    ) internal pure returns (bool, uint, bytes memory) {\\n        for (uint i = 0; i < _workerOptions.length; i++) {\\n            if (_workerOptions[i].workerId == _workerId) {\\n                return (true, i, _workerOptions[i].options);\\n            }\\n        }\\n        return (false, 0, bytes(\\\"\\\"));\\n    }\\n\\n    function getOptionByOptionType(\\n        Option[] memory _options,\\n        uint16 _optionType\\n    ) internal pure returns (bool, uint, bytes memory) {\\n        for (uint i = 0; i < _options.length; i++) {\\n            if (_options[i].optionType == _optionType) {\\n                return (true, i, _options[i].params);\\n            }\\n        }\\n        return (false, 0, bytes(\\\"\\\"));\\n    }\\n\\n    function getOptionByWorkerIdAndOptionType(\\n        WorkerOptions[] memory _workerOptions,\\n        uint16 _workerId,\\n        uint16 _optionType\\n    ) internal pure returns (bool, bytes memory) {\\n        (bool found, , bytes memory options) = getWorkerOptionsByWorkerId(_workerOptions, _workerId);\\n        if (!found) {\\n            return (false, bytes(\\\"\\\"));\\n        }\\n\\n        (found, , options) = getOptionByOptionType(decodeWorkerOptions(options), _optionType);\\n        return (found, options);\\n    }\\n\\n    function _safeToUint16(uint _value) private pure returns (uint16) {\\n        require(_value <= type(uint16).max, \\\"LZ10009\\\");\\n        return uint16(_value);\\n    }\\n}\\n\",\"keccak256\":\"0x16463006eadd3a81609356d75f94bf827ffcf1ba9f426ab46e6842a68152dc5a\",\"license\":\"BUSL-1.1\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/interfaces/ILayerZeroPriceFeed.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.7.0;\\npragma abicoder v2;\\n\\ninterface ILayerZeroPriceFeed {\\n    /**\\n     * @dev\\n     * priceRatio: (USD price of 1 unit of remote native token in unit of local native token) * PRICE_RATIO_DENOMINATOR\\n     */\\n\\n    struct Price {\\n        uint128 priceRatio; // float value * 10 ^ 20, decimal awared. for aptos to evm, the basis would be (10^18 / 10^8) * 10 ^20 = 10 ^ 30.\\n        uint64 gasPriceInUnit; // for evm, it is in wei, for aptos, it is in octas.\\n        uint32 gasPerByte;\\n    }\\n\\n    struct UpdatePrice {\\n        uint32 eid;\\n        Price price;\\n    }\\n\\n    /**\\n     * @dev\\n     *    ArbGasInfo.go:GetPricesInArbGas\\n     *\\n     */\\n    struct ArbitrumPriceExt {\\n        uint64 gasPerL2Tx; // L2 overhead\\n        uint32 gasPerL1CallDataByte;\\n    }\\n\\n    struct UpdatePriceExt {\\n        uint32 eid;\\n        Price price;\\n        ArbitrumPriceExt extend;\\n    }\\n\\n    function getPrice(uint32 _dstEid) external view returns (Price memory);\\n\\n    function getPriceRatioDenominator() external view returns (uint128);\\n\\n    function estimateFeeByEid(\\n        uint32 _dstEid,\\n        uint _callDataSize,\\n        uint _gas\\n    ) external view returns (uint fee, uint128 priceRatio, uint128 priceRatioDenominator, uint128 nativePriceUSD);\\n}\\n\",\"keccak256\":\"0xf15344080b17108bd5f019e5abd2d55b6aae25ab7bd7ee969c31776a66a70e06\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IWorker.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\ninterface IWorker {\\n    event SetWorkerLib(address workerLib);\\n    event SetPriceFeed(address priceFeed);\\n    event SetDefaultMultiplierBps(uint16 multiplierBps);\\n    event Withdraw(address lib, address to, uint amount);\\n\\n    function priceFeed() external view returns (address);\\n\\n    function setDefaultMultiplierBps(uint16 _multiplierBps) external;\\n\\n    function withdrawFee(address _lib, address payable _to, uint _amount) external;\\n\\n    function defaultMultiplierBps() external view returns (uint16);\\n}\\n\",\"keccak256\":\"0x2ca44b0296d9308b89bfd09ef87369ce4482c076953d6e8ba1459f43b53a25df\",\"license\":\"BUSL-1.1\"},\"contracts/uln/OracleFeeLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/Options.sol\\\";\\n\\nimport \\\"../interfaces/ILayerZeroPriceFeed.sol\\\";\\nimport \\\"./interfaces/IOracle.sol\\\";\\nimport \\\"./interfaces/IOracleFeeLib.sol\\\";\\n\\ncontract OracleFeeLib is IOracleFeeLib, ERC165 {\\n    uint16 internal constant EXECUTE_FIXED_BYTES = 68; // encoded: funcSigHash + params -> 4  + (32 * 2)\\n    uint16 internal constant SIGNATURE_RAW_BYTES = 65; // not encoded\\n    // callData(updateHash) = 132 (4 + 32 * 4), padded to 32 = 160 and encoded as bytes with an 64 byte overhead = 224\\n    uint16 internal constant UPDATE_HASH_BYTES = 224;\\n    uint internal constant NATIVE_DECIMALS_RATE = 1e18;\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IOracleFeeLib).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    // pass through for offchain fee calculation\\n    function getPrice(ILayerZeroPriceFeed _priceFeed, uint32 _dstEid) public view returns (uint128, uint64) {\\n        ILayerZeroPriceFeed.Price memory price = _priceFeed.getPrice(_dstEid);\\n        return (price.priceRatio, price.gasPriceInUnit);\\n    }\\n\\n    function getFee(\\n        FeeParams memory _params,\\n        IOracle.DstConfig memory _dstConfig,\\n        bytes memory /* _options */\\n    ) external view returns (uint) {\\n        uint totalSignatureBytes = uint(_params.quorum) * SIGNATURE_RAW_BYTES;\\n        if (totalSignatureBytes % 32 != 0) {\\n            totalSignatureBytes = totalSignatureBytes - (totalSignatureBytes % 32) + 32;\\n        }\\n        // getFee should charge on execute(updateHash)\\n        // totalSignatureBytesPadded also has 64 overhead for bytes\\n        uint callDataSize = uint(EXECUTE_FIXED_BYTES) + UPDATE_HASH_BYTES + totalSignatureBytes + 64;\\n        (uint fee, , , uint128 nativePriceUSD) = ILayerZeroPriceFeed(_params.priceFeed).estimateFeeByEid(\\n            _params.dstEid,\\n            callDataSize,\\n            _dstConfig.gas\\n        );\\n        uint16 multiplierBps = _dstConfig.multiplierBps == 0 ? _params.defaultMultiplierBps : _dstConfig.multiplierBps;\\n\\n        uint feeWithMultiplier = (fee * multiplierBps) / 10000;\\n        if (nativePriceUSD == 0 || _dstConfig.floorMarginUSD == 0) {\\n            return feeWithMultiplier;\\n        }\\n\\n        uint feeWithFloorMargin = fee + (_dstConfig.floorMarginUSD * NATIVE_DECIMALS_RATE) / nativePriceUSD;\\n\\n        return feeWithFloorMargin > feeWithMultiplier ? feeWithFloorMargin : feeWithMultiplier;\\n    }\\n}\\n\",\"keccak256\":\"0x183173141a420faf22464e9a2e4818aafeaf4f94791f316487a966525743af6d\",\"license\":\"BUSL-1.1\"},\"contracts/uln/interfaces/ILayerZeroOracle.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\ninterface ILayerZeroOracle {\\n    // @notice query price and assign jobs at the same time\\n    // @param _dstEid - the destination endpoint identifier\\n    // @param _confirmations - block confirmation delay before relaying blocks\\n    // @param _sender - the source sending contract address\\n    // @param _options - options\\n    function assignJob(\\n        uint32 _dstEid,\\n        uint64 _confirmations,\\n        address _sender,\\n        bytes calldata _options\\n    ) external payable returns (uint fee);\\n\\n    // @notice query the oracle fee for relaying block information to the destination chain\\n    // @param _dstEid the destination endpoint identifier\\n    // @param _confirmations - block confirmation delay before relaying blocks\\n    // @param _sender - the source sending contract address\\n    // @param _options - options\\n    function getFee(\\n        uint32 _dstEid,\\n        uint64 _confirmations,\\n        address _sender,\\n        bytes calldata _options\\n    ) external view returns (uint fee);\\n}\\n\",\"keccak256\":\"0xcea231f493ce3f24ed6a3949e09ad0b8f800f8fbcb00b64a7c7967eea277d4ac\",\"license\":\"BUSL-1.1\"},\"contracts/uln/interfaces/IOracle.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"../../interfaces/IWorker.sol\\\";\\nimport \\\"./ILayerZeroOracle.sol\\\";\\n\\ninterface IOracle is IWorker, ILayerZeroOracle {\\n    struct DstConfigParam {\\n        uint32 dstEid;\\n        uint64 gas;\\n        uint16 multiplierBps;\\n        uint128 floorMarginUSD;\\n    }\\n\\n    struct DstConfig {\\n        uint64 gas;\\n        uint16 multiplierBps;\\n        uint128 floorMarginUSD;\\n    }\\n\\n    event AssignJob(uint32 dstEid, address oapp, uint64 confirmations, uint totalFee);\\n    event SetDstConfig(DstConfigParam[] params);\\n\\n    function dstConfig(uint32 _dstEid) external view returns (uint64, uint16, uint128);\\n}\\n\",\"keccak256\":\"0x92c9e2d4b94721408a76c06d2e97cf07e9e18200d62851d6fb9fcdaf48f9d6cb\",\"license\":\"BUSL-1.1\"},\"contracts/uln/interfaces/IOracleFeeLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IOracle.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\ninterface IOracleFeeLib is IERC165 {\\n    struct FeeParams {\\n        address priceFeed;\\n        uint32 dstEid;\\n        uint64 confirmations;\\n        address sender;\\n        uint64 quorum;\\n        uint16 defaultMultiplierBps;\\n    }\\n\\n    function getFee(\\n        FeeParams memory _params,\\n        IOracle.DstConfig memory _dstConfig,\\n        bytes memory _options\\n    ) external view returns (uint fee);\\n}\\n\",\"keccak256\":\"0x3ace8dea27f4cb0c1a039f3ee16c96f60aab05437218c758bb39185cb886b83f\",\"license\":\"BUSL-1.1\"},\"solidity-bytes-utils/contracts/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\\u00e7alo S\\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity >=0.8.0 <0.9.0;\\n\\n\\nlibrary BytesLib {\\n    function concat(\\n        bytes memory _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(0x40, and(\\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n              not(31) // Round down to the nearest 32 bytes.\\n            ))\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes.slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes.slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                                ),\\n                                // and now shift left the number of bytes to\\n                                // leave space for the length in the slot\\n                                exp(0x100, sub(32, newlength))\\n                            ),\\n                            // increase length by the double of the memory\\n                            // bytes length\\n                            mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(\\n                    sc,\\n                    add(\\n                        and(\\n                            fslot,\\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\\n                        ),\\n                        and(mload(mc), mask)\\n                    )\\n                )\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let mlengthmod := mod(mlength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n                for {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_bytes.length >= _start + 1 , \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\n        require(_bytes.length >= _start + 2, \\\"toUint16_outOfBounds\\\");\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\\n        require(_bytes.length >= _start + 4, \\\"toUint32_outOfBounds\\\");\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\\n        require(_bytes.length >= _start + 8, \\\"toUint64_outOfBounds\\\");\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\\n        require(_bytes.length >= _start + 12, \\\"toUint96_outOfBounds\\\");\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\\n        require(_bytes.length >= _start + 16, \\\"toUint128_outOfBounds\\\");\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n        require(_bytes.length >= _start + 32, \\\"toUint256_outOfBounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n        require(_bytes.length >= _start + 32, \\\"toBytes32_outOfBounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                // the next line is the loop condition:\\n                // while(uint256(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(\\n        bytes storage _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes.slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes.slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint256(mc < end) + cb == 2)\\n                        for {} eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n}\\n\",\"keccak256\":\"0xf75784dfc94ea43668eb195d5690a1dde1b6eda62017e73a3899721583821d29\",\"license\":\"Unlicense\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610946806100206000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c806301ffc9a714610046578063228cdc031461006e5780637bfa20a9146100b2575b600080fd5b610059610054366004610454565b6100d3565b60405190151581526020015b60405180910390f35b61008161007c3660046104cd565b61016c565b604080516fffffffffffffffffffffffffffffffff909316835267ffffffffffffffff909116602083015201610065565b6100c56100c03660046106ca565b61021b565b604051908152602001610065565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f7bfa20a900000000000000000000000000000000000000000000000000000000148061016657507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b92915050565b6040517fda26663a00000000000000000000000000000000000000000000000000000000815263ffffffff821660048201526000908190819073ffffffffffffffffffffffffffffffffffffffff86169063da26663a90602401606060405180830381865afa1580156101e3573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061020791906107a4565b805160209091015190969095509350505050565b600080604161ffff16856080015167ffffffffffffffff1661023d9190610827565b905061024a60208261086d565b156102725761025a60208261086d565b6102649082610881565b61026f906020610894565b90505b60008161028160e06044610894565b61028b9190610894565b610296906040610894565b8651602088015187516040517f88a4124c00000000000000000000000000000000000000000000000000000000815263ffffffff90921660048301526024820184905267ffffffffffffffff166044820152919250600091829173ffffffffffffffffffffffffffffffffffffffff16906388a4124c90606401608060405180830381865afa15801561032d573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061035191906108a7565b9350505091506000876020015161ffff16600014610373578760200151610379565b8860a001515b9050600061271061038e61ffff841686610827565b61039891906108fc565b90506fffffffffffffffffffffffffffffffff831615806103cd575060408901516fffffffffffffffffffffffffffffffff16155b156103df57955061044d945050505050565b6000836fffffffffffffffffffffffffffffffff16670de0b6b3a76400008b604001516fffffffffffffffffffffffffffffffff1661041e9190610827565b61042891906108fc565b6104329086610894565b90508181116104415781610443565b805b9750505050505050505b9392505050565b60006020828403121561046657600080fd5b81357fffffffff000000000000000000000000000000000000000000000000000000008116811461044d57600080fd5b73ffffffffffffffffffffffffffffffffffffffff811681146104b857600080fd5b50565b63ffffffff811681146104b857600080fd5b600080604083850312156104e057600080fd5b82356104eb81610496565b915060208301356104fb816104bb565b809150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040516060810167ffffffffffffffff8111828210171561055857610558610506565b60405290565b60405160c0810167ffffffffffffffff8111828210171561055857610558610506565b67ffffffffffffffff811681146104b857600080fd5b803561ffff811681146105a957600080fd5b919050565b6fffffffffffffffffffffffffffffffff811681146104b857600080fd5b6000606082840312156105de57600080fd5b6105e6610535565b905081356105f381610581565b815261060160208301610597565b60208201526040820135610614816105ae565b604082015292915050565b600082601f83011261063057600080fd5b813567ffffffffffffffff8082111561064b5761064b610506565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190828211818310171561069157610691610506565b816040528381528660208588010111156106aa57600080fd5b836020870160208301376000602085830101528094505050505092915050565b60008060008385036101408112156106e157600080fd5b60c08112156106ef57600080fd5b506106f861055e565b843561070381610496565b81526020850135610713816104bb565b6020820152604085013561072681610581565b6040820152606085013561073981610496565b6060820152608085013561074c81610581565b608082015261075d60a08601610597565b60a082015292506107718560c086016105cc565b915061012084013567ffffffffffffffff81111561078e57600080fd5b61079a8682870161061f565b9150509250925092565b6000606082840312156107b657600080fd5b6107be610535565b82516107c9816105ae565b815260208301516107d981610581565b602082015260408301516107ec816104bb565b60408201529392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8082028115828204841417610166576101666107f8565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60008261087c5761087c61083e565b500690565b81810381811115610166576101666107f8565b80820180821115610166576101666107f8565b600080600080608085870312156108bd57600080fd5b8451935060208501516108cf816105ae565b60408601519093506108e0816105ae565b60608601519092506108f1816105ae565b939692955090935050565b60008261090b5761090b61083e565b50049056fea26469706673582212209a8dfb2589587bcd1bc1d331f28f7a1d728aa04c6e2a53448e9d77836f01c6e864736f6c63430008120033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100415760003560e01c806301ffc9a714610046578063228cdc031461006e5780637bfa20a9146100b2575b600080fd5b610059610054366004610454565b6100d3565b60405190151581526020015b60405180910390f35b61008161007c3660046104cd565b61016c565b604080516fffffffffffffffffffffffffffffffff909316835267ffffffffffffffff909116602083015201610065565b6100c56100c03660046106ca565b61021b565b604051908152602001610065565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f7bfa20a900000000000000000000000000000000000000000000000000000000148061016657507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b92915050565b6040517fda26663a00000000000000000000000000000000000000000000000000000000815263ffffffff821660048201526000908190819073ffffffffffffffffffffffffffffffffffffffff86169063da26663a90602401606060405180830381865afa1580156101e3573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061020791906107a4565b805160209091015190969095509350505050565b600080604161ffff16856080015167ffffffffffffffff1661023d9190610827565b905061024a60208261086d565b156102725761025a60208261086d565b6102649082610881565b61026f906020610894565b90505b60008161028160e06044610894565b61028b9190610894565b610296906040610894565b8651602088015187516040517f88a4124c00000000000000000000000000000000000000000000000000000000815263ffffffff90921660048301526024820184905267ffffffffffffffff166044820152919250600091829173ffffffffffffffffffffffffffffffffffffffff16906388a4124c90606401608060405180830381865afa15801561032d573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061035191906108a7565b9350505091506000876020015161ffff16600014610373578760200151610379565b8860a001515b9050600061271061038e61ffff841686610827565b61039891906108fc565b90506fffffffffffffffffffffffffffffffff831615806103cd575060408901516fffffffffffffffffffffffffffffffff16155b156103df57955061044d945050505050565b6000836fffffffffffffffffffffffffffffffff16670de0b6b3a76400008b604001516fffffffffffffffffffffffffffffffff1661041e9190610827565b61042891906108fc565b6104329086610894565b90508181116104415781610443565b805b9750505050505050505b9392505050565b60006020828403121561046657600080fd5b81357fffffffff000000000000000000000000000000000000000000000000000000008116811461044d57600080fd5b73ffffffffffffffffffffffffffffffffffffffff811681146104b857600080fd5b50565b63ffffffff811681146104b857600080fd5b600080604083850312156104e057600080fd5b82356104eb81610496565b915060208301356104fb816104bb565b809150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040516060810167ffffffffffffffff8111828210171561055857610558610506565b60405290565b60405160c0810167ffffffffffffffff8111828210171561055857610558610506565b67ffffffffffffffff811681146104b857600080fd5b803561ffff811681146105a957600080fd5b919050565b6fffffffffffffffffffffffffffffffff811681146104b857600080fd5b6000606082840312156105de57600080fd5b6105e6610535565b905081356105f381610581565b815261060160208301610597565b60208201526040820135610614816105ae565b604082015292915050565b600082601f83011261063057600080fd5b813567ffffffffffffffff8082111561064b5761064b610506565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190828211818310171561069157610691610506565b816040528381528660208588010111156106aa57600080fd5b836020870160208301376000602085830101528094505050505092915050565b60008060008385036101408112156106e157600080fd5b60c08112156106ef57600080fd5b506106f861055e565b843561070381610496565b81526020850135610713816104bb565b6020820152604085013561072681610581565b6040820152606085013561073981610496565b6060820152608085013561074c81610581565b608082015261075d60a08601610597565b60a082015292506107718560c086016105cc565b915061012084013567ffffffffffffffff81111561078e57600080fd5b61079a8682870161061f565b9150509250925092565b6000606082840312156107b657600080fd5b6107be610535565b82516107c9816105ae565b815260208301516107d981610581565b602082015260408301516107ec816104bb565b60408201529392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8082028115828204841417610166576101666107f8565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60008261087c5761087c61083e565b500690565b81810381811115610166576101666107f8565b80820180821115610166576101666107f8565b600080600080608085870312156108bd57600080fd5b8451935060208501516108cf816105ae565b60408601519093506108e0816105ae565b60608601519092506108f1816105ae565b939692955090935050565b60008261090b5761090b61083e565b50049056fea26469706673582212209a8dfb2589587bcd1bc1d331f28f7a1d728aa04c6e2a53448e9d77836f01c6e864736f6c63430008120033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}