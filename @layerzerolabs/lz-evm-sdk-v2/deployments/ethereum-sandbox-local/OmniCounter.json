{
  "address": "0x39dD11C243Ac4Ac250980FA3AEa016f73C509f37",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_endpoint",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "EndpointOnly",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "addr",
          "type": "bytes32"
        }
      ],
      "name": "InvalidPeer",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidPeerState",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "code",
          "type": "uint16"
        },
        {
          "internalType": "bytes",
          "name": "result",
          "type": "bytes"
        }
      ],
      "name": "LzReceiveRevert",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "eid",
          "type": "uint32"
        }
      ],
      "name": "NoPeerSet",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "PreCrimeOnly",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint16",
              "name": "msgType",
              "type": "uint16"
            },
            {
              "internalType": "uint32",
              "name": "eid",
              "type": "uint32"
            },
            {
              "internalType": "bytes",
              "name": "options",
              "type": "bytes"
            }
          ],
          "indexed": false,
          "internalType": "struct IOApp.EnforcedOptionParam[]",
          "name": "_enforcedOptions",
          "type": "tuple[]"
        }
      ],
      "name": "SetEnforcedOption",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "remoteEid",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "peer",
          "type": "bytes32"
        }
      ],
      "name": "SetPeer",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "precrime",
          "type": "address"
        }
      ],
      "name": "SetPrecrime",
      "type": "event"
    },
    {
      "stateMutability": "payable",
      "type": "fallback"
    },
    {
      "inputs": [],
      "name": "admin",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32[]",
          "name": "_eids",
          "type": "uint32[]"
        },
        {
          "internalType": "uint8[]",
          "name": "_types",
          "type": "uint8[]"
        },
        {
          "internalType": "bytes[]",
          "name": "_options",
          "type": "bytes[]"
        }
      ],
      "name": "batchIncrement",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_eid",
          "type": "uint32"
        },
        {
          "internalType": "uint8",
          "name": "_type",
          "type": "uint8"
        },
        {
          "internalType": "bytes",
          "name": "_options",
          "type": "bytes"
        }
      ],
      "name": "brokenIncrement",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_callData",
          "type": "bytes"
        }
      ],
      "name": "callEndpoint",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "composedCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "count",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "eid",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "endpoint",
      "outputs": [
        {
          "internalType": "contract ILayerZeroEndpointV2",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "srcEid",
          "type": "uint32"
        }
      ],
      "name": "inboundCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "count",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_eid",
          "type": "uint32"
        },
        {
          "internalType": "uint8",
          "name": "_type",
          "type": "uint8"
        },
        {
          "internalType": "bytes",
          "name": "_options",
          "type": "bytes"
        }
      ],
      "name": "increment",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "_message",
          "type": "bytes"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "lzCompose",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "srcEid",
              "type": "uint32"
            },
            {
              "internalType": "bytes32",
              "name": "sender",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "nonce",
              "type": "uint64"
            }
          ],
          "internalType": "struct Origin",
          "name": "_origin",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "_guid",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "_message",
          "type": "bytes"
        },
        {
          "internalType": "address",
          "name": "_executor",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "_extraData",
          "type": "bytes"
        }
      ],
      "name": "lzReceive",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint32",
                  "name": "srcEid",
                  "type": "uint32"
                },
                {
                  "internalType": "bytes32",
                  "name": "sender",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint64",
                  "name": "nonce",
                  "type": "uint64"
                }
              ],
              "internalType": "struct Origin",
              "name": "origin",
              "type": "tuple"
            },
            {
              "internalType": "bytes32",
              "name": "guid",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "message",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "callParams",
              "type": "bytes"
            }
          ],
          "internalType": "struct IPreCrime.Packet[]",
          "name": "_packets",
          "type": "tuple[]"
        }
      ],
      "name": "lzReceiveAndRevert",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_srcEid",
          "type": "uint32"
        },
        {
          "internalType": "bytes32",
          "name": "_sender",
          "type": "bytes32"
        }
      ],
      "name": "nextNonce",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "dstEid",
          "type": "uint32"
        }
      ],
      "name": "outboundCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "count",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "name": "peers",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "precrime",
      "outputs": [
        {
          "internalType": "contract IPreCrime",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_eid",
          "type": "uint32"
        },
        {
          "internalType": "uint8",
          "name": "_type",
          "type": "uint8"
        },
        {
          "internalType": "bytes",
          "name": "_options",
          "type": "bytes"
        }
      ],
      "name": "quote",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "nativeFee",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "zroFee",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_eid",
          "type": "uint32"
        }
      ],
      "name": "safeGetPeer",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "peer",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_admin",
          "type": "address"
        }
      ],
      "name": "setAdmin",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint16",
              "name": "msgType",
              "type": "uint16"
            },
            {
              "internalType": "uint32",
              "name": "eid",
              "type": "uint32"
            },
            {
              "internalType": "bytes",
              "name": "options",
              "type": "bytes"
            }
          ],
          "internalType": "struct IOApp.EnforcedOptionParam[]",
          "name": "_enforcedOptions",
          "type": "tuple[]"
        }
      ],
      "name": "setEnforcedOptions",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bool",
          "name": "_orderedNonce",
          "type": "bool"
        }
      ],
      "name": "setOrderedNonce",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_eid",
          "type": "uint32"
        },
        {
          "internalType": "bytes32",
          "name": "_peer",
          "type": "bytes32"
        }
      ],
      "name": "setPeer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_precrime",
          "type": "address"
        }
      ],
      "name": "setPrecrime",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_srcEid",
          "type": "uint32"
        },
        {
          "internalType": "bytes32",
          "name": "_sender",
          "type": "bytes32"
        },
        {
          "internalType": "uint64",
          "name": "_nonce",
          "type": "uint64"
        }
      ],
      "name": "skipInboundNonce",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "version",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address payable",
          "name": "_to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        }
      ],
      "name": "withdraw",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0x44ea6808dda256393f135aab284f53ddedf7931517c67a93a7b15b66c5b82674",
  "receipt": {
    "to": null,
    "from": "0x14dC79964da2C08b23698B3D3cc7Ca32193d9955",
    "contractAddress": "0x39dD11C243Ac4Ac250980FA3AEa016f73C509f37",
    "transactionIndex": 0,
    "gasUsed": "2939388",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000001000000000400000000000000000000000000020000000000000000000800000000000000000000000000000002400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002100000000000000000000000000000000000000000000000000000000000000040000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xf7415617d5ffcac80ef4e6728d01ced1d0f4c4cc13fefc1cb0fed1cad6147056",
    "transactionHash": "0x44ea6808dda256393f135aab284f53ddedf7931517c67a93a7b15b66c5b82674",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 218,
        "transactionHash": "0x44ea6808dda256393f135aab284f53ddedf7931517c67a93a7b15b66c5b82674",
        "address": "0x39dD11C243Ac4Ac250980FA3AEa016f73C509f37",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x00000000000000000000000014dc79964da2c08b23698b3d3cc7ca32193d9955"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0xf7415617d5ffcac80ef4e6728d01ced1d0f4c4cc13fefc1cb0fed1cad6147056"
      }
    ],
    "blockNumber": 218,
    "cumulativeGasUsed": "2939388",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x1275D096B9DBf2347bD2a131Fb6BDaB0B4882487"
  ],
  "numDeployments": 1,
  "solcInputHash": "7b29806b85282df4a83b429384afd158",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_endpoint\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"EndpointOnly\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"addr\",\"type\":\"bytes32\"}],\"name\":\"InvalidPeer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPeerState\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"code\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"name\":\"LzReceiveRevert\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"eid\",\"type\":\"uint32\"}],\"name\":\"NoPeerSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"PreCrimeOnly\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"msgType\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"eid\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"}],\"indexed\":false,\"internalType\":\"struct IOApp.EnforcedOptionParam[]\",\"name\":\"_enforcedOptions\",\"type\":\"tuple[]\"}],\"name\":\"SetEnforcedOption\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"remoteEid\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"peer\",\"type\":\"bytes32\"}],\"name\":\"SetPeer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"precrime\",\"type\":\"address\"}],\"name\":\"SetPrecrime\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"_eids\",\"type\":\"uint32[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_types\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_options\",\"type\":\"bytes[]\"}],\"name\":\"batchIncrement\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_eid\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"_options\",\"type\":\"bytes\"}],\"name\":\"brokenIncrement\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_callData\",\"type\":\"bytes\"}],\"name\":\"callEndpoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"composedCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"count\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eid\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endpoint\",\"outputs\":[{\"internalType\":\"contract ILayerZeroEndpointV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"srcEid\",\"type\":\"uint32\"}],\"name\":\"inboundCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_eid\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"_options\",\"type\":\"bytes\"}],\"name\":\"increment\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"lzCompose\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"srcEid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"internalType\":\"struct Origin\",\"name\":\"_origin\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"_guid\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_executor\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"lzReceive\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"srcEid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"internalType\":\"struct Origin\",\"name\":\"origin\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"guid\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callParams\",\"type\":\"bytes\"}],\"internalType\":\"struct IPreCrime.Packet[]\",\"name\":\"_packets\",\"type\":\"tuple[]\"}],\"name\":\"lzReceiveAndRevert\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_srcEid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_sender\",\"type\":\"bytes32\"}],\"name\":\"nextNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"dstEid\",\"type\":\"uint32\"}],\"name\":\"outboundCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"peers\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"precrime\",\"outputs\":[{\"internalType\":\"contract IPreCrime\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_eid\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"_options\",\"type\":\"bytes\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nativeFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"zroFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_eid\",\"type\":\"uint32\"}],\"name\":\"safeGetPeer\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"peer\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"msgType\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"eid\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"}],\"internalType\":\"struct IOApp.EnforcedOptionParam[]\",\"name\":\"_enforcedOptions\",\"type\":\"tuple[]\"}],\"name\":\"setEnforcedOptions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_orderedNonce\",\"type\":\"bool\"}],\"name\":\"setOrderedNonce\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_eid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_peer\",\"type\":\"bytes32\"}],\"name\":\"setPeer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_precrime\",\"type\":\"address\"}],\"name\":\"setPrecrime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_srcEid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"skipInboundNonce\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"callEndpoint(bytes)\":{\"details\":\"a generic interface to set the endpoint configthis is a low level interface, and should be used with cautionuse our SDK to generate the properly abi.encoded config\"},\"lzReceive((uint32,bytes32,uint64),bytes32,bytes,address,bytes)\":{\"details\":\"Oapp can override this interface for custom logics (e.g. more assertion)\"},\"lzReceiveAndRevert(((uint32,bytes32,uint64),bytes32,bytes,bytes)[])\":{\"details\":\"a generic interface for precrime simulationsthis function reverts at the end with the simulation resultsvalue is provided as a lump sum, does not restrict how much each packet can consume\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"safeGetPeer(uint32)\":{\"details\":\"check non-zero peer and return it\"},\"setPeer(uint32,bytes32)\":{\"details\":\"set _peer to bytes32(0) (the default value) to \\\"untrust\\\"\"},\"setPrecrime(address)\":{\"details\":\"set the precrime contract. can upgrade the precrime implementation overtime\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/examples/OmniCounter.sol\":\"OmniCounter\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":20000},\"remappings\":[]},\"sources\":{\"@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/libs/VerifierOptions.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"solidity-bytes-utils/contracts/BytesLib.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/BitMaps.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Errors.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol\\\";\\n\\nlibrary VerifierOptions {\\n    using BitMaps for BitMaps.BitMap256;\\n    using CalldataBytesLib for bytes;\\n    using BytesLib for bytes;\\n\\n    uint8 internal constant WORKER_ID = 2;\\n    uint8 internal constant OPTION_TYPE_PRECRIME = 1;\\n\\n    /// @dev group verifier options by its idx\\n    /// @param _options [verifier_id][verifier_option][verifier_id][verifier_option]...\\n    ///        verifier_option = [option_size][verifier_idx][option_type][option]\\n    ///        option_size = len(verifier_idx) + len(option_type) + len(option)\\n    ///        verifier_id: uint8, verifier_idx: uint8, option_size: uint16, option_type: uint8, option: bytes\\n    /// @return verifierOptions the grouped options, still share the same format of _options\\n    /// @return verifierIndices the verifier indices\\n    function groupVerifierOptionsByIdx(\\n        bytes memory _options\\n    ) internal pure returns (bytes[] memory verifierOptions, uint8[] memory verifierIndices) {\\n        if (_options.length == 0) return (verifierOptions, verifierIndices);\\n\\n        uint8 numVerifiers = getNumVerifiers(_options);\\n\\n        // if there is only 1 verifier, we can just return the whole options\\n        if (numVerifiers == 1) {\\n            verifierOptions = new bytes[](1);\\n            verifierOptions[0] = _options;\\n\\n            verifierIndices = new uint8[](1);\\n            verifierIndices[0] = _options.toUint8(3); // verifier idx\\n            return (verifierOptions, verifierIndices);\\n        }\\n\\n        // otherwise, we need to group the options by verifier_idx\\n        verifierIndices = new uint8[](numVerifiers);\\n        verifierOptions = new bytes[](numVerifiers);\\n        unchecked {\\n            uint cursor;\\n            uint start;\\n            uint8 lastVerifierIdx = 255; // 255 is an invalid verifier_idx\\n\\n            while (cursor < _options.length) {\\n                ++cursor; // skip worker_id\\n\\n                uint16 optionLength = _options.toUint16(cursor);\\n                cursor += 2;\\n                require(optionLength >= 2, Errors.INVALID_SIZE); // at least 1 byte for option_type and 1 byte for verifier_idx\\n\\n                uint8 verifierIdx = _options.toUint8(cursor);\\n\\n                if (lastVerifierIdx == 255) {\\n                    lastVerifierIdx = verifierIdx;\\n                }\\n\\n                // verifierIdx must equal to the lastVerifierIdx for the first option\\n                // so it is always skipped in the first option\\n                // this operation slices out options whenever the the scan finds a different lastVerifierIdx\\n                if (verifierIdx != lastVerifierIdx) {\\n                    uint size = cursor - start - 3; // 3 is for worker_id and option_length\\n                    bytes memory op = _options.slice(start, size);\\n                    _insertVerifierOptions(verifierOptions, verifierIndices, lastVerifierIdx, op);\\n\\n                    // reset the start and lastVerifierIdx\\n                    start += size;\\n                    lastVerifierIdx = verifierIdx;\\n                }\\n\\n                cursor += optionLength;\\n\\n                // if we have reached the end of the options, we need to process the last verifier\\n                if (cursor == _options.length) {\\n                    uint size = cursor - start;\\n                    bytes memory op = _options.slice(start, size);\\n                    _insertVerifierOptions(verifierOptions, verifierIndices, verifierIdx, op);\\n                }\\n            }\\n            require(cursor == _options.length, Errors.INVALID_SIZE);\\n\\n            // revert verifierIndices to start from 0\\n            for (uint8 i = 0; i < numVerifiers; ++i) {\\n                --verifierIndices[i];\\n            }\\n        }\\n    }\\n\\n    function _insertVerifierOptions(\\n        bytes[] memory _verifierOptions,\\n        uint8[] memory _verifierIndices,\\n        uint8 _verifierIdx,\\n        bytes memory _newOptions\\n    ) internal pure {\\n        // verifierIdx starts from 0 but default value of verifierIndices is 0, so we tell if the slot is empty by adding 1 to verifierIdx\\n        require(_verifierIdx < 255, Errors.INVALID_VERIFIERS);\\n        uint8 verifierIdxAdj = _verifierIdx + 1;\\n\\n        for (uint8 j = 0; j < _verifierIndices.length; ++j) {\\n            uint8 index = _verifierIndices[j];\\n            if (verifierIdxAdj == index) {\\n                _verifierOptions[j] = abi.encodePacked(_verifierOptions[j], _newOptions);\\n                break;\\n            } else if (index == 0) {\\n                // empty slot, that means it is the first time we see this verifier\\n                _verifierIndices[j] = verifierIdxAdj;\\n                _verifierOptions[j] = _newOptions;\\n                break;\\n            }\\n        }\\n    }\\n\\n    /// @dev get the number of unique verifiers\\n    /// @param _options the format is the same as groupVerifierOptionsByIdx\\n    function getNumVerifiers(bytes memory _options) internal pure returns (uint8 numVerifiers) {\\n        uint cursor;\\n        BitMaps.BitMap256 bitmap;\\n\\n        // find number of unique verifier_idx\\n        unchecked {\\n            while (cursor < _options.length) {\\n                ++cursor; // skip worker_id\\n\\n                uint16 optionLength = _options.toUint16(cursor);\\n                cursor += 2;\\n                require(optionLength >= 2, Errors.INVALID_SIZE); // at least 1 byte for verifier_idx and 1 byte for option_type\\n\\n                uint8 verifierIdx = _options.toUint8(cursor);\\n\\n                // verifierIdx starts from 0, add one for bitmap check/set\\n                require(verifierIdx < 255, Errors.INVALID_VERIFIERS);\\n                uint8 verifierIdxAdj = verifierIdx + 1;\\n\\n                // if verifierIdx is not set, increment numVerifiers\\n                if (!bitmap.get(verifierIdxAdj)) {\\n                    ++numVerifiers;\\n                    bitmap = bitmap.set(verifierIdxAdj);\\n                }\\n\\n                cursor += optionLength;\\n            }\\n        }\\n        require(cursor == _options.length, Errors.INVALID_SIZE);\\n    }\\n\\n    /// @dev decode the next verifier option from _options starting from the specified cursor\\n    /// @param _options the format is the same as groupVerifierOptionsByIdx\\n    /// @param _cursor the cursor to start decoding\\n    /// @return optionType the type of the option\\n    /// @return option the option\\n    /// @return cursor the cursor to start decoding the next option\\n    function nextVerifierOption(\\n        bytes calldata _options,\\n        uint _cursor\\n    ) internal pure returns (uint8 optionType, bytes calldata option, uint cursor) {\\n        unchecked {\\n            // skip worker id\\n            cursor = _cursor + 1;\\n\\n            // read option size\\n            uint16 size = _options.toU16(cursor);\\n            cursor += 2;\\n\\n            // read option type\\n            optionType = _options.toU8(cursor + 1); // skip verifier_idx\\n\\n            // startCursor and endCursor are used to slice the option from _options\\n            uint startCursor = cursor + 2; // skip option type and verifier_idx\\n            uint endCursor = cursor + size;\\n            option = _options[startCursor:endCursor];\\n            cursor += size;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x64ce5ceb89a26cdcddd34f2d90838cc41de88beb510c810247648de085492b31\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/MessagingStructs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\nstruct PacketForQuote {\\n    address sender;\\n    uint32 dstEid;\\n    bytes message;\\n}\\n\\nstruct Packet {\\n    uint64 nonce;\\n    uint32 srcEid;\\n    address sender;\\n    uint32 dstEid;\\n    bytes32 receiver;\\n    bytes32 guid;\\n    bytes message;\\n}\\n\\nstruct Origin {\\n    uint32 srcEid;\\n    bytes32 sender;\\n    uint64 nonce;\\n}\\n\",\"keccak256\":\"0x8a4a8eba63ff7313aee2d476b643fd05ec13e91fa0a7cea1b9af0f0d04aee645\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroComposer.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\ninterface ILayerZeroComposer {\\n    function lzCompose(\\n        address _receiver,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        address _caller,\\n        bytes calldata _extraData\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0x3e7e7e659a2e469eb7b0961d5bc36884a284e0a7b6b66230db7b72217b65f5df\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IMessageLibManager.sol\\\";\\nimport \\\"./IMessagingComposer.sol\\\";\\nimport \\\"./IMessagingChannel.sol\\\";\\nimport \\\"./IMessagingContext.sol\\\";\\nimport {Origin} from \\\"../MessagingStructs.sol\\\";\\n\\nstruct MessagingParams {\\n    uint32 dstEid;\\n    bytes32 receiver;\\n    bytes message;\\n    bytes options;\\n}\\n\\nstruct MessagingReceipt {\\n    bytes32 guid;\\n    uint64 nonce;\\n    MessagingFee fee;\\n}\\n\\nstruct MessagingFee {\\n    uint nativeFee;\\n    uint lzTokenFee;\\n}\\n\\ninterface ILayerZeroEndpointV2 is IMessageLibManager, IMessagingComposer, IMessagingChannel, IMessagingContext {\\n    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);\\n\\n    event PacketDelivered(Origin origin, address receiver, bytes32 payloadHash);\\n\\n    event PacketReceived(Origin origin, address receiver);\\n\\n    event LzReceiveFailed(Origin origin, address receiver, bytes reason);\\n\\n    event FeePaid(MessagingFee fee);\\n\\n    event LayerZeroTokenSet(address token);\\n\\n    function quote(\\n        address _sender,\\n        uint32 _dstEid,\\n        bytes calldata _message,\\n        bool _payInLzToken,\\n        bytes calldata _options\\n    ) external view returns (MessagingFee memory);\\n\\n    function send(\\n        MessagingParams calldata _params,\\n        uint _lzTokenFee,\\n        address payable _refundAddress\\n    ) external payable returns (MessagingReceipt memory);\\n\\n    function sendWithAlt(\\n        MessagingParams calldata _params,\\n        uint _lzTokenFee,\\n        uint _altTokenFee\\n    ) external returns (MessagingReceipt memory);\\n\\n    function deliver(Origin calldata _origin, address _receiver, bytes32 _payloadHash) external;\\n\\n    function deliverable(Origin calldata _origin, address _receiveLib, address _receiver) external view returns (bool);\\n\\n    function lzReceive(\\n        Origin calldata _origin,\\n        address _receiver,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        bytes calldata _extraData\\n    ) external payable returns (bool, bytes memory);\\n\\n    // oapp can burn messages partially by calling this function with its own business logic if messages are delivered in order\\n    function clear(Origin calldata _origin, bytes32 _guid, bytes calldata _message) external;\\n\\n    function setLayerZeroToken(address _layerZeroToken) external;\\n\\n    function layerZeroToken() external view returns (address);\\n\\n    function altFeeToken() external view returns (address);\\n}\\n\",\"keccak256\":\"0xd28654aeb9c0baf8ca04418b0e5af31a4d1b6e7a3d59ad54e57919bb241dffb3\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\nimport {Origin} from \\\"../MessagingStructs.sol\\\";\\n\\ninterface ILayerZeroReceiver {\\n    function nextNonce(uint32 _eid, bytes32 _sender) external view returns (uint64);\\n\\n    function lzReceive(\\n        Origin calldata _origin,\\n        bytes32 _guid,\\n        bytes memory _message,\\n        address _executor,\\n        bytes calldata _extraData\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0xf2f6095c492980f567f32950a8e033579642fb238e7e8fffd08143ff8fa652b3\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\nstruct SetConfigParam {\\n    uint32 configType;\\n    bytes config;\\n}\\n\\ninterface IMessageLibManager {\\n    struct Timeout {\\n        address lib;\\n        uint expiry;\\n    }\\n\\n    event LibraryRegistered(address newLib);\\n    event DefaultSendLibrarySet(uint32 eid, address newLib);\\n    event DefaultReceiveLibrarySet(uint32 eid, address oldLib, address newLib);\\n    event DefaultReceiveLibraryTimeoutSet(uint32 eid, address oldLib, uint expiry);\\n    event SendLibrarySet(address sender, uint32 eid, address newLib);\\n    event ReceiveLibrarySet(address receiver, uint32 eid, address oldLib, address newLib);\\n    event ReceiveLibraryTimoutSet(address receiver, uint32 eid, address oldLib, uint timeout);\\n\\n    function registerLibrary(address _lib) external;\\n\\n    function isRegisteredLibrary(address _lib) external view returns (bool);\\n\\n    function getRegisteredLibraries() external view returns (address[] memory);\\n\\n    function setDefaultSendLibrary(uint32 _eid, address _newLib) external;\\n\\n    function defaultSendLibrary(uint32 _eid) external view returns (address);\\n\\n    function setDefaultReceiveLibrary(uint32 _eid, address _newLib, uint _timeout) external;\\n\\n    function defaultReceiveLibrary(uint32 _eid) external view returns (address);\\n\\n    function setDefaultReceiveLibraryTimeout(uint32 _eid, address _lib, uint _expiry) external;\\n\\n    function defaultReceiveLibraryTimeout(uint32 _eid) external view returns (address lib, uint expiry);\\n\\n    function defaultConfig(address _lib, uint32 _eid, uint32 _configType) external view returns (bytes memory);\\n\\n    function isSupportedEid(uint32 _eid) external view returns (bool);\\n\\n    /// ------------------- OApp interfaces -------------------\\n    function setSendLibrary(uint32 _eid, address _newLib) external;\\n\\n    function getSendLibrary(address _sender, uint32 _eid) external view returns (address lib);\\n\\n    function isDefaultSendLibrary(address _sender, uint32 _eid) external view returns (bool);\\n\\n    function setReceiveLibrary(uint32 _eid, address _newLib, uint _gracePeriod) external;\\n\\n    function getReceiveLibrary(address _receiver, uint32 _eid) external view returns (address lib, bool isDefault);\\n\\n    function setReceiveLibraryTimeout(uint32 _eid, address _lib, uint _gracePeriod) external;\\n\\n    function receiveLibraryTimeout(address _receiver, uint32 _eid) external view returns (address lib, uint expiry);\\n\\n    function setConfig(address _lib, uint32 _eid, SetConfigParam[] calldata _params) external;\\n\\n    function getConfig(\\n        address _oapp,\\n        address _lib,\\n        uint32 _eid,\\n        uint32 _configType\\n    ) external view returns (bytes memory config, bool isDefault);\\n\\n    function snapshotConfig(address _lib, uint32[] calldata _eids) external;\\n\\n    function resetConfig(address _lib, uint32[] calldata _eids) external;\\n}\\n\",\"keccak256\":\"0xf5a21fd6499c96c7cd5998a3c4cb6bea41ff3ec1be212dfdac368d428803091f\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessagingChannel {\\n    event InboundNonceSkipped(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce);\\n\\n    function eid() external view returns (uint32);\\n\\n    // this is an emergency function if a message can not be delivered for some reasons\\n    // required to provide _nextNonce to avoid race condition\\n    function skip(uint32 _srcEid, bytes32 _sender, uint64 _nonce) external;\\n\\n    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32);\\n\\n    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\\n\\n    function outboundNonce(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (uint64);\\n\\n    function inboundPayloadHash(\\n        address _receiver,\\n        uint32 _srcEid,\\n        bytes32 _sender,\\n        uint64 _nonce\\n    ) external view returns (bytes32);\\n\\n    function hasPayloadHash(\\n        address _receiver,\\n        uint32 _srcEid,\\n        bytes32 _sender,\\n        uint64 _nonce\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xe9c180ca201e8af11747079224729e0552addf70d65c60e7a61a4624a28d4e5c\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingComposer.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessagingComposer {\\n    event ComposedMessageDelivered(address receiver, address composer, bytes32 guid, bytes message);\\n    event ComposedMessageReceived(\\n        address receiver,\\n        address composer,\\n        bytes32 guid,\\n        bytes32 messageHash,\\n        address caller\\n    );\\n    event LzComposeFailed(\\n        address sender,\\n        address receiver,\\n        bytes32 guid,\\n        bytes32 messageHash,\\n        address caller,\\n        bytes reason\\n    );\\n\\n    function deliverComposedMessage(address _composer, bytes32 _guid, bytes calldata _message) external;\\n\\n    function lzCompose(\\n        address _receiver,\\n        address _composer,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        bytes calldata _extraData\\n    ) external payable returns (bool, bytes memory);\\n}\\n\",\"keccak256\":\"0x3993726690a51a8660c2145d3d1483e03d93de7a578afc4130467bf6804f6896\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingContext.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessagingContext {\\n    function isSendingMessage() external view returns (bool);\\n\\n    function getSendContext() external view returns (uint32, address);\\n}\\n\",\"keccak256\":\"0x6af87d5d41d060363fe554ff0ce9138f1ad8e20c1aaeec777d4132fc505e74e8\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nlibrary CalldataBytesLib {\\n    function toU8(bytes calldata _bytes, uint _start) internal pure returns (uint8) {\\n        return uint8(_bytes[_start]);\\n    }\\n\\n    function toU16(bytes calldata _bytes, uint _start) internal pure returns (uint16) {\\n        unchecked {\\n            uint end = _start + 2;\\n            return uint16(bytes2(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toU32(bytes calldata _bytes, uint _start) internal pure returns (uint32) {\\n        unchecked {\\n            uint end = _start + 4;\\n            return uint32(bytes4(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toU64(bytes calldata _bytes, uint _start) internal pure returns (uint64) {\\n        unchecked {\\n            uint end = _start + 8;\\n            return uint64(bytes8(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toU128(bytes calldata _bytes, uint _start) internal pure returns (uint128) {\\n        unchecked {\\n            uint end = _start + 16;\\n            return uint128(bytes16(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toU256(bytes calldata _bytes, uint _start) internal pure returns (uint256) {\\n        unchecked {\\n            uint end = _start + 32;\\n            return uint256(bytes32(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toAddr(bytes calldata _bytes, uint _start) internal pure returns (address) {\\n        unchecked {\\n            uint end = _start + 20;\\n            return address(bytes20(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toB32(bytes calldata _bytes, uint _start) internal pure returns (bytes32) {\\n        unchecked {\\n            uint end = _start + 32;\\n            return bytes32(_bytes[_start:end]);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6984a7e7f292ec4533ac684583e5d0505bee3bc4348776072413ceb521a6acc8\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Errors {\\n    // Invalid Argument (http: 400)\\n    string internal constant INVALID_ARGUMENT = \\\"LZ10000\\\";\\n    string internal constant ONLY_REGISTERED = \\\"LZ10001\\\";\\n    string internal constant ONLY_REGISTERED_OR_DEFAULT = \\\"LZ10002\\\";\\n    string internal constant INVALID_AMOUNT = \\\"LZ10003\\\";\\n    string internal constant INVALID_NONCE = \\\"LZ10004\\\";\\n    string internal constant SAME_VALUE = \\\"LZ10005\\\";\\n    string internal constant UNSORTED = \\\"LZ10006\\\";\\n    string internal constant INVALID_VERSION = \\\"LZ10007\\\";\\n    string internal constant INVALID_EID = \\\"LZ10008\\\";\\n    string internal constant INVALID_SIZE = \\\"LZ10009\\\";\\n    string internal constant ONLY_NON_DEFAULT = \\\"LZ10010\\\";\\n    string internal constant INVALID_VERIFIERS = \\\"LZ10011\\\";\\n    string internal constant DUPLICATED = \\\"LZ10012\\\";\\n    string internal constant INVALID_WORKER_ID = \\\"LZ10013\\\";\\n\\n    // Out of Range (http: 400)\\n    string internal constant OUT_OF_RANGE = \\\"LZ20000\\\";\\n\\n    // Invalid State (http: 400)\\n    string internal constant INVALID_STATE = \\\"LZ30000\\\";\\n    string internal constant SEND_REENTRANCY = \\\"LZ30001\\\";\\n    string internal constant RECEIVE_REENTRANCY = \\\"LZ30002\\\";\\n    string internal constant COMPOSE_REENTRANCY = \\\"LZ30003\\\";\\n\\n    // Permission Denied (http: 403)\\n    string internal constant PERMISSION_DENIED = \\\"LZ50000\\\";\\n\\n    // Not Found (http: 404)\\n    string internal constant NOT_FOUND = \\\"LZ60000\\\";\\n\\n    // Already Exists (http: 409)\\n    string internal constant ALREADY_EXISTS = \\\"LZ80000\\\";\\n\\n    // Not Implemented (http: 501)\\n    string internal constant NOT_IMPLEMENTED = \\\"LZC0000\\\";\\n    string internal constant UNSUPPORTED_INTERFACE = \\\"LZC0001\\\";\\n\\n    // Unavailable (http: 503)\\n    string internal constant UNAVAILABLE = \\\"LZD0000\\\";\\n    string internal constant NATIVE_COIN_UNAVAILABLE = \\\"LZD0001\\\";\\n    string internal constant TOKEN_UNAVAILABLE = \\\"LZD0002\\\";\\n    string internal constant DEFAULT_LIBRARY_UNAVAILABLE = \\\"LZD0003\\\";\\n    string internal constant VERIFIERS_UNAVAILABLE = \\\"LZD0004\\\";\\n}\\n\",\"keccak256\":\"0x00c68dee6968a14fa9a120a7447a3f568379c86f2a59d363e902128d4f361a6e\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/BitMaps.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\n// modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/BitMaps.sol\\npragma solidity ^0.8.19;\\n\\nlibrary BitMaps {\\n    type BitMap256 is uint;\\n\\n    /**\\n     * @dev Returns whether the bit at `index` is set.\\n     */\\n    function get(BitMap256 bitmap, uint8 index) internal pure returns (bool) {\\n        uint256 mask = 1 << (index & 0xff);\\n        return BitMap256.unwrap(bitmap) & mask != 0;\\n    }\\n\\n    /**\\n     * @dev Sets the bit at `index`.\\n     */\\n    function set(BitMap256 bitmap, uint8 index) internal pure returns (BitMap256) {\\n        uint256 mask = 1 << (index & 0xff);\\n        return BitMap256.wrap(BitMap256.unwrap(bitmap) | mask);\\n    }\\n}\\n\",\"keccak256\":\"0x29b1fb7dda9d3d6a699938da8610c0aa58d2eeb4244c6889a657eaf24117ac8e\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/ExecutorOptions.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../libs/Errors.sol\\\";\\nimport \\\"../../libs/CalldataBytesLib.sol\\\";\\n\\nlibrary ExecutorOptions {\\n    using CalldataBytesLib for bytes;\\n\\n    uint8 internal constant WORKER_ID = 1;\\n\\n    uint8 internal constant OPTION_TYPE_LZRECEIVE = 1;\\n    uint8 internal constant OPTION_TYPE_AIRDROP = 2;\\n    uint8 internal constant OPTION_TYPE_LZCOMPOSE = 3;\\n    uint8 internal constant OPTION_TYPE_ORDERED_EXECUTION = 4;\\n\\n    /// @dev decode the next executor option from the options starting from the specified cursor\\n    /// @param _options [executor_id][executor_option][executor_id][executor_option]...\\n    ///        executor_option = [option_size][option_type][option]\\n    ///        option_size = len(option_type) + len(option)\\n    ///        executor_id: uint8, option_size: uint16, option_type: uint8, option: bytes\\n    /// @param _cursor the cursor to start decoding from\\n    /// @return optionType the type of the option\\n    /// @return option the option of the executor\\n    /// @return cursor the cursor to start decoding the next executor option\\n    function nextExecutorOption(\\n        bytes calldata _options,\\n        uint _cursor\\n    ) internal pure returns (uint8 optionType, bytes calldata option, uint cursor) {\\n        unchecked {\\n            // skip worker id\\n            cursor = _cursor + 1;\\n\\n            // read option size\\n            uint16 size = _options.toU16(cursor);\\n            cursor += 2;\\n\\n            // read option type\\n            optionType = _options.toU8(cursor);\\n\\n            // startCursor and endCursor are used to slice the option from _options\\n            uint startCursor = cursor + 1; // skip option type and verifier_idx\\n            uint endCursor = cursor + size;\\n            option = _options[startCursor:endCursor];\\n            cursor += size;\\n        }\\n    }\\n\\n    function decodeLzReceiveOption(bytes calldata _option) internal pure returns (uint128 gas, uint128 value) {\\n        require(_option.length == 16 || _option.length == 32, Errors.INVALID_SIZE);\\n        gas = _option.toU128(0);\\n        value = _option.length == 32 ? _option.toU128(16) : 0;\\n    }\\n\\n    function decodeAirdropOption(bytes calldata _option) internal pure returns (uint128 amount, bytes32 receiver) {\\n        require(_option.length == 48, Errors.INVALID_SIZE);\\n        amount = _option.toU128(0);\\n        receiver = _option.toB32(16);\\n    }\\n\\n    function decodeLzComposeOption(bytes calldata _option) internal pure returns (uint128 gas, uint128 value) {\\n        require(_option.length == 16 || _option.length == 32, Errors.INVALID_SIZE);\\n        gas = _option.toU128(0);\\n        value = _option.length == 32 ? _option.toU128(16) : 0;\\n    }\\n\\n    function encodeLzReceiveOption(uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\\n        return _value == 0 ? abi.encodePacked(_gas) : abi.encodePacked(_gas, _value);\\n    }\\n\\n    function encodeAirdropOption(uint128 _amount, bytes32 _receiver) internal pure returns (bytes memory) {\\n        return abi.encodePacked(_amount, _receiver);\\n    }\\n\\n    function encodeLzComposeOption(uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\\n        return _value == 0 ? abi.encodePacked(_gas) : abi.encodePacked(_gas, _value);\\n    }\\n}\\n\",\"keccak256\":\"0x2d317c33c60f628c83625a2622a76891789b7388b06596564bd08ae6af11058a\",\"license\":\"BUSL-1.1\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xba43b97fba0d32eb4254f6a5a297b39a19a247082a02d6e69349e071e2946218\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x52a8cfb0f5239d11b457dcdd1b326992ef672714ca8da71a157255bddd13f3ad\",\"license\":\"MIT\"},\"contracts/OApp.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {Origin} from \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/MessagingStructs.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./interfaces/IOApp.sol\\\";\\nimport \\\"./interfaces/IPreCrime.sol\\\";\\n\\n/// @dev the template class for OApps. Refer to the OmniCounter for examples\\nabstract contract OApp is IOApp, Ownable {\\n    /// @dev we version the OApp to version the OApp Behaviours (e.g. future version might have different precrime interfaces)\\n    uint public constant override version = 1;\\n    ILayerZeroEndpointV2 public immutable endpoint;\\n    mapping(uint32 => bytes32) public peers;\\n\\n    // @dev These enforced options can vary as the potential options/execution on remote may differ\\n    // eg. Amount of lzReceive gas necessary to deliver a composed message adds overhear you dont want to pay\\n    // if you are only make a standard crosschain call (no deliver compose)\\n    // enforcedOptions[eid][executionType] = enforcedOptions\\n    // The \\\"msgType\\\" should be defined in the child contract\\n    mapping(uint32 eid => mapping(uint16 msgType => bytes)) internal enforcedOptions;\\n\\n    IPreCrime public precrime;\\n\\n    constructor(address _endpoint) {\\n        endpoint = ILayerZeroEndpointV2(_endpoint);\\n    }\\n\\n    function setEnforcedOptions(EnforcedOptionParam[] calldata _enforcedOptions) public virtual onlyOwner {\\n        for (uint i = 0; i < _enforcedOptions.length; i++) {\\n            enforcedOptions[_enforcedOptions[i].eid][_enforcedOptions[i].msgType] = _enforcedOptions[i].options;\\n        }\\n\\n        emit SetEnforcedOption(_enforcedOptions);\\n    }\\n\\n    /// @dev the generic send interface to interact with the LayerZero EndpointV2.quote()\\n    function _quote(\\n        uint32 _eid,\\n        bytes memory _message,\\n        bool _useLZToken,\\n        bytes memory _options\\n    ) internal view virtual returns (uint nativeFee, uint lzTokenFee) {\\n        MessagingFee memory fee = endpoint.quote(address(this), _eid, _message, _useLZToken, _options);\\n        return (fee.nativeFee, fee.lzTokenFee);\\n    }\\n\\n    /// @dev the generic send interface to interact with the LayerZero EndpointV2.send()\\n    function _lzSend(\\n        MessagingParams memory _msgParams,\\n        MessagingFee memory _fee,\\n        address payable _refundAddress\\n    ) internal virtual returns (MessagingReceipt memory) {\\n        MessagingReceipt memory receipt = endpoint.send{value: _fee.nativeFee}(\\n            _msgParams,\\n            _fee.lzTokenFee,\\n            _refundAddress\\n        );\\n        return receipt;\\n    }\\n\\n    /// @dev Oapp can override this interface for custom logics (e.g. more assertion)\\n    function lzReceive(\\n        Origin calldata _origin,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        address _executor,\\n        bytes calldata _extraData\\n    ) public payable virtual {\\n        // assert the call is from the endpoint\\n        if (address(endpoint) != msg.sender) revert EndpointOnly(msg.sender);\\n        // assert that it is from a trusted peer\\n        if (safeGetPeer(_origin.srcEid) != _origin.sender) revert InvalidPeer(_origin.sender);\\n        // assert that the nonce is acceptable\\n        _acceptNonce(_origin.srcEid, _origin.sender, _origin.nonce);\\n\\n        // perform the state transition logic\\n        _lzReceive(_origin, _guid, _message, _executor, _extraData);\\n    }\\n\\n    /// @dev needs to be implemented by the OApp\\n    /// @dev basic security checks are already performed\\n    function _lzReceive(\\n        Origin calldata _origin,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        address _executor,\\n        bytes calldata _extraData\\n    ) internal virtual;\\n\\n    /// @dev a generic interface for precrime simulations\\n    /// @dev this function reverts at the end with the simulation results\\n    /// @dev value is provided as a lump sum, does not restrict how much each packet can consume\\n    function lzReceiveAndRevert(IPreCrime.Packet[] calldata _packets) external payable virtual override {\\n        if (address(precrime) != msg.sender) revert PreCrimeOnly(msg.sender);\\n\\n        for (uint i = 0; i < _packets.length; i++) {\\n            IPreCrime.Packet calldata packet = _packets[i];\\n            bytes32 peer = safeGetPeer(packet.origin.srcEid);\\n            if (peer != packet.origin.sender) {\\n                // packet from untrusted peer cannot be lzReceived, hence cannot change state\\n                continue;\\n            }\\n            // don't need to accept nonce, as by precrime protocol, all packets are sorted\\n            _lzReceive(packet.origin, packet.guid, packet.message, msg.sender, packet.callParams);\\n        }\\n        revert IPreCrime.LzReceiveRevert(1, precrime.simulationCallback());\\n    }\\n\\n    /// @dev path nonce starts from 1. if 0 it means that there is no specific nonce enforcement\\n    /// @dev only used to guide the executor actions if the app specify the msg execution to be ordered.\\n    function nextNonce(uint32 /*_srcEid*/, bytes32 /*_sender*/) public view virtual returns (uint64) {\\n        return 0;\\n    }\\n\\n    /// @dev if the app wants to enforce ordered execution, it should override this function to return the correct value\\n    /// @dev check OmniCounter for example\\n    function _acceptNonce(uint32 /*_srcEid*/, bytes32 /*_sender*/, uint64 /*_nonce*/) internal virtual {\\n        // do nth by default\\n    }\\n\\n    /// @dev receive native tokens. this might be used for the endpoint to refund\\n    receive() external payable virtual {}\\n\\n    /// ----------------------------- OAPP Config Functions -----------------------------\\n\\n    /// @dev set _peer to bytes32(0) (the default value) to \\\"untrust\\\"\\n    function setPeer(uint32 _eid, bytes32 _peer) public virtual onlyOwner {\\n        if (peers[_eid] == _peer) revert InvalidPeerState();\\n        peers[_eid] = _peer;\\n        emit SetPeer(_eid, _peer);\\n    }\\n\\n    /// @dev check non-zero peer and return it\\n    function safeGetPeer(uint32 _eid) public view virtual returns (bytes32 peer) {\\n        peer = peers[_eid];\\n        if (peer == bytes32(0)) revert NoPeerSet(_eid);\\n    }\\n\\n    /// @dev set the precrime contract. can upgrade the precrime implementation overtime\\n    function setPrecrime(address _precrime) external onlyOwner {\\n        precrime = IPreCrime(_precrime);\\n        emit SetPrecrime(_precrime);\\n    }\\n\\n    /// @dev a generic interface to set the endpoint config\\n    /// @dev this is a low level interface, and should be used with caution\\n    /// @dev use our SDK to generate the properly abi.encoded config\\n    function callEndpoint(bytes calldata _callData) public virtual onlyOwner {\\n        bytes4 functionSig = bytes4(_callData);\\n        require(\\n            functionSig == IMessageLibManager.setConfig.selector ||\\n                functionSig == IMessageLibManager.snapshotConfig.selector ||\\n                functionSig == IMessageLibManager.resetConfig.selector ||\\n                functionSig == IMessageLibManager.setReceiveLibrary.selector ||\\n                functionSig == IMessageLibManager.setSendLibrary.selector ||\\n                functionSig == IMessageLibManager.setReceiveLibraryTimeout.selector ||\\n                functionSig == ILayerZeroEndpointV2.clear.selector ||\\n                functionSig == IMessagingChannel.skip.selector,\\n            \\\"OApp: function not allowed\\\"\\n        );\\n\\n        (bool success, bytes memory reason) = address(endpoint).call(_callData);\\n        if (!success) {\\n            assembly {\\n                revert(add(reason, 32), mload(reason))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0c7cca227fdc21ef8d8a2d9e159ae55274b1dca6e83011b8efb702d969265dca\",\"license\":\"MIT\"},\"contracts/examples/OmniCounter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../OApp.sol\\\";\\nimport \\\"../libs/OptionsBuilder.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroComposer.sol\\\";\\nimport {Origin} from \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/MessagingStructs.sol\\\";\\n\\nlibrary MsgCodec {\\n    uint8 internal constant VANILLA_TYPE = 1;\\n    uint8 internal constant COMPOSED_TYPE = 2;\\n    uint8 internal constant ABA_TYPE = 3;\\n    uint8 internal constant COMPOSED_ABA_TYPE = 4;\\n\\n    uint8 internal constant MSG_TYPE_OFFSET = 0;\\n    uint8 internal constant SRC_EID_OFFSET = 1;\\n\\n    function encode(uint8 _type, uint32 _srcEid) internal pure returns (bytes memory) {\\n        return abi.encodePacked(_type, _srcEid);\\n    }\\n\\n    function msgType(bytes calldata _message) internal pure returns (uint8) {\\n        return uint8(bytes1(_message[MSG_TYPE_OFFSET:SRC_EID_OFFSET]));\\n    }\\n\\n    function srcEid(bytes calldata _message) internal pure returns (uint32) {\\n        return uint32(bytes4(_message[SRC_EID_OFFSET:]));\\n    }\\n}\\n\\ncontract OmniCounter is ILayerZeroComposer, OApp {\\n    using MsgCodec for bytes;\\n    using OptionsBuilder for bytes;\\n\\n    uint public count;\\n    uint public composedCount;\\n\\n    address public admin;\\n    uint32 public eid;\\n\\n    mapping(uint32 srcEid => mapping(bytes32 sender => uint64 nonce)) private maxReceivedNonce;\\n    bool private orderedNonce;\\n\\n    // for global assertions\\n    mapping(uint32 srcEid => uint count) public inboundCount;\\n    mapping(uint32 dstEid => uint count) public outboundCount;\\n\\n    constructor(address _endpoint) OApp(_endpoint) {\\n        admin = msg.sender;\\n        eid = endpoint.eid();\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"only admin\\\");\\n        _;\\n    }\\n\\n    // -------------------------------\\n    // Only Admin\\n    function setAdmin(address _admin) external onlyAdmin {\\n        admin = _admin;\\n    }\\n\\n    function withdraw(address payable _to, uint _amount) external onlyAdmin {\\n        _to.transfer(_amount);\\n    }\\n\\n    // -------------------------------\\n    // Send\\n    function increment(uint32 _eid, uint8 _type, bytes calldata _options) external payable {\\n        _lzSend(\\n            MessagingParams(_eid, safeGetPeer(_eid), MsgCodec.encode(_type, eid), _options),\\n            MessagingFee(msg.value, 0),\\n            payable(msg.sender)\\n        );\\n        _incrementOutbound(_eid);\\n    }\\n\\n    // this is a broken function to skip incrementing outbound count\\n    // so that precrime will fail\\n    function brokenIncrement(uint32 _eid, uint8 _type, bytes calldata _options) external payable onlyAdmin {\\n        _lzSend(\\n            MessagingParams(_eid, safeGetPeer(_eid), MsgCodec.encode(_type, eid), _options),\\n            MessagingFee(msg.value, 0),\\n            payable(msg.sender)\\n        );\\n    }\\n\\n    function batchIncrement(\\n        uint32[] calldata _eids,\\n        uint8[] calldata _types,\\n        bytes[] calldata _options\\n    ) external payable {\\n        require(_eids.length == _options.length && _eids.length == _types.length, \\\"OmniCounter: length mismatch\\\");\\n\\n        MessagingReceipt memory receipt;\\n        uint providedFee = msg.value;\\n        for (uint i = 0; i < _eids.length; i++) {\\n            address refundAddress = i == _eids.length - 1 ? msg.sender : address(this);\\n            receipt = _lzSend(\\n                MessagingParams(_eids[i], safeGetPeer(_eids[i]), MsgCodec.encode(_types[i], eid), _options[i]),\\n                MessagingFee(providedFee, 0),\\n                payable(refundAddress)\\n            );\\n            _incrementOutbound(_eids[i]);\\n            providedFee -= receipt.fee.nativeFee;\\n        }\\n    }\\n\\n    // -------------------------------\\n    // View\\n    function quote(\\n        uint32 _eid,\\n        uint8 _type,\\n        bytes calldata _options\\n    ) public view returns (uint nativeFee, uint zroFee) {\\n        return _quote(_eid, MsgCodec.encode(_type, eid), false, _options);\\n    }\\n\\n    // -------------------------------\\n    // Receive\\n    function _lzReceive(\\n        Origin calldata _origin,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        address /*_executor*/,\\n        bytes calldata /*_extraData*/\\n    ) internal override {\\n        uint8 messageType = _message.msgType();\\n\\n        if (messageType == MsgCodec.VANILLA_TYPE) {\\n            count++;\\n            _incrementInbound(_origin.srcEid);\\n        } else if (messageType == MsgCodec.COMPOSED_TYPE || messageType == MsgCodec.COMPOSED_ABA_TYPE) {\\n            count++;\\n            _incrementInbound(_origin.srcEid);\\n            endpoint.deliverComposedMessage(address(this), _guid, _message);\\n        } else if (messageType == MsgCodec.ABA_TYPE) {\\n            count++;\\n            _incrementInbound(_origin.srcEid);\\n\\n            // send back to the sender\\n            _incrementOutbound(_origin.srcEid);\\n            bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200000, 0);\\n            _lzSend(\\n                MessagingParams(\\n                    _origin.srcEid,\\n                    safeGetPeer(_origin.srcEid),\\n                    MsgCodec.encode(MsgCodec.VANILLA_TYPE, eid),\\n                    options\\n                ),\\n                MessagingFee(msg.value, 0),\\n                payable(address(this))\\n            );\\n        } else {\\n            revert(\\\"invalid message type\\\");\\n        }\\n    }\\n\\n    function _incrementInbound(uint32 _srcEid) internal {\\n        inboundCount[_srcEid]++;\\n    }\\n\\n    function _incrementOutbound(uint32 _dstEid) internal {\\n        outboundCount[_dstEid]++;\\n    }\\n\\n    function lzCompose(\\n        address /*_oapp*/,\\n        bytes32 /*_guid*/,\\n        bytes calldata _message,\\n        address,\\n        bytes calldata\\n    ) external payable override {\\n        require(msg.sender == address(endpoint), \\\"!endpoint\\\");\\n\\n        uint8 msgType = _message.msgType();\\n        if (msgType == MsgCodec.COMPOSED_TYPE) {\\n            composedCount += 1;\\n        } else if (msgType == MsgCodec.COMPOSED_ABA_TYPE) {\\n            composedCount += 1;\\n\\n            uint32 srcEid = _message.srcEid();\\n            _incrementOutbound(srcEid);\\n            bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200000, 0);\\n            _lzSend(\\n                MessagingParams(srcEid, safeGetPeer(srcEid), MsgCodec.encode(MsgCodec.VANILLA_TYPE, eid), options),\\n                MessagingFee(msg.value, 0),\\n                payable(address(this))\\n            );\\n        } else {\\n            revert(\\\"invalid message type\\\");\\n        }\\n    }\\n\\n    // -------------------------------\\n    // Ordered OApp\\n    // this demonstrates how to build an app that requires execution nonce ordering\\n    // normally an app should decide ordered or not on contract construction\\n    // this is just a demo\\n    function setOrderedNonce(bool _orderedNonce) external onlyOwner {\\n        orderedNonce = _orderedNonce;\\n    }\\n\\n    function _acceptNonce(uint32 _srcEid, bytes32 _sender, uint64 _nonce) internal virtual override {\\n        uint64 currentNonce = maxReceivedNonce[_srcEid][_sender];\\n        if (orderedNonce) {\\n            require(_nonce == currentNonce + 1, \\\"OApp: invalid nonce\\\");\\n        }\\n        // update the max nonce anyway. once the ordered mode is turned on, missing early nonces will be rejected\\n        if (_nonce > currentNonce) {\\n            maxReceivedNonce[_srcEid][_sender] = _nonce;\\n        }\\n    }\\n\\n    function nextNonce(uint32 _srcEid, bytes32 _sender) public view virtual override returns (uint64) {\\n        if (orderedNonce) {\\n            return maxReceivedNonce[_srcEid][_sender] + 1;\\n        } else {\\n            return 0; // path nonce starts from 1. if 0 it means that there is no specific nonce enforcement\\n        }\\n    }\\n\\n    // a governance function to skip nonce\\n    function skipInboundNonce(uint32 _srcEid, bytes32 _sender, uint64 _nonce) public virtual onlyOwner {\\n        endpoint.skip(_srcEid, _sender, _nonce);\\n        if (orderedNonce) {\\n            maxReceivedNonce[_srcEid][_sender]++;\\n        }\\n    }\\n\\n    // be able to receive ether\\n    fallback() external payable {}\\n}\\n\",\"keccak256\":\"0xb1f0f546754248f670ec55473b2702b82142a80dfa829a1e3aafa7d319afb2ce\",\"license\":\"MIT\"},\"contracts/interfaces/IOApp.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol\\\";\\nimport \\\"./IPreCrime.sol\\\";\\n\\ninterface IOApp is ILayerZeroReceiver {\\n    struct EnforcedOptionParam {\\n        uint16 msgType;\\n        uint32 eid;\\n        bytes options;\\n    }\\n\\n    event SetEnforcedOption(EnforcedOptionParam[] _enforcedOptions);\\n\\n    function callEndpoint(bytes calldata _callData) external;\\n\\n    function nextNonce(uint32 _srcEid, bytes32 _sender) external view returns (uint64);\\n\\n    function version() external view returns (uint);\\n\\n    function lzReceiveAndRevert(IPreCrime.Packet[] calldata _packets) external payable;\\n\\n    error EndpointOnly(address addr);\\n    error PreCrimeOnly(address addr);\\n    error InvalidPeer(bytes32 addr);\\n    error InvalidPeerState();\\n    error NoPeerSet(uint32 eid);\\n\\n    event SetPeer(uint32 remoteEid, bytes32 peer);\\n    event SetPrecrime(address precrime);\\n}\\n\",\"keccak256\":\"0x715c1da9d496a4c2892c4cb93864658df74f24a6001e259cc02634ec1a5d93d4\",\"license\":\"MIT\"},\"contracts/interfaces/IPreCrime.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport {Origin} from \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/MessagingStructs.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol\\\";\\n\\ninterface IPreCrime {\\n    error LzReceiveRevert(uint16 code, bytes result);\\n\\n    struct Packet {\\n        Origin origin;\\n        bytes32 guid;\\n        bytes message;\\n        bytes callParams;\\n    }\\n\\n    function getPrecrimeConfig(Packet[] calldata _packets) external view returns (bytes memory);\\n\\n    function precrime(\\n        Packet[] calldata _packets,\\n        bytes[] calldata _simulation\\n    ) external view returns (uint16 code, bytes memory reason);\\n\\n    function precrimeVersion() external view returns (uint16);\\n\\n    function simulate(Packet[] calldata _packets) external payable returns (uint16 code, bytes memory result);\\n\\n    function simulateView(Packet[] calldata _packets) external view returns (uint16 code, bytes memory result);\\n\\n    function simulationCallback() external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x007ebfe122841988a7a33576e52675bab7ea61fd6b05fd2a504d8429aa0d87e4\",\"license\":\"MIT\"},\"contracts/libs/OptionsBuilder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/ExecutorOptions.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/libs/VerifierOptions.sol\\\";\\n\\nlibrary OptionsBuilder {\\n    using SafeCast for uint;\\n    using BytesLib for bytes;\\n\\n    uint16 internal constant TYPE_1 = 1; // legacy options type 1\\n    uint16 internal constant TYPE_2 = 2; // legacy options type 2\\n    uint16 internal constant TYPE_3 = 3;\\n\\n    modifier onlyType3(bytes memory _options) {\\n        require(_options.toUint16(0) == TYPE_3, \\\"OptionsBuilder: invalid options type\\\");\\n        _;\\n    }\\n\\n    function newOptions() internal pure returns (bytes memory) {\\n        return abi.encodePacked(TYPE_3);\\n    }\\n\\n    function addExecutorLzReceiveOption(\\n        bytes memory _options,\\n        uint128 _gas,\\n        uint128 _value\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        bytes memory option = ExecutorOptions.encodeLzReceiveOption(_gas, _value);\\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZRECEIVE, option);\\n    }\\n\\n    function addExecutorAirdropOption(\\n        bytes memory _options,\\n        uint128 _amount,\\n        bytes32 _receiver\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        bytes memory option = ExecutorOptions.encodeAirdropOption(_amount, _receiver);\\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_AIRDROP, option);\\n    }\\n\\n    function addExecutorLzComposeOption(\\n        bytes memory _options,\\n        uint128 _gas,\\n        uint128 _value\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        bytes memory option = ExecutorOptions.encodeLzComposeOption(_gas, _value);\\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZCOMPOSE, option);\\n    }\\n\\n    function addExecutorOrderedExecutionOption(\\n        bytes memory _options\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_ORDERED_EXECUTION, bytes(\\\"\\\"));\\n    }\\n\\n    function addVerifierPrecrimeOption(\\n        bytes memory _options,\\n        uint8 _verifierIdx\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        return addVerifierOption(_options, _verifierIdx, VerifierOptions.OPTION_TYPE_PRECRIME, bytes(\\\"\\\"));\\n    }\\n\\n    function addExecutorOption(\\n        bytes memory _options,\\n        uint8 _optionType,\\n        bytes memory _option\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                _options,\\n                ExecutorOptions.WORKER_ID,\\n                _option.length.toUint16() + 1, // +1 for optionType\\n                _optionType,\\n                _option\\n            );\\n    }\\n\\n    function addVerifierOption(\\n        bytes memory _options,\\n        uint8 _verifierIdx,\\n        uint8 _optionType,\\n        bytes memory _option\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                _options,\\n                VerifierOptions.WORKER_ID,\\n                _option.length.toUint16() + 2, // +2 for optionType and verifierIdx\\n                _verifierIdx,\\n                _optionType,\\n                _option\\n            );\\n    }\\n\\n    function encodeLegacyOptionsType1(uint _executionGas) internal pure returns (bytes memory) {\\n        require(_executionGas <= type(uint128).max, Errors.INVALID_SIZE);\\n        return abi.encodePacked(TYPE_1, _executionGas);\\n    }\\n\\n    function encodeLegacyOptionsType2(\\n        uint _executionGas,\\n        uint _amount,\\n        bytes memory _receiver // use bytes instead of bytes32 in legacy type 2\\n    ) internal pure returns (bytes memory) {\\n        require(\\n            _executionGas <= type(uint128).max && _amount <= type(uint128).max && _receiver.length <= 32,\\n            Errors.INVALID_SIZE\\n        );\\n        return abi.encodePacked(TYPE_2, _executionGas, _amount, _receiver);\\n    }\\n}\\n\",\"keccak256\":\"0xb0b9666bd73151ace3988bf55c2c20317e7b8eca7182b174e0c7a7e48005174a\",\"license\":\"MIT\"},\"solidity-bytes-utils/contracts/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\\u00e7alo S\\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity >=0.8.0 <0.9.0;\\n\\n\\nlibrary BytesLib {\\n    function concat(\\n        bytes memory _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(0x40, and(\\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n              not(31) // Round down to the nearest 32 bytes.\\n            ))\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes.slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes.slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                                ),\\n                                // and now shift left the number of bytes to\\n                                // leave space for the length in the slot\\n                                exp(0x100, sub(32, newlength))\\n                            ),\\n                            // increase length by the double of the memory\\n                            // bytes length\\n                            mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(\\n                    sc,\\n                    add(\\n                        and(\\n                            fslot,\\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\\n                        ),\\n                        and(mload(mc), mask)\\n                    )\\n                )\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let mlengthmod := mod(mlength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n                for {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_bytes.length >= _start + 1 , \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\n        require(_bytes.length >= _start + 2, \\\"toUint16_outOfBounds\\\");\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\\n        require(_bytes.length >= _start + 4, \\\"toUint32_outOfBounds\\\");\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\\n        require(_bytes.length >= _start + 8, \\\"toUint64_outOfBounds\\\");\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\\n        require(_bytes.length >= _start + 12, \\\"toUint96_outOfBounds\\\");\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\\n        require(_bytes.length >= _start + 16, \\\"toUint128_outOfBounds\\\");\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n        require(_bytes.length >= _start + 32, \\\"toUint256_outOfBounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n        require(_bytes.length >= _start + 32, \\\"toBytes32_outOfBounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                // the next line is the loop condition:\\n                // while(uint256(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(\\n        bytes storage _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes.slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes.slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint256(mc < end) + cb == 2)\\n                        for {} eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n}\\n\",\"keccak256\":\"0xf75784dfc94ea43668eb195d5690a1dde1b6eda62017e73a3899721583821d29\",\"license\":\"Unlicense\"}},\"version\":1}",
  "bytecode": "0x60a06040523480156200001157600080fd5b506040516200358038038062003580833981016040819052620000349162000139565b806200004033620000e9565b6001600160a01b03166080819052600680546001600160a01b031916331790556040805163416ecebf60e01b8152905163416ecebf916004808201926020929091908290030181865afa1580156200009c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620000c291906200016b565b600660146101000a81548163ffffffff021916908363ffffffff1602179055505062000193565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6000602082840312156200014c57600080fd5b81516001600160a01b03811681146200016457600080fd5b9392505050565b6000602082840312156200017e57600080fd5b815163ffffffff811681146200016457600080fd5b6080516133a0620001e0600039600081816103450152818161073901528181610cd601528181611012015281816115c401528181611c4801528181611e7301526120a301526133a06000f3fe6080604052600436106101b95760003560e01c8063715018a6116100eb578063c95c55be1161008f578063f2fde38b11610061578063f2fde38b1461057a578063f3fef3a31461059a578063f5c6ba5a146105ba578063f851a440146105cd57005b8063c95c55be146104ff578063d0a1026014610512578063d22446ce14610525578063dbcd3b911461055a57005b8063950c8a74116100c8578063950c8a7414610472578063b7abbb5d1461049f578063baf3292d146104b2578063bb0b6a53146104d257005b8063715018a6146103f95780637d25a05e1461040e5780638da5cb5b1461044757005b8063542e7b561161015d5780635e280f111161012f5780635e280f1114610333578063622f17f61461038c578063704b6c02146103b95780637112f86f146103d957005b8063542e7b56146102be57806354fd4d50146102d157806356a47289146102e65780635b849af61461031357005b8063257f4e0511610196578063257f4e051461021e57806326b27f84146102345780633400288b14610254578063416ecebf1461027457005b806306661abd146101c2578063107a93d6146101eb57806313137d651461020b57005b366101c057005b005b3480156101ce57600080fd5b506101d860045481565b6040519081526020015b60405180910390f35b3480156101f757600080fd5b506101c06102063660046124b3565b6105fa565b6101c0610219366004612559565b610737565b34801561022a57600080fd5b506101d860055481565b34801561024057600080fd5b506101d861024f366004612614565b610841565b34801561026057600080fd5b506101c061026f36600461262f565b61089b565b34801561028057600080fd5b506006546102a99074010000000000000000000000000000000000000000900463ffffffff1681565b60405163ffffffff90911681526020016101e2565b6101c06102cc366004612659565b610940565b3480156102dd57600080fd5b506101d8600181565b3480156102f257600080fd5b506101d8610301366004612614565b60096020526000908152604090205481565b34801561031f57600080fd5b506101c061032e3660046126f3565b610b82565b34801561033f57600080fd5b506103677f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016101e2565b34801561039857600080fd5b506101d86103a7366004612614565b600a6020526000908152604090205481565b3480156103c557600080fd5b506101c06103d4366004612715565b610bbb565b3480156103e557600080fd5b506101c06103f4366004612748565b610c83565b34801561040557600080fd5b506101c0610db7565b34801561041a57600080fd5b5061042e61042936600461262f565b610dcb565b60405167ffffffffffffffff90911681526020016101e2565b34801561045357600080fd5b5060005473ffffffffffffffffffffffffffffffffffffffff16610367565b34801561047e57600080fd5b506003546103679073ffffffffffffffffffffffffffffffffffffffff1681565b6101c06104ad366004612799565b610e20565b3480156104be57600080fd5b506101c06104cd366004612715565b610ece565b3480156104de57600080fd5b506101d86104ed366004612614565b60016020526000908152604090205481565b6101c061050d366004612799565b610f4f565b6101c06105203660046127fa565b610ffa565b34801561053157600080fd5b50610545610540366004612799565b61127c565b604080519283526020830191909152016101e2565b34801561056657600080fd5b506101c061057536600461287b565b6112ea565b34801561058657600080fd5b506101c0610595366004612715565b61165d565b3480156105a657600080fd5b506101c06105b53660046128b1565b611714565b6101c06105c83660046124b3565b6117d8565b3480156105d957600080fd5b506006546103679073ffffffffffffffffffffffffffffffffffffffff1681565b6106026119ac565b60005b818110156106f95782828281811061061f5761061f6128cf565b905060200281019061063191906128fe565b61063f90604081019061293c565b60026000868686818110610655576106556128cf565b905060200281019061066791906128fe565b610678906040810190602001612614565b63ffffffff1663ffffffff16815260200190815260200160002060008686868181106106a6576106a66128cf565b90506020028101906106b891906128fe565b6106c69060208101906129b3565b61ffff1681526020810191909152604001600020916106e6919083612a9e565b50806106f181612be7565b915050610605565b507f0548419a320c116408d237dae51da66dc63603dfd20bd99ba0c8be4c5ff7a200828260405161072b929190612c68565b60405180910390a15050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1633146107ad576040517fab08c09e0000000000000000000000000000000000000000000000000000000081523360048201526024015b60405180910390fd5b602087018035906107c29061024f908a612614565b146107ff576040517fc59a4f64000000000000000000000000000000000000000000000000000000008152602088013560048201526024016107a4565b61082961080f6020890189612614565b602089013561082460608b0160408c01612da6565b611a2d565b61083887878787878787611b63565b50505050505050565b63ffffffff811660009081526001602052604090205480610896576040517f196fb6c000000000000000000000000000000000000000000000000000000000815263ffffffff831660048201526024016107a4565b919050565b6108a36119ac565b63ffffffff82166000908152600160205260409020548190036108f2576040517f9556766100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b63ffffffff8216600081815260016020908152604091829020849055815192835282018390527fd81b9101f39c530fa8f18e6c9c5a64e4a3d7cb699e959f5d7abb5951c65e318f910161072b565b848114801561094e57508483145b6109b4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f4f6d6e69436f756e7465723a206c656e677468206d69736d617463680000000060448201526064016107a4565b6109bc61241f565b3460005b87811015610b775760006109d560018a612dc3565b82146109e157306109e3565b335b9050610b2060405180608001604052808c8c86818110610a0557610a056128cf565b9050602002016020810190610a1a9190612614565b63ffffffff168152602001610a4f8d8d87818110610a3a57610a3a6128cf565b905060200201602081019061024f9190612614565b8152602001610aa48b8b87818110610a6957610a696128cf565b9050602002016020810190610a7e9190612dd6565b60065474010000000000000000000000000000000000000000900463ffffffff16611dab565b8152602001888886818110610abb57610abb6128cf565b9050602002810190610acd919061293c565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920182905250939094525050604080518082019091528781526020810191909152905083611e24565b9350610b518a8a84818110610b3757610b376128cf565b9050602002016020810190610b4c9190612614565b611ef6565b604084015151610b619084612dc3565b9250508080610b6f90612be7565b9150506109c0565b505050505050505050565b610b8a6119ac565b600880547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016911515919091179055565b60065473ffffffffffffffffffffffffffffffffffffffff163314610c3c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f6f6e6c792061646d696e0000000000000000000000000000000000000000000060448201526064016107a4565b600680547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b610c8b6119ac565b6040517feaeacd6300000000000000000000000000000000000000000000000000000000815263ffffffff841660048201526024810183905267ffffffffffffffff821660448201527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169063eaeacd6390606401600060405180830381600087803b158015610d2f57600080fd5b505af1158015610d43573d6000803e3d6000fd5b505060085460ff16159150610db290505763ffffffff831660009081526007602090815260408083208584529091528120805467ffffffffffffffff1691610d8a83612df1565b91906101000a81548167ffffffffffffffff021916908367ffffffffffffffff160217905550505b505050565b610dbf6119ac565b610dc96000611f1f565b565b60085460009060ff1615610e165763ffffffff83166000908152600760209081526040808320858452909152902054610e0f9067ffffffffffffffff166001612e18565b9050610e1a565b5060005b92915050565b610ebe60405180608001604052808663ffffffff168152602001610e4387610841565b8152602001610e6486600660149054906101000a900463ffffffff16611dab565b815260200184848080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920182905250939094525050604080518082019091523481526020810191909152905033611e24565b50610ec884611ef6565b50505050565b610ed66119ac565b600380547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040519081527f5db758e995a17ec1ad84bdef7e8c3293a0bd6179bcce400dff5d4c3d87db726b9060200160405180910390a150565b60065473ffffffffffffffffffffffffffffffffffffffff163314610fd0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f6f6e6c792061646d696e0000000000000000000000000000000000000000000060448201526064016107a4565b610ff360405180608001604052808663ffffffff168152602001610e4387610841565b5050505050565b3373ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001614611099576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f21656e64706f696e74000000000000000000000000000000000000000000000060448201526064016107a4565b60006110a58686611f94565b90507ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe60ff8216016110ef576001600560008282546110e49190612e40565b909155506112729050565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc60ff8216016112105760016005600082825461112c9190612e40565b909155506000905061113e8787611fb6565b905061114981611ef6565b600061119c62030d406000611195604080517e03000000000000000000000000000000000000000000000000000000000000602082015281516002818303018152602290910190915290565b9190611fd8565b905061120860405180608001604052808463ffffffff1681526020016111c185610841565b81526020016111e36001600660149054906101000a900463ffffffff16611dab565b8152602001838152506040518060400160405280348152602001600081525030611e24565b505050611272565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f696e76616c6964206d657373616765207479706500000000000000000000000060448201526064016107a4565b5050505050505050565b6000806112dd8661129f87600660149054906101000a900463ffffffff16611dab565b600087878080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061209c92505050565b9150915094509492505050565b6112f26119ac565b60006112fe8284612e53565b90507fffffffff0000000000000000000000000000000000000000000000000000000081167fb8007ff600000000000000000000000000000000000000000000000000000000148061139157507fffffffff0000000000000000000000000000000000000000000000000000000081167f9e7fffcc00000000000000000000000000000000000000000000000000000000145b806113dd57507fffffffff0000000000000000000000000000000000000000000000000000000081167f0678327f00000000000000000000000000000000000000000000000000000000145b8061142957507fffffffff0000000000000000000000000000000000000000000000000000000081167fb8849ac900000000000000000000000000000000000000000000000000000000145b8061147557507fffffffff0000000000000000000000000000000000000000000000000000000081167fe16f964d00000000000000000000000000000000000000000000000000000000145b806114c157507fffffffff0000000000000000000000000000000000000000000000000000000081167f66bf43d600000000000000000000000000000000000000000000000000000000145b8061150d57507fffffffff0000000000000000000000000000000000000000000000000000000081167f965183d400000000000000000000000000000000000000000000000000000000145b8061155957507fffffffff0000000000000000000000000000000000000000000000000000000081167feaeacd6300000000000000000000000000000000000000000000000000000000145b6115bf576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f4f4170703a2066756e6374696f6e206e6f7420616c6c6f77656400000000000060448201526064016107a4565b6000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff168585604051611609929190612e9b565b6000604051808303816000865af19150503d8060008114611646576040519150601f19603f3d011682016040523d82523d6000602084013e61164b565b606091505b509150915081610ff357805160208201fd5b6116656119ac565b73ffffffffffffffffffffffffffffffffffffffff8116611708576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f646472657373000000000000000000000000000000000000000000000000000060648201526084016107a4565b61171181611f1f565b50565b60065473ffffffffffffffffffffffffffffffffffffffff163314611795576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f6f6e6c792061646d696e0000000000000000000000000000000000000000000060448201526064016107a4565b60405173ffffffffffffffffffffffffffffffffffffffff83169082156108fc029083906000818181858888f19350505050158015610db2573d6000803e3d6000fd5b60035473ffffffffffffffffffffffffffffffffffffffff16331461182b576040517fc023811c0000000000000000000000000000000000000000000000000000000081523360048201526024016107a4565b60005b818110156118c15736838383818110611849576118496128cf565b905060200281019061185b9190612eab565b9050600061186f61024f6020840184612614565b9050602082013581146118835750506118af565b6118ac826060810135611899608083018361293c565b336118a760a089018961293c565b611b63565b50505b806118b981612be7565b91505061182e565b50600354604080517fd2968d57000000000000000000000000000000000000000000000000000000008152905160019273ffffffffffffffffffffffffffffffffffffffff169163d2968d579160048083019260009291908290030181865afa158015611932573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682016040526119789190810190612f03565b6040517f0a78da8f0000000000000000000000000000000000000000000000000000000081526004016107a4929190613018565b60005473ffffffffffffffffffffffffffffffffffffffff163314610dc9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016107a4565b63ffffffff8316600090815260076020908152604080832085845290915290205460085467ffffffffffffffff9091169060ff1615611aed57611a71816001612e18565b67ffffffffffffffff168267ffffffffffffffff1614611aed576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f4f4170703a20696e76616c6964206e6f6e63650000000000000000000000000060448201526064016107a4565b8067ffffffffffffffff168267ffffffffffffffff161115610ec85763ffffffff841660009081526007602090815260408083208684529091529020805467ffffffffffffffff84167fffffffffffffffffffffffffffffffffffffffffffffffff000000000000000090911617905550505050565b6000611b6f8686611f94565b90507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60ff821601611bcb5760048054906000611bab83612be7565b90915550611bc69050611bc160208a018a612614565b612158565b611272565b60ff811660021480611be0575060ff81166004145b15611cba5760048054906000611bf583612be7565b90915550611c0b9050611bc160208a018a612614565b6040517f754d3b9c00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063754d3b9c90611c839030908b908b908b9060040161303d565b600060405180830381600087803b158015611c9d57600080fd5b505af1158015611cb1573d6000803e3d6000fd5b50505050611272565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd60ff8216016112105760048054906000611cf483612be7565b90915550611d0a9050611bc160208a018a612614565b611d1a610b4c60208a018a612614565b6000611d6662030d406000611195604080517e03000000000000000000000000000000000000000000000000000000000000602082015281516002818303018152602290910190915290565b6040805160808101909152909150611da49080611d8660208d018d612614565b63ffffffff1681526020908101906111c19061024f908e018e612614565b5050611272565b6040517fff0000000000000000000000000000000000000000000000000000000000000060f884901b1660208201527fffffffff0000000000000000000000000000000000000000000000000000000060e083901b1660218201526060906025015b604051602081830303815290604052905092915050565b611e2c61241f565b825160208401516040517faca1b45a00000000000000000000000000000000000000000000000000000000815260009273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169263aca1b45a92611eaa918a918990600401613073565b60806040518083038185885af1158015611ec8573d6000803e3d6000fd5b50505050506040513d601f19601f82011682018060405250810190611eed9190613161565b95945050505050565b63ffffffff81166000908152600a60205260408120805491611f1783612be7565b919050555050565b6000805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6000611fa360018284866131c9565b611fac916131f3565b60f81c9392505050565b6000611fc582600181866131c9565b611fce91612e53565b60e01c9392505050565b6060836003611fe8826000612179565b61ffff1614612078576040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526024808201527f4f7074696f6e734275696c6465723a20696e76616c6964206f7074696f6e732060448201527f747970650000000000000000000000000000000000000000000000000000000060648201526084016107a4565b600061208485856121f9565b9050612092866001836122a0565b9695505050505050565b60008060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166383c4755930898989896040518663ffffffff1660e01b8152600401612102959493929190613239565b6040805180830381865afa15801561211e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612142919061329a565b8051602090910151909890975095505050505050565b63ffffffff81166000908152600960205260408120805491611f1783612be7565b6000612186826002612e40565b835110156121f0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f746f55696e7431365f6f75744f66426f756e647300000000000000000000000060448201526064016107a4565b50016002015190565b60606fffffffffffffffffffffffffffffffff82161561226257604080517fffffffffffffffffffffffffffffffff00000000000000000000000000000000608086811b8216602084015285901b16603082015201604051602081830303815290604052612299565b6040517fffffffffffffffffffffffffffffffff00000000000000000000000000000000608085901b166020820152603001611e0d565b9392505050565b60608360036122b0826000612179565b61ffff1614612340576040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526024808201527f4f7074696f6e734275696c6465723a20696e76616c6964206f7074696f6e732060448201527f747970650000000000000000000000000000000000000000000000000000000060648201526084016107a4565b84600161234d8551612387565b6123589060016132b6565b868660405160200161236e9594939291906132d1565b6040516020818303038152906040529150509392505050565b600061ffff82111561241b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f53616665436173743a2076616c756520646f65736e27742066697420696e203160448201527f362062697473000000000000000000000000000000000000000000000000000060648201526084016107a4565b5090565b604051806060016040528060008019168152602001600067ffffffffffffffff168152602001612462604051806040016040528060008152602001600081525090565b905290565b60008083601f84011261247957600080fd5b50813567ffffffffffffffff81111561249157600080fd5b6020830191508360208260051b85010111156124ac57600080fd5b9250929050565b600080602083850312156124c657600080fd5b823567ffffffffffffffff8111156124dd57600080fd5b6124e985828601612467565b90969095509350505050565b60008083601f84011261250757600080fd5b50813567ffffffffffffffff81111561251f57600080fd5b6020830191508360208285010111156124ac57600080fd5b73ffffffffffffffffffffffffffffffffffffffff8116811461171157600080fd5b600080600080600080600087890360e081121561257557600080fd5b606081121561258357600080fd5b5087965060608801359550608088013567ffffffffffffffff808211156125a957600080fd5b6125b58b838c016124f5565b909750955060a08a013591506125ca82612537565b90935060c089013590808211156125e057600080fd5b506125ed8a828b016124f5565b989b979a50959850939692959293505050565b803563ffffffff8116811461089657600080fd5b60006020828403121561262657600080fd5b61229982612600565b6000806040838503121561264257600080fd5b61264b83612600565b946020939093013593505050565b6000806000806000806060878903121561267257600080fd5b863567ffffffffffffffff8082111561268a57600080fd5b6126968a838b01612467565b909850965060208901359150808211156126af57600080fd5b6126bb8a838b01612467565b909650945060408901359150808211156126d457600080fd5b506126e189828a01612467565b979a9699509497509295939492505050565b60006020828403121561270557600080fd5b8135801515811461229957600080fd5b60006020828403121561272757600080fd5b813561229981612537565b67ffffffffffffffff8116811461171157600080fd5b60008060006060848603121561275d57600080fd5b61276684612600565b925060208401359150604084013561277d81612732565b809150509250925092565b803560ff8116811461089657600080fd5b600080600080606085870312156127af57600080fd5b6127b885612600565b93506127c660208601612788565b9250604085013567ffffffffffffffff8111156127e257600080fd5b6127ee878288016124f5565b95989497509550505050565b600080600080600080600060a0888a03121561281557600080fd5b873561282081612537565b965060208801359550604088013567ffffffffffffffff8082111561284457600080fd5b6128508b838c016124f5565b909750955060608a0135915061286582612537565b909350608089013590808211156125e057600080fd5b6000806020838503121561288e57600080fd5b823567ffffffffffffffff8111156128a557600080fd5b6124e9858286016124f5565b600080604083850312156128c457600080fd5b823561264b81612537565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa183360301811261293257600080fd5b9190910192915050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261297157600080fd5b83018035915067ffffffffffffffff82111561298c57600080fd5b6020019150368190038213156124ac57600080fd5b803561ffff8116811461089657600080fd5b6000602082840312156129c557600080fd5b612299826129a1565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600181811c90821680612a1157607f821691505b602082108103612a4a577f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b50919050565b601f821115610db257600081815260208120601f850160051c81016020861015612a775750805b601f850160051c820191505b81811015612a9657828155600101612a83565b505050505050565b67ffffffffffffffff831115612ab657612ab66129ce565b612aca83612ac483546129fd565b83612a50565b6000601f841160018114612b1c5760008515612ae65750838201355b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600387901b1c1916600186901b178355610ff3565b6000838152602090207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0861690835b82811015612b6b5786850135825560209485019460019092019101612b4b565b5086821015612ba6577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60f88860031b161c19848701351681555b505060018560011b0183555050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203612c1857612c18612bb8565b5060010190565b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b60208082528181018390526000906040808401600586901b8501820187855b88811015612d98577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc088840301845281357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa18b3603018112612ce857600080fd5b8a01606061ffff612cf8836129a1565b16855263ffffffff612d0b898401612600565b1688860152868201357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1833603018112612d4457600080fd5b90910187810191903567ffffffffffffffff811115612d6257600080fd5b803603831315612d7157600080fd5b8188870152612d838287018285612c1f565b96890196955050509186019150600101612c87565b509098975050505050505050565b600060208284031215612db857600080fd5b813561229981612732565b81810381811115610e1a57610e1a612bb8565b600060208284031215612de857600080fd5b61229982612788565b600067ffffffffffffffff808316818103612e0e57612e0e612bb8565b6001019392505050565b67ffffffffffffffff818116838216019080821115612e3957612e39612bb8565b5092915050565b80820180821115610e1a57610e1a612bb8565b7fffffffff000000000000000000000000000000000000000000000000000000008135818116916004851015612e935780818660040360031b1b83161692505b505092915050565b8183823760009101908152919050565b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff4183360301811261293257600080fd5b60005b83811015612efa578181015183820152602001612ee2565b50506000910152565b600060208284031215612f1557600080fd5b815167ffffffffffffffff80821115612f2d57600080fd5b818401915084601f830112612f4157600080fd5b815181811115612f5357612f536129ce565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908382118183101715612f9957612f996129ce565b81604052828152876020848701011115612fb257600080fd5b612fc3836020830160208801612edf565b979650505050505050565b60008151808452612fe6816020860160208601612edf565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b61ffff831681526040602082015260006130356040830184612fce565b949350505050565b73ffffffffffffffffffffffffffffffffffffffff85168152836020820152606060408201526000612092606083018486612c1f565b6060815263ffffffff84511660608201526020840151608082015260006040850151608060a08401526130a960e0840182612fce565b905060608601517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa08483030160c08501526130e48282612fce565b9250505083602083015273ffffffffffffffffffffffffffffffffffffffff83166040830152949350505050565b60006040828403121561312457600080fd5b6040516040810181811067ffffffffffffffff82111715613147576131476129ce565b604052825181526020928301519281019290925250919050565b60006080828403121561317357600080fd5b6040516060810181811067ffffffffffffffff82111715613196576131966129ce565b6040528251815260208301516131ab81612732565b60208201526131bd8460408501613112565b60408201529392505050565b600080858511156131d957600080fd5b838611156131e657600080fd5b5050820193919092039150565b7fff000000000000000000000000000000000000000000000000000000000000008135818116916001851015612e935760019490940360031b84901b1690921692915050565b73ffffffffffffffffffffffffffffffffffffffff8616815263ffffffff8516602082015260a06040820152600061327460a0830186612fce565b8415156060840152828103608084015261328e8185612fce565b98975050505050505050565b6000604082840312156132ac57600080fd5b6122998383613112565b61ffff818116838216019080821115612e3957612e39612bb8565b600086516132e3818460208b01612edf565b80830190507fff00000000000000000000000000000000000000000000000000000000000000808860f81b1682527fffff0000000000000000000000000000000000000000000000000000000000008760f01b166001830152808660f81b16600383015250835161335b816004840160208801612edf565b0160040197965050505050505056fea2646970667358221220be7b2ce1c2b1d3a5d2e641e93a120d13abbc38a821ee6ab4d36d75e342b53e4364736f6c63430008130033",
  "deployedBytecode": "0x6080604052600436106101b95760003560e01c8063715018a6116100eb578063c95c55be1161008f578063f2fde38b11610061578063f2fde38b1461057a578063f3fef3a31461059a578063f5c6ba5a146105ba578063f851a440146105cd57005b8063c95c55be146104ff578063d0a1026014610512578063d22446ce14610525578063dbcd3b911461055a57005b8063950c8a74116100c8578063950c8a7414610472578063b7abbb5d1461049f578063baf3292d146104b2578063bb0b6a53146104d257005b8063715018a6146103f95780637d25a05e1461040e5780638da5cb5b1461044757005b8063542e7b561161015d5780635e280f111161012f5780635e280f1114610333578063622f17f61461038c578063704b6c02146103b95780637112f86f146103d957005b8063542e7b56146102be57806354fd4d50146102d157806356a47289146102e65780635b849af61461031357005b8063257f4e0511610196578063257f4e051461021e57806326b27f84146102345780633400288b14610254578063416ecebf1461027457005b806306661abd146101c2578063107a93d6146101eb57806313137d651461020b57005b366101c057005b005b3480156101ce57600080fd5b506101d860045481565b6040519081526020015b60405180910390f35b3480156101f757600080fd5b506101c06102063660046124b3565b6105fa565b6101c0610219366004612559565b610737565b34801561022a57600080fd5b506101d860055481565b34801561024057600080fd5b506101d861024f366004612614565b610841565b34801561026057600080fd5b506101c061026f36600461262f565b61089b565b34801561028057600080fd5b506006546102a99074010000000000000000000000000000000000000000900463ffffffff1681565b60405163ffffffff90911681526020016101e2565b6101c06102cc366004612659565b610940565b3480156102dd57600080fd5b506101d8600181565b3480156102f257600080fd5b506101d8610301366004612614565b60096020526000908152604090205481565b34801561031f57600080fd5b506101c061032e3660046126f3565b610b82565b34801561033f57600080fd5b506103677f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016101e2565b34801561039857600080fd5b506101d86103a7366004612614565b600a6020526000908152604090205481565b3480156103c557600080fd5b506101c06103d4366004612715565b610bbb565b3480156103e557600080fd5b506101c06103f4366004612748565b610c83565b34801561040557600080fd5b506101c0610db7565b34801561041a57600080fd5b5061042e61042936600461262f565b610dcb565b60405167ffffffffffffffff90911681526020016101e2565b34801561045357600080fd5b5060005473ffffffffffffffffffffffffffffffffffffffff16610367565b34801561047e57600080fd5b506003546103679073ffffffffffffffffffffffffffffffffffffffff1681565b6101c06104ad366004612799565b610e20565b3480156104be57600080fd5b506101c06104cd366004612715565b610ece565b3480156104de57600080fd5b506101d86104ed366004612614565b60016020526000908152604090205481565b6101c061050d366004612799565b610f4f565b6101c06105203660046127fa565b610ffa565b34801561053157600080fd5b50610545610540366004612799565b61127c565b604080519283526020830191909152016101e2565b34801561056657600080fd5b506101c061057536600461287b565b6112ea565b34801561058657600080fd5b506101c0610595366004612715565b61165d565b3480156105a657600080fd5b506101c06105b53660046128b1565b611714565b6101c06105c83660046124b3565b6117d8565b3480156105d957600080fd5b506006546103679073ffffffffffffffffffffffffffffffffffffffff1681565b6106026119ac565b60005b818110156106f95782828281811061061f5761061f6128cf565b905060200281019061063191906128fe565b61063f90604081019061293c565b60026000868686818110610655576106556128cf565b905060200281019061066791906128fe565b610678906040810190602001612614565b63ffffffff1663ffffffff16815260200190815260200160002060008686868181106106a6576106a66128cf565b90506020028101906106b891906128fe565b6106c69060208101906129b3565b61ffff1681526020810191909152604001600020916106e6919083612a9e565b50806106f181612be7565b915050610605565b507f0548419a320c116408d237dae51da66dc63603dfd20bd99ba0c8be4c5ff7a200828260405161072b929190612c68565b60405180910390a15050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1633146107ad576040517fab08c09e0000000000000000000000000000000000000000000000000000000081523360048201526024015b60405180910390fd5b602087018035906107c29061024f908a612614565b146107ff576040517fc59a4f64000000000000000000000000000000000000000000000000000000008152602088013560048201526024016107a4565b61082961080f6020890189612614565b602089013561082460608b0160408c01612da6565b611a2d565b61083887878787878787611b63565b50505050505050565b63ffffffff811660009081526001602052604090205480610896576040517f196fb6c000000000000000000000000000000000000000000000000000000000815263ffffffff831660048201526024016107a4565b919050565b6108a36119ac565b63ffffffff82166000908152600160205260409020548190036108f2576040517f9556766100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b63ffffffff8216600081815260016020908152604091829020849055815192835282018390527fd81b9101f39c530fa8f18e6c9c5a64e4a3d7cb699e959f5d7abb5951c65e318f910161072b565b848114801561094e57508483145b6109b4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f4f6d6e69436f756e7465723a206c656e677468206d69736d617463680000000060448201526064016107a4565b6109bc61241f565b3460005b87811015610b775760006109d560018a612dc3565b82146109e157306109e3565b335b9050610b2060405180608001604052808c8c86818110610a0557610a056128cf565b9050602002016020810190610a1a9190612614565b63ffffffff168152602001610a4f8d8d87818110610a3a57610a3a6128cf565b905060200201602081019061024f9190612614565b8152602001610aa48b8b87818110610a6957610a696128cf565b9050602002016020810190610a7e9190612dd6565b60065474010000000000000000000000000000000000000000900463ffffffff16611dab565b8152602001888886818110610abb57610abb6128cf565b9050602002810190610acd919061293c565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920182905250939094525050604080518082019091528781526020810191909152905083611e24565b9350610b518a8a84818110610b3757610b376128cf565b9050602002016020810190610b4c9190612614565b611ef6565b604084015151610b619084612dc3565b9250508080610b6f90612be7565b9150506109c0565b505050505050505050565b610b8a6119ac565b600880547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016911515919091179055565b60065473ffffffffffffffffffffffffffffffffffffffff163314610c3c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f6f6e6c792061646d696e0000000000000000000000000000000000000000000060448201526064016107a4565b600680547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b610c8b6119ac565b6040517feaeacd6300000000000000000000000000000000000000000000000000000000815263ffffffff841660048201526024810183905267ffffffffffffffff821660448201527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169063eaeacd6390606401600060405180830381600087803b158015610d2f57600080fd5b505af1158015610d43573d6000803e3d6000fd5b505060085460ff16159150610db290505763ffffffff831660009081526007602090815260408083208584529091528120805467ffffffffffffffff1691610d8a83612df1565b91906101000a81548167ffffffffffffffff021916908367ffffffffffffffff160217905550505b505050565b610dbf6119ac565b610dc96000611f1f565b565b60085460009060ff1615610e165763ffffffff83166000908152600760209081526040808320858452909152902054610e0f9067ffffffffffffffff166001612e18565b9050610e1a565b5060005b92915050565b610ebe60405180608001604052808663ffffffff168152602001610e4387610841565b8152602001610e6486600660149054906101000a900463ffffffff16611dab565b815260200184848080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920182905250939094525050604080518082019091523481526020810191909152905033611e24565b50610ec884611ef6565b50505050565b610ed66119ac565b600380547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040519081527f5db758e995a17ec1ad84bdef7e8c3293a0bd6179bcce400dff5d4c3d87db726b9060200160405180910390a150565b60065473ffffffffffffffffffffffffffffffffffffffff163314610fd0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f6f6e6c792061646d696e0000000000000000000000000000000000000000000060448201526064016107a4565b610ff360405180608001604052808663ffffffff168152602001610e4387610841565b5050505050565b3373ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001614611099576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f21656e64706f696e74000000000000000000000000000000000000000000000060448201526064016107a4565b60006110a58686611f94565b90507ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe60ff8216016110ef576001600560008282546110e49190612e40565b909155506112729050565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc60ff8216016112105760016005600082825461112c9190612e40565b909155506000905061113e8787611fb6565b905061114981611ef6565b600061119c62030d406000611195604080517e03000000000000000000000000000000000000000000000000000000000000602082015281516002818303018152602290910190915290565b9190611fd8565b905061120860405180608001604052808463ffffffff1681526020016111c185610841565b81526020016111e36001600660149054906101000a900463ffffffff16611dab565b8152602001838152506040518060400160405280348152602001600081525030611e24565b505050611272565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f696e76616c6964206d657373616765207479706500000000000000000000000060448201526064016107a4565b5050505050505050565b6000806112dd8661129f87600660149054906101000a900463ffffffff16611dab565b600087878080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061209c92505050565b9150915094509492505050565b6112f26119ac565b60006112fe8284612e53565b90507fffffffff0000000000000000000000000000000000000000000000000000000081167fb8007ff600000000000000000000000000000000000000000000000000000000148061139157507fffffffff0000000000000000000000000000000000000000000000000000000081167f9e7fffcc00000000000000000000000000000000000000000000000000000000145b806113dd57507fffffffff0000000000000000000000000000000000000000000000000000000081167f0678327f00000000000000000000000000000000000000000000000000000000145b8061142957507fffffffff0000000000000000000000000000000000000000000000000000000081167fb8849ac900000000000000000000000000000000000000000000000000000000145b8061147557507fffffffff0000000000000000000000000000000000000000000000000000000081167fe16f964d00000000000000000000000000000000000000000000000000000000145b806114c157507fffffffff0000000000000000000000000000000000000000000000000000000081167f66bf43d600000000000000000000000000000000000000000000000000000000145b8061150d57507fffffffff0000000000000000000000000000000000000000000000000000000081167f965183d400000000000000000000000000000000000000000000000000000000145b8061155957507fffffffff0000000000000000000000000000000000000000000000000000000081167feaeacd6300000000000000000000000000000000000000000000000000000000145b6115bf576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f4f4170703a2066756e6374696f6e206e6f7420616c6c6f77656400000000000060448201526064016107a4565b6000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff168585604051611609929190612e9b565b6000604051808303816000865af19150503d8060008114611646576040519150601f19603f3d011682016040523d82523d6000602084013e61164b565b606091505b509150915081610ff357805160208201fd5b6116656119ac565b73ffffffffffffffffffffffffffffffffffffffff8116611708576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f646472657373000000000000000000000000000000000000000000000000000060648201526084016107a4565b61171181611f1f565b50565b60065473ffffffffffffffffffffffffffffffffffffffff163314611795576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f6f6e6c792061646d696e0000000000000000000000000000000000000000000060448201526064016107a4565b60405173ffffffffffffffffffffffffffffffffffffffff83169082156108fc029083906000818181858888f19350505050158015610db2573d6000803e3d6000fd5b60035473ffffffffffffffffffffffffffffffffffffffff16331461182b576040517fc023811c0000000000000000000000000000000000000000000000000000000081523360048201526024016107a4565b60005b818110156118c15736838383818110611849576118496128cf565b905060200281019061185b9190612eab565b9050600061186f61024f6020840184612614565b9050602082013581146118835750506118af565b6118ac826060810135611899608083018361293c565b336118a760a089018961293c565b611b63565b50505b806118b981612be7565b91505061182e565b50600354604080517fd2968d57000000000000000000000000000000000000000000000000000000008152905160019273ffffffffffffffffffffffffffffffffffffffff169163d2968d579160048083019260009291908290030181865afa158015611932573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682016040526119789190810190612f03565b6040517f0a78da8f0000000000000000000000000000000000000000000000000000000081526004016107a4929190613018565b60005473ffffffffffffffffffffffffffffffffffffffff163314610dc9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016107a4565b63ffffffff8316600090815260076020908152604080832085845290915290205460085467ffffffffffffffff9091169060ff1615611aed57611a71816001612e18565b67ffffffffffffffff168267ffffffffffffffff1614611aed576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f4f4170703a20696e76616c6964206e6f6e63650000000000000000000000000060448201526064016107a4565b8067ffffffffffffffff168267ffffffffffffffff161115610ec85763ffffffff841660009081526007602090815260408083208684529091529020805467ffffffffffffffff84167fffffffffffffffffffffffffffffffffffffffffffffffff000000000000000090911617905550505050565b6000611b6f8686611f94565b90507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60ff821601611bcb5760048054906000611bab83612be7565b90915550611bc69050611bc160208a018a612614565b612158565b611272565b60ff811660021480611be0575060ff81166004145b15611cba5760048054906000611bf583612be7565b90915550611c0b9050611bc160208a018a612614565b6040517f754d3b9c00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063754d3b9c90611c839030908b908b908b9060040161303d565b600060405180830381600087803b158015611c9d57600080fd5b505af1158015611cb1573d6000803e3d6000fd5b50505050611272565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd60ff8216016112105760048054906000611cf483612be7565b90915550611d0a9050611bc160208a018a612614565b611d1a610b4c60208a018a612614565b6000611d6662030d406000611195604080517e03000000000000000000000000000000000000000000000000000000000000602082015281516002818303018152602290910190915290565b6040805160808101909152909150611da49080611d8660208d018d612614565b63ffffffff1681526020908101906111c19061024f908e018e612614565b5050611272565b6040517fff0000000000000000000000000000000000000000000000000000000000000060f884901b1660208201527fffffffff0000000000000000000000000000000000000000000000000000000060e083901b1660218201526060906025015b604051602081830303815290604052905092915050565b611e2c61241f565b825160208401516040517faca1b45a00000000000000000000000000000000000000000000000000000000815260009273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169263aca1b45a92611eaa918a918990600401613073565b60806040518083038185885af1158015611ec8573d6000803e3d6000fd5b50505050506040513d601f19601f82011682018060405250810190611eed9190613161565b95945050505050565b63ffffffff81166000908152600a60205260408120805491611f1783612be7565b919050555050565b6000805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6000611fa360018284866131c9565b611fac916131f3565b60f81c9392505050565b6000611fc582600181866131c9565b611fce91612e53565b60e01c9392505050565b6060836003611fe8826000612179565b61ffff1614612078576040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526024808201527f4f7074696f6e734275696c6465723a20696e76616c6964206f7074696f6e732060448201527f747970650000000000000000000000000000000000000000000000000000000060648201526084016107a4565b600061208485856121f9565b9050612092866001836122a0565b9695505050505050565b60008060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166383c4755930898989896040518663ffffffff1660e01b8152600401612102959493929190613239565b6040805180830381865afa15801561211e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612142919061329a565b8051602090910151909890975095505050505050565b63ffffffff81166000908152600960205260408120805491611f1783612be7565b6000612186826002612e40565b835110156121f0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f746f55696e7431365f6f75744f66426f756e647300000000000000000000000060448201526064016107a4565b50016002015190565b60606fffffffffffffffffffffffffffffffff82161561226257604080517fffffffffffffffffffffffffffffffff00000000000000000000000000000000608086811b8216602084015285901b16603082015201604051602081830303815290604052612299565b6040517fffffffffffffffffffffffffffffffff00000000000000000000000000000000608085901b166020820152603001611e0d565b9392505050565b60608360036122b0826000612179565b61ffff1614612340576040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526024808201527f4f7074696f6e734275696c6465723a20696e76616c6964206f7074696f6e732060448201527f747970650000000000000000000000000000000000000000000000000000000060648201526084016107a4565b84600161234d8551612387565b6123589060016132b6565b868660405160200161236e9594939291906132d1565b6040516020818303038152906040529150509392505050565b600061ffff82111561241b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f53616665436173743a2076616c756520646f65736e27742066697420696e203160448201527f362062697473000000000000000000000000000000000000000000000000000060648201526084016107a4565b5090565b604051806060016040528060008019168152602001600067ffffffffffffffff168152602001612462604051806040016040528060008152602001600081525090565b905290565b60008083601f84011261247957600080fd5b50813567ffffffffffffffff81111561249157600080fd5b6020830191508360208260051b85010111156124ac57600080fd5b9250929050565b600080602083850312156124c657600080fd5b823567ffffffffffffffff8111156124dd57600080fd5b6124e985828601612467565b90969095509350505050565b60008083601f84011261250757600080fd5b50813567ffffffffffffffff81111561251f57600080fd5b6020830191508360208285010111156124ac57600080fd5b73ffffffffffffffffffffffffffffffffffffffff8116811461171157600080fd5b600080600080600080600087890360e081121561257557600080fd5b606081121561258357600080fd5b5087965060608801359550608088013567ffffffffffffffff808211156125a957600080fd5b6125b58b838c016124f5565b909750955060a08a013591506125ca82612537565b90935060c089013590808211156125e057600080fd5b506125ed8a828b016124f5565b989b979a50959850939692959293505050565b803563ffffffff8116811461089657600080fd5b60006020828403121561262657600080fd5b61229982612600565b6000806040838503121561264257600080fd5b61264b83612600565b946020939093013593505050565b6000806000806000806060878903121561267257600080fd5b863567ffffffffffffffff8082111561268a57600080fd5b6126968a838b01612467565b909850965060208901359150808211156126af57600080fd5b6126bb8a838b01612467565b909650945060408901359150808211156126d457600080fd5b506126e189828a01612467565b979a9699509497509295939492505050565b60006020828403121561270557600080fd5b8135801515811461229957600080fd5b60006020828403121561272757600080fd5b813561229981612537565b67ffffffffffffffff8116811461171157600080fd5b60008060006060848603121561275d57600080fd5b61276684612600565b925060208401359150604084013561277d81612732565b809150509250925092565b803560ff8116811461089657600080fd5b600080600080606085870312156127af57600080fd5b6127b885612600565b93506127c660208601612788565b9250604085013567ffffffffffffffff8111156127e257600080fd5b6127ee878288016124f5565b95989497509550505050565b600080600080600080600060a0888a03121561281557600080fd5b873561282081612537565b965060208801359550604088013567ffffffffffffffff8082111561284457600080fd5b6128508b838c016124f5565b909750955060608a0135915061286582612537565b909350608089013590808211156125e057600080fd5b6000806020838503121561288e57600080fd5b823567ffffffffffffffff8111156128a557600080fd5b6124e9858286016124f5565b600080604083850312156128c457600080fd5b823561264b81612537565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa183360301811261293257600080fd5b9190910192915050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261297157600080fd5b83018035915067ffffffffffffffff82111561298c57600080fd5b6020019150368190038213156124ac57600080fd5b803561ffff8116811461089657600080fd5b6000602082840312156129c557600080fd5b612299826129a1565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600181811c90821680612a1157607f821691505b602082108103612a4a577f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b50919050565b601f821115610db257600081815260208120601f850160051c81016020861015612a775750805b601f850160051c820191505b81811015612a9657828155600101612a83565b505050505050565b67ffffffffffffffff831115612ab657612ab66129ce565b612aca83612ac483546129fd565b83612a50565b6000601f841160018114612b1c5760008515612ae65750838201355b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600387901b1c1916600186901b178355610ff3565b6000838152602090207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0861690835b82811015612b6b5786850135825560209485019460019092019101612b4b565b5086821015612ba6577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60f88860031b161c19848701351681555b505060018560011b0183555050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203612c1857612c18612bb8565b5060010190565b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b60208082528181018390526000906040808401600586901b8501820187855b88811015612d98577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc088840301845281357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa18b3603018112612ce857600080fd5b8a01606061ffff612cf8836129a1565b16855263ffffffff612d0b898401612600565b1688860152868201357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1833603018112612d4457600080fd5b90910187810191903567ffffffffffffffff811115612d6257600080fd5b803603831315612d7157600080fd5b8188870152612d838287018285612c1f565b96890196955050509186019150600101612c87565b509098975050505050505050565b600060208284031215612db857600080fd5b813561229981612732565b81810381811115610e1a57610e1a612bb8565b600060208284031215612de857600080fd5b61229982612788565b600067ffffffffffffffff808316818103612e0e57612e0e612bb8565b6001019392505050565b67ffffffffffffffff818116838216019080821115612e3957612e39612bb8565b5092915050565b80820180821115610e1a57610e1a612bb8565b7fffffffff000000000000000000000000000000000000000000000000000000008135818116916004851015612e935780818660040360031b1b83161692505b505092915050565b8183823760009101908152919050565b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff4183360301811261293257600080fd5b60005b83811015612efa578181015183820152602001612ee2565b50506000910152565b600060208284031215612f1557600080fd5b815167ffffffffffffffff80821115612f2d57600080fd5b818401915084601f830112612f4157600080fd5b815181811115612f5357612f536129ce565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908382118183101715612f9957612f996129ce565b81604052828152876020848701011115612fb257600080fd5b612fc3836020830160208801612edf565b979650505050505050565b60008151808452612fe6816020860160208601612edf565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b61ffff831681526040602082015260006130356040830184612fce565b949350505050565b73ffffffffffffffffffffffffffffffffffffffff85168152836020820152606060408201526000612092606083018486612c1f565b6060815263ffffffff84511660608201526020840151608082015260006040850151608060a08401526130a960e0840182612fce565b905060608601517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa08483030160c08501526130e48282612fce565b9250505083602083015273ffffffffffffffffffffffffffffffffffffffff83166040830152949350505050565b60006040828403121561312457600080fd5b6040516040810181811067ffffffffffffffff82111715613147576131476129ce565b604052825181526020928301519281019290925250919050565b60006080828403121561317357600080fd5b6040516060810181811067ffffffffffffffff82111715613196576131966129ce565b6040528251815260208301516131ab81612732565b60208201526131bd8460408501613112565b60408201529392505050565b600080858511156131d957600080fd5b838611156131e657600080fd5b5050820193919092039150565b7fff000000000000000000000000000000000000000000000000000000000000008135818116916001851015612e935760019490940360031b84901b1690921692915050565b73ffffffffffffffffffffffffffffffffffffffff8616815263ffffffff8516602082015260a06040820152600061327460a0830186612fce565b8415156060840152828103608084015261328e8185612fce565b98975050505050505050565b6000604082840312156132ac57600080fd5b6122998383613112565b61ffff818116838216019080821115612e3957612e39612bb8565b600086516132e3818460208b01612edf565b80830190507fff00000000000000000000000000000000000000000000000000000000000000808860f81b1682527fffff0000000000000000000000000000000000000000000000000000000000008760f01b166001830152808660f81b16600383015250835161335b816004840160208801612edf565b0160040197965050505050505056fea2646970667358221220be7b2ce1c2b1d3a5d2e641e93a120d13abbc38a821ee6ab4d36d75e342b53e4364736f6c63430008130033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "callEndpoint(bytes)": {
        "details": "a generic interface to set the endpoint configthis is a low level interface, and should be used with cautionuse our SDK to generate the properly abi.encoded config"
      },
      "lzReceive((uint32,bytes32,uint64),bytes32,bytes,address,bytes)": {
        "details": "Oapp can override this interface for custom logics (e.g. more assertion)"
      },
      "lzReceiveAndRevert(((uint32,bytes32,uint64),bytes32,bytes,bytes)[])": {
        "details": "a generic interface for precrime simulationsthis function reverts at the end with the simulation resultsvalue is provided as a lump sum, does not restrict how much each packet can consume"
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
      },
      "safeGetPeer(uint32)": {
        "details": "check non-zero peer and return it"
      },
      "setPeer(uint32,bytes32)": {
        "details": "set _peer to bytes32(0) (the default value) to \"untrust\""
      },
      "setPrecrime(address)": {
        "details": "set the precrime contract. can upgrade the precrime implementation overtime"
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 1837,
        "contract": "contracts/examples/OmniCounter.sol:OmniCounter",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 6164,
        "contract": "contracts/examples/OmniCounter.sol:OmniCounter",
        "label": "peers",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_uint32,t_bytes32)"
      },
      {
        "astId": 6170,
        "contract": "contracts/examples/OmniCounter.sol:OmniCounter",
        "label": "enforcedOptions",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_uint32,t_mapping(t_uint16,t_bytes_storage))"
      },
      {
        "astId": 6173,
        "contract": "contracts/examples/OmniCounter.sol:OmniCounter",
        "label": "precrime",
        "offset": 0,
        "slot": "3",
        "type": "t_contract(IPreCrime)9608"
      },
      {
        "astId": 7648,
        "contract": "contracts/examples/OmniCounter.sol:OmniCounter",
        "label": "count",
        "offset": 0,
        "slot": "4",
        "type": "t_uint256"
      },
      {
        "astId": 7650,
        "contract": "contracts/examples/OmniCounter.sol:OmniCounter",
        "label": "composedCount",
        "offset": 0,
        "slot": "5",
        "type": "t_uint256"
      },
      {
        "astId": 7652,
        "contract": "contracts/examples/OmniCounter.sol:OmniCounter",
        "label": "admin",
        "offset": 0,
        "slot": "6",
        "type": "t_address"
      },
      {
        "astId": 7654,
        "contract": "contracts/examples/OmniCounter.sol:OmniCounter",
        "label": "eid",
        "offset": 20,
        "slot": "6",
        "type": "t_uint32"
      },
      {
        "astId": 7660,
        "contract": "contracts/examples/OmniCounter.sol:OmniCounter",
        "label": "maxReceivedNonce",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_uint32,t_mapping(t_bytes32,t_uint64))"
      },
      {
        "astId": 7662,
        "contract": "contracts/examples/OmniCounter.sol:OmniCounter",
        "label": "orderedNonce",
        "offset": 0,
        "slot": "8",
        "type": "t_bool"
      },
      {
        "astId": 7666,
        "contract": "contracts/examples/OmniCounter.sol:OmniCounter",
        "label": "inboundCount",
        "offset": 0,
        "slot": "9",
        "type": "t_mapping(t_uint32,t_uint256)"
      },
      {
        "astId": 7670,
        "contract": "contracts/examples/OmniCounter.sol:OmniCounter",
        "label": "outboundCount",
        "offset": 0,
        "slot": "10",
        "type": "t_mapping(t_uint32,t_uint256)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_bytes_storage": {
        "encoding": "bytes",
        "label": "bytes",
        "numberOfBytes": "32"
      },
      "t_contract(IPreCrime)9608": {
        "encoding": "inplace",
        "label": "contract IPreCrime",
        "numberOfBytes": "20"
      },
      "t_mapping(t_bytes32,t_uint64)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint64)",
        "numberOfBytes": "32",
        "value": "t_uint64"
      },
      "t_mapping(t_uint16,t_bytes_storage)": {
        "encoding": "mapping",
        "key": "t_uint16",
        "label": "mapping(uint16 => bytes)",
        "numberOfBytes": "32",
        "value": "t_bytes_storage"
      },
      "t_mapping(t_uint32,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_uint32",
        "label": "mapping(uint32 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_mapping(t_uint32,t_mapping(t_bytes32,t_uint64))": {
        "encoding": "mapping",
        "key": "t_uint32",
        "label": "mapping(uint32 => mapping(bytes32 => uint64))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes32,t_uint64)"
      },
      "t_mapping(t_uint32,t_mapping(t_uint16,t_bytes_storage))": {
        "encoding": "mapping",
        "key": "t_uint32",
        "label": "mapping(uint32 => mapping(uint16 => bytes))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint16,t_bytes_storage)"
      },
      "t_mapping(t_uint32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint32",
        "label": "mapping(uint32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_uint16": {
        "encoding": "inplace",
        "label": "uint16",
        "numberOfBytes": "2"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      }
    }
  }
}