{
  "address": "0x76ca03a67C049477FfB09694dFeF00416dB69746",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_endpoint",
          "type": "address"
        },
        {
          "internalType": "address payable",
          "name": "_counter",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "code",
          "type": "uint16"
        },
        {
          "internalType": "bytes",
          "name": "result",
          "type": "bytes"
        }
      ],
      "name": "LzReceiveRevert",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "code",
          "type": "uint16"
        },
        {
          "internalType": "bytes",
          "name": "message",
          "type": "bytes"
        }
      ],
      "name": "SimulateRevert",
      "type": "error"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint32",
                  "name": "srcEid",
                  "type": "uint32"
                },
                {
                  "internalType": "bytes32",
                  "name": "sender",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint64",
                  "name": "nonce",
                  "type": "uint64"
                }
              ],
              "internalType": "struct IMessageOrigin.MessageOrigin",
              "name": "origin",
              "type": "tuple"
            },
            {
              "internalType": "bytes32",
              "name": "guid",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "message",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "callParams",
              "type": "bytes"
            }
          ],
          "internalType": "struct IPreCrime.Packet[]",
          "name": "_packets",
          "type": "tuple[]"
        }
      ],
      "name": "_simulateAndRevert",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint32",
                  "name": "srcEid",
                  "type": "uint32"
                },
                {
                  "internalType": "bytes32",
                  "name": "sender",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint64",
                  "name": "nonce",
                  "type": "uint64"
                }
              ],
              "internalType": "struct IMessageOrigin.MessageOrigin",
              "name": "origin",
              "type": "tuple"
            },
            {
              "internalType": "bytes32",
              "name": "guid",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "message",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "callParams",
              "type": "bytes"
            }
          ],
          "internalType": "struct IPreCrime.Packet[]",
          "name": "_packets",
          "type": "tuple[]"
        }
      ],
      "name": "getPrecrimeConfig",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pAdmin",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pMaxBatchSize",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint32",
                  "name": "srcEid",
                  "type": "uint32"
                },
                {
                  "internalType": "bytes32",
                  "name": "sender",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint64",
                  "name": "nonce",
                  "type": "uint64"
                }
              ],
              "internalType": "struct IMessageOrigin.MessageOrigin",
              "name": "origin",
              "type": "tuple"
            },
            {
              "internalType": "bytes32",
              "name": "guid",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "message",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "callParams",
              "type": "bytes"
            }
          ],
          "internalType": "struct IPreCrime.Packet[]",
          "name": "_packets",
          "type": "tuple[]"
        },
        {
          "internalType": "bytes[]",
          "name": "_simulation",
          "type": "bytes[]"
        }
      ],
      "name": "precrime",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "code",
          "type": "uint16"
        },
        {
          "internalType": "bytes",
          "name": "reason",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "eid",
          "type": "uint32"
        }
      ],
      "name": "precrimeEidToPeer",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "peer",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "precrimeEids",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "precrimePeers",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "precrimeVersion",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "",
          "type": "uint16"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_admin",
          "type": "address"
        }
      ],
      "name": "setPrecrimeAdmin",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "_maxBatchSize",
          "type": "uint64"
        }
      ],
      "name": "setPrecrimeMaxBatchSize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32[]",
          "name": "_eids",
          "type": "uint32[]"
        },
        {
          "internalType": "bytes32[]",
          "name": "_peers",
          "type": "bytes32[]"
        }
      ],
      "name": "setPrecrimePeers",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint32",
                  "name": "srcEid",
                  "type": "uint32"
                },
                {
                  "internalType": "bytes32",
                  "name": "sender",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint64",
                  "name": "nonce",
                  "type": "uint64"
                }
              ],
              "internalType": "struct IMessageOrigin.MessageOrigin",
              "name": "origin",
              "type": "tuple"
            },
            {
              "internalType": "bytes32",
              "name": "guid",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "message",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "callParams",
              "type": "bytes"
            }
          ],
          "internalType": "struct IPreCrime.Packet[]",
          "name": "_packets",
          "type": "tuple[]"
        }
      ],
      "name": "simulate",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "code",
          "type": "uint16"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint32",
                  "name": "srcEid",
                  "type": "uint32"
                },
                {
                  "internalType": "bytes32",
                  "name": "sender",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint64",
                  "name": "nonce",
                  "type": "uint64"
                }
              ],
              "internalType": "struct IMessageOrigin.MessageOrigin",
              "name": "origin",
              "type": "tuple"
            },
            {
              "internalType": "bytes32",
              "name": "guid",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "message",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "callParams",
              "type": "bytes"
            }
          ],
          "internalType": "struct IPreCrime.Packet[]",
          "name": "",
          "type": "tuple[]"
        }
      ],
      "name": "simulateView",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "",
          "type": "uint16"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "simulationCallback",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xc60833c31951016f0f9c6a9cd7db7e45e10be5f4297287aa2e87db86dad1f7bc",
  "receipt": {
    "to": null,
    "from": "0x14dC79964da2C08b23698B3D3cc7Ca32193d9955",
    "contractAddress": "0x76ca03a67C049477FfB09694dFeF00416dB69746",
    "transactionIndex": 0,
    "gasUsed": "2588145",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xf07cdeb5076e03920ec7e1f33afcd9f6c8c52b4cb1fe224fa6d32249b562d063",
    "transactionHash": "0xc60833c31951016f0f9c6a9cd7db7e45e10be5f4297287aa2e87db86dad1f7bc",
    "logs": [],
    "blockNumber": 236,
    "cumulativeGasUsed": "2588145",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x1275D096B9DBf2347bD2a131Fb6BDaB0B4882487",
    "0x39dD11C243Ac4Ac250980FA3AEa016f73C509f37"
  ],
  "numDeployments": 1,
  "solcInputHash": "678dd2c8bfaae833f2471ff1cdef9557",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_endpoint\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_counter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"code\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"name\":\"LzReceiveRevert\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"code\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"SimulateRevert\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"srcEid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"internalType\":\"struct IMessageOrigin.MessageOrigin\",\"name\":\"origin\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"guid\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callParams\",\"type\":\"bytes\"}],\"internalType\":\"struct IPreCrime.Packet[]\",\"name\":\"_packets\",\"type\":\"tuple[]\"}],\"name\":\"_simulateAndRevert\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"srcEid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"internalType\":\"struct IMessageOrigin.MessageOrigin\",\"name\":\"origin\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"guid\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callParams\",\"type\":\"bytes\"}],\"internalType\":\"struct IPreCrime.Packet[]\",\"name\":\"_packets\",\"type\":\"tuple[]\"}],\"name\":\"getPrecrimeConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pMaxBatchSize\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"srcEid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"internalType\":\"struct IMessageOrigin.MessageOrigin\",\"name\":\"origin\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"guid\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callParams\",\"type\":\"bytes\"}],\"internalType\":\"struct IPreCrime.Packet[]\",\"name\":\"_packets\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_simulation\",\"type\":\"bytes[]\"}],\"name\":\"precrime\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"code\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"reason\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"eid\",\"type\":\"uint32\"}],\"name\":\"precrimeEidToPeer\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"peer\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"precrimeEids\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"precrimePeers\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"precrimeVersion\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setPrecrimeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_maxBatchSize\",\"type\":\"uint64\"}],\"name\":\"setPrecrimeMaxBatchSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"_eids\",\"type\":\"uint32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_peers\",\"type\":\"bytes32[]\"}],\"name\":\"setPrecrimePeers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"srcEid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"internalType\":\"struct IMessageOrigin.MessageOrigin\",\"name\":\"origin\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"guid\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callParams\",\"type\":\"bytes\"}],\"internalType\":\"struct IPreCrime.Packet[]\",\"name\":\"_packets\",\"type\":\"tuple[]\"}],\"name\":\"simulate\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"code\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"srcEid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"internalType\":\"struct IMessageOrigin.MessageOrigin\",\"name\":\"origin\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"guid\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callParams\",\"type\":\"bytes\"}],\"internalType\":\"struct IPreCrime.Packet[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"name\":\"simulateView\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"simulationCallback\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/examples/OmniCounterPreCrime.sol\":\"OmniCounterPreCrime\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":20000},\"remappings\":[]},\"sources\":{\"@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/libs/VerifierOptions.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"solidity-bytes-utils/contracts/BytesLib.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/BitMaps.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Errors.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol\\\";\\n\\nlibrary VerifierOptions {\\n    using BitMaps for BitMaps.BitMap256;\\n    using CalldataBytesLib for bytes;\\n    using BytesLib for bytes;\\n\\n    uint8 internal constant WORKER_ID = 2;\\n    uint8 internal constant OPTION_TYPE_PRECRIME = 1;\\n\\n    /// @dev group verifier options by its idx\\n    /// @param _options [verifier_id][verifier_option][verifier_id][verifier_option]...\\n    ///        verifier_option = [option_size][verifier_idx][option_type][option]\\n    ///        option_size = len(verifier_idx) + len(option_type) + len(option)\\n    ///        verifier_id: uint8, verifier_idx: uint8, option_size: uint16, option_type: uint8, option: bytes\\n    /// @return verifierOptions the grouped options, still share the same format of _options\\n    /// @return verifierIndices the verifier indices\\n    function groupVerifierOptionsByIdx(\\n        bytes memory _options\\n    ) internal pure returns (bytes[] memory verifierOptions, uint8[] memory verifierIndices) {\\n        if (_options.length == 0) return (verifierOptions, verifierIndices);\\n\\n        uint8 numVerifiers = getNumVerifiers(_options);\\n\\n        // if there is only 1 verifier, we can just return the whole options\\n        if (numVerifiers == 1) {\\n            verifierOptions = new bytes[](1);\\n            verifierOptions[0] = _options;\\n\\n            verifierIndices = new uint8[](1);\\n            verifierIndices[0] = _options.toUint8(3); // verifier idx\\n            return (verifierOptions, verifierIndices);\\n        }\\n\\n        // otherwise, we need to group the options by verifier_idx\\n        verifierIndices = new uint8[](numVerifiers);\\n        verifierOptions = new bytes[](numVerifiers);\\n        unchecked {\\n            uint cursor;\\n            uint start;\\n            uint8 lastVerifierIdx = 255; // 255 is an invalid verifier_idx\\n\\n            while (cursor < _options.length) {\\n                ++cursor; // skip worker_id\\n\\n                uint16 optionLength = _options.toUint16(cursor);\\n                cursor += 2;\\n                require(optionLength >= 2, Errors.INVALID_SIZE); // at least 1 byte for option_type and 1 byte for verifier_idx\\n\\n                uint8 verifierIdx = _options.toUint8(cursor);\\n\\n                if (lastVerifierIdx == 255) {\\n                    lastVerifierIdx = verifierIdx;\\n                }\\n\\n                // verifierIdx must equal to the lastVerifierIdx for the first option\\n                // so it is always skipped in the first option\\n                // this operation slices out options whenever the the scan finds a different lastVerifierIdx\\n                if (verifierIdx != lastVerifierIdx) {\\n                    uint size = cursor - start - 3; // 3 is for worker_id and option_length\\n                    bytes memory op = _options.slice(start, size);\\n                    _insertVerifierOptions(verifierOptions, verifierIndices, lastVerifierIdx, op);\\n\\n                    // reset the start and lastVerifierIdx\\n                    start += size;\\n                    lastVerifierIdx = verifierIdx;\\n                }\\n\\n                cursor += optionLength;\\n\\n                // if we have reached the end of the options, we need to process the last verifier\\n                if (cursor == _options.length) {\\n                    uint size = cursor - start;\\n                    bytes memory op = _options.slice(start, size);\\n                    _insertVerifierOptions(verifierOptions, verifierIndices, verifierIdx, op);\\n                }\\n            }\\n            require(cursor == _options.length, Errors.INVALID_SIZE);\\n\\n            // revert verifierIndices to start from 0\\n            for (uint8 i = 0; i < numVerifiers; ++i) {\\n                --verifierIndices[i];\\n            }\\n        }\\n    }\\n\\n    function _insertVerifierOptions(\\n        bytes[] memory _verifierOptions,\\n        uint8[] memory _verifierIndices,\\n        uint8 _verifierIdx,\\n        bytes memory _newOptions\\n    ) internal pure {\\n        // verifierIdx starts from 0 but default value of verifierIndices is 0, so we tell if the slot is empty by adding 1 to verifierIdx\\n        require(_verifierIdx < 255, Errors.INVALID_VERIFIERS);\\n        uint8 verifierIdxAdj = _verifierIdx + 1;\\n\\n        for (uint8 j = 0; j < _verifierIndices.length; ++j) {\\n            uint8 index = _verifierIndices[j];\\n            if (verifierIdxAdj == index) {\\n                _verifierOptions[j] = abi.encodePacked(_verifierOptions[j], _newOptions);\\n                break;\\n            } else if (index == 0) {\\n                // empty slot, that means it is the first time we see this verifier\\n                _verifierIndices[j] = verifierIdxAdj;\\n                _verifierOptions[j] = _newOptions;\\n                break;\\n            }\\n        }\\n    }\\n\\n    /// @dev get the number of unique verifiers\\n    /// @param _options the format is the same as groupVerifierOptionsByIdx\\n    function getNumVerifiers(bytes memory _options) internal pure returns (uint8 numVerifiers) {\\n        uint cursor;\\n        BitMaps.BitMap256 bitmap;\\n\\n        // find number of unique verifier_idx\\n        unchecked {\\n            while (cursor < _options.length) {\\n                ++cursor; // skip worker_id\\n\\n                uint16 optionLength = _options.toUint16(cursor);\\n                cursor += 2;\\n                require(optionLength >= 2, Errors.INVALID_SIZE); // at least 1 byte for verifier_idx and 1 byte for option_type\\n\\n                uint8 verifierIdx = _options.toUint8(cursor);\\n\\n                // verifierIdx starts from 0, add one for bitmap check/set\\n                require(verifierIdx < 255, Errors.INVALID_VERIFIERS);\\n                uint8 verifierIdxAdj = verifierIdx + 1;\\n\\n                // if verifierIdx is not set, increment numVerifiers\\n                if (!bitmap.get(verifierIdxAdj)) {\\n                    ++numVerifiers;\\n                    bitmap = bitmap.set(verifierIdxAdj);\\n                }\\n\\n                cursor += optionLength;\\n            }\\n        }\\n        require(cursor == _options.length, Errors.INVALID_SIZE);\\n    }\\n\\n    /// @dev decode the next verifier option from _options starting from the specified cursor\\n    /// @param _options the format is the same as groupVerifierOptionsByIdx\\n    /// @param _cursor the cursor to start decoding\\n    /// @return optionType the type of the option\\n    /// @return option the option\\n    /// @return cursor the cursor to start decoding the next option\\n    function nextVerifierOption(\\n        bytes calldata _options,\\n        uint _cursor\\n    ) internal pure returns (uint8 optionType, bytes calldata option, uint cursor) {\\n        unchecked {\\n            // skip worker id\\n            cursor = _cursor + 1;\\n\\n            // read option size\\n            uint16 size = _options.toU16(cursor);\\n            cursor += 2;\\n\\n            // read option type\\n            optionType = _options.toU8(cursor + 1); // skip verifier_idx\\n\\n            // startCursor and endCursor are used to slice the option from _options\\n            uint startCursor = cursor + 2; // skip option type and verifier_idx\\n            uint endCursor = cursor + size;\\n            option = _options[startCursor:endCursor];\\n            cursor += size;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x64ce5ceb89a26cdcddd34f2d90838cc41de88beb510c810247648de085492b31\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroComposer.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\ninterface ILayerZeroComposer {\\n    function lzCompose(\\n        address _receiver,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        address _caller,\\n        bytes calldata _extraData\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0x3e7e7e659a2e469eb7b0961d5bc36884a284e0a7b6b66230db7b72217b65f5df\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IMessageLibManager.sol\\\";\\nimport \\\"./IMessagingComposer.sol\\\";\\nimport \\\"./IMessagingChannel.sol\\\";\\nimport \\\"./IMessagingContext.sol\\\";\\nimport \\\"./IMessageOrigin.sol\\\";\\n\\ninterface ILayerZeroEndpointV2 is\\n    IMessageLibManager,\\n    IMessagingComposer,\\n    IMessagingChannel,\\n    IMessagingContext,\\n    IMessageOrigin\\n{\\n    struct MessagingParams {\\n        uint32 dstEid;\\n        bytes32 receiver;\\n        bytes message;\\n        bytes options;\\n    }\\n\\n    struct MessagingReceipt {\\n        bytes32 guid;\\n        uint64 nonce;\\n        MessagingFee fee;\\n    }\\n\\n    struct MessagingFee {\\n        uint nativeFee;\\n        uint lzTokenFee;\\n    }\\n\\n    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);\\n\\n    event PacketDelivered(MessageOrigin origin, address receiver, bytes32 payloadHash);\\n\\n    event PacketReceived(MessageOrigin origin, address receiver);\\n\\n    event LzReceiveFailed(MessageOrigin origin, address receiver, bytes reason);\\n\\n    event FeePaid(MessagingFee fee);\\n\\n    event LayerZeroTokenSet(address token);\\n\\n    function quote(\\n        address _sender,\\n        uint32 _dstEid,\\n        bytes calldata _message,\\n        bool _payInLzToken,\\n        bytes calldata _options\\n    ) external view returns (MessagingFee memory);\\n\\n    function send(\\n        MessagingParams calldata _params,\\n        uint _lzTokenFee,\\n        address payable _refundAddress\\n    ) external payable returns (MessagingReceipt memory);\\n\\n    function sendWithAlt(\\n        MessagingParams calldata _params,\\n        uint _lzTokenFee,\\n        uint _altTokenFee\\n    ) external returns (MessagingReceipt memory);\\n\\n    function deliver(MessageOrigin calldata _origin, address _receiver, bytes32 _payloadHash) external;\\n\\n    function deliverable(\\n        MessageOrigin calldata _origin,\\n        address _receiveLib,\\n        address _receiver\\n    ) external view returns (bool);\\n\\n    function lzReceive(\\n        MessageOrigin calldata _origin,\\n        address _receiver,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        bytes calldata _extraData\\n    ) external payable returns (bool, bytes memory);\\n\\n    // oapp can burn messages partially by calling this function with its own business logic if messages are delivered in order\\n    function clear(MessageOrigin calldata _origin, bytes32 _guid, bytes calldata _message) external;\\n\\n    function setLayerZeroToken(address _layerZeroToken) external;\\n\\n    function layerZeroToken() external view returns (address);\\n\\n    function altFeeToken() external view returns (address);\\n}\\n\",\"keccak256\":\"0x93a91a12df3614cabdd1964097718da66cb8487964ad7f013a6f5f2dd507f768\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IMessageOrigin.sol\\\";\\n\\ninterface ILayerZeroReceiver is IMessageOrigin {\\n    function nextNonce(uint32 _eid, bytes32 _sender) external view returns (uint64);\\n\\n    function lzReceive(\\n        MessageOrigin calldata _origin,\\n        bytes32 _guid,\\n        bytes memory _message,\\n        address _executor,\\n        bytes calldata _extraData\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0xe1e716f2016fe17aeeed4b41a37b6ce9a163e719a5c8e1c5e6be41d64fb701ee\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessageLibManager {\\n    struct SetConfigParam {\\n        uint32 configType;\\n        bytes config;\\n    }\\n\\n    struct Timeout {\\n        address lib;\\n        uint expiry;\\n    }\\n\\n    event LibraryRegistered(address newLib);\\n    event DefaultSendLibrarySet(uint32 eid, address newLib);\\n    event DefaultReceiveLibrarySet(uint32 eid, address oldLib, address newLib);\\n    event DefaultReceiveLibraryTimeoutSet(uint32 eid, address oldLib, uint expiry);\\n    event SendLibrarySet(address sender, uint32 eid, address newLib);\\n    event ReceiveLibrarySet(address receiver, uint32 eid, address oldLib, address newLib);\\n    event ReceiveLibraryTimoutSet(address receiver, uint32 eid, address oldLib, uint timeout);\\n\\n    function registerLibrary(address _lib) external;\\n\\n    function isRegisteredLibrary(address _lib) external view returns (bool);\\n\\n    function getRegisteredLibraries() external view returns (address[] memory);\\n\\n    function setDefaultSendLibrary(uint32 _eid, address _newLib) external;\\n\\n    function defaultSendLibrary(uint32 _eid) external view returns (address);\\n\\n    function setDefaultReceiveLibrary(uint32 _eid, address _newLib, uint _timeout) external;\\n\\n    function defaultReceiveLibrary(uint32 _eid) external view returns (address);\\n\\n    function setDefaultReceiveLibraryTimeout(uint32 _eid, address _lib, uint _expiry) external;\\n\\n    function defaultReceiveLibraryTimeout(uint32 _eid) external view returns (address lib, uint expiry);\\n\\n    function defaultConfig(address _lib, uint32 _eid, uint32 _configType) external view returns (bytes memory);\\n\\n    function isSupportedEid(uint32 _eid) external view returns (bool);\\n\\n    /// ------------------- OApp interfaces -------------------\\n    function setSendLibrary(uint32 _eid, address _newLib) external;\\n\\n    function getSendLibrary(address _sender, uint32 _eid) external view returns (address lib);\\n\\n    function isDefaultSendLibrary(address _sender, uint32 _eid) external view returns (bool);\\n\\n    function setReceiveLibrary(uint32 _eid, address _newLib, uint _gracePeriod) external;\\n\\n    function getReceiveLibrary(address _receiver, uint32 _eid) external view returns (address lib, bool isDefault);\\n\\n    function setReceiveLibraryTimeout(uint32 _eid, address _lib, uint _gracePeriod) external;\\n\\n    function receiveLibraryTimeout(address _receiver, uint32 _eid) external view returns (address lib, uint expiry);\\n\\n    function setConfig(address _lib, uint32 _eid, SetConfigParam[] calldata _params) external;\\n\\n    function getConfig(\\n        address _oapp,\\n        address _lib,\\n        uint32 _eid,\\n        uint32 _configType\\n    ) external view returns (bytes memory config, bool isDefault);\\n\\n    function snapshotConfig(address _lib, uint32[] calldata _eids) external;\\n\\n    function resetConfig(address _lib, uint32[] calldata _eids) external;\\n}\\n\",\"keccak256\":\"0xb013b61a9b8c4950aa5bfa966dc4876203dd8a3f55a890cd107f549edca41463\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageOrigin.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessageOrigin {\\n    struct MessageOrigin {\\n        uint32 srcEid;\\n        bytes32 sender;\\n        uint64 nonce;\\n    }\\n}\\n\",\"keccak256\":\"0x17fe98500a8ff512f22020c5a9522b676af101e6fc11a073ebf162ea02aa2f47\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessagingChannel {\\n    event InboundNonceSkipped(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce);\\n\\n    function eid() external view returns (uint32);\\n\\n    // this is an emergency function if a message can not be delivered for some reasons\\n    // required to provide _nextNonce to avoid race condition\\n    function skip(uint32 _srcEid, bytes32 _sender, uint64 _nonce) external;\\n\\n    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32);\\n\\n    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\\n\\n    function outboundNonce(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (uint64);\\n\\n    function inboundPayloadHash(\\n        address _receiver,\\n        uint32 _srcEid,\\n        bytes32 _sender,\\n        uint64 _nonce\\n    ) external view returns (bytes32);\\n\\n    function hasPayloadHash(\\n        address _receiver,\\n        uint32 _srcEid,\\n        bytes32 _sender,\\n        uint64 _nonce\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xe9c180ca201e8af11747079224729e0552addf70d65c60e7a61a4624a28d4e5c\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingComposer.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessagingComposer {\\n    event ComposedMessageDelivered(address receiver, address composer, bytes32 guid, bytes message);\\n    event ComposedMessageReceived(\\n        address receiver,\\n        address composer,\\n        bytes32 guid,\\n        bytes32 messageHash,\\n        address caller\\n    );\\n    event LzComposeFailed(\\n        address sender,\\n        address receiver,\\n        bytes32 guid,\\n        bytes32 messageHash,\\n        address caller,\\n        bytes reason\\n    );\\n\\n    function deliverComposedMessage(address _composer, bytes32 _guid, bytes calldata _message) external;\\n\\n    function lzCompose(\\n        address _receiver,\\n        address _composer,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        bytes calldata _extraData\\n    ) external payable returns (bool, bytes memory);\\n}\\n\",\"keccak256\":\"0x3993726690a51a8660c2145d3d1483e03d93de7a578afc4130467bf6804f6896\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingContext.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessagingContext {\\n    function isSendingMessage() external view returns (bool);\\n\\n    function getSendContext() external view returns (uint32, address);\\n}\\n\",\"keccak256\":\"0x6af87d5d41d060363fe554ff0ce9138f1ad8e20c1aaeec777d4132fc505e74e8\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nlibrary CalldataBytesLib {\\n    function toU8(bytes calldata _bytes, uint _start) internal pure returns (uint8) {\\n        return uint8(_bytes[_start]);\\n    }\\n\\n    function toU16(bytes calldata _bytes, uint _start) internal pure returns (uint16) {\\n        unchecked {\\n            uint end = _start + 2;\\n            return uint16(bytes2(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toU32(bytes calldata _bytes, uint _start) internal pure returns (uint32) {\\n        unchecked {\\n            uint end = _start + 4;\\n            return uint32(bytes4(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toU64(bytes calldata _bytes, uint _start) internal pure returns (uint64) {\\n        unchecked {\\n            uint end = _start + 8;\\n            return uint64(bytes8(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toU128(bytes calldata _bytes, uint _start) internal pure returns (uint128) {\\n        unchecked {\\n            uint end = _start + 16;\\n            return uint128(bytes16(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toU256(bytes calldata _bytes, uint _start) internal pure returns (uint256) {\\n        unchecked {\\n            uint end = _start + 32;\\n            return uint256(bytes32(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toAddr(bytes calldata _bytes, uint _start) internal pure returns (address) {\\n        unchecked {\\n            uint end = _start + 20;\\n            return address(bytes20(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toB32(bytes calldata _bytes, uint _start) internal pure returns (bytes32) {\\n        unchecked {\\n            uint end = _start + 32;\\n            return bytes32(_bytes[_start:end]);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6984a7e7f292ec4533ac684583e5d0505bee3bc4348776072413ceb521a6acc8\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Errors {\\n    // Invalid Argument (http: 400)\\n    string internal constant INVALID_ARGUMENT = \\\"LZ10000\\\";\\n    string internal constant ONLY_REGISTERED = \\\"LZ10001\\\";\\n    string internal constant ONLY_REGISTERED_OR_DEFAULT = \\\"LZ10002\\\";\\n    string internal constant INVALID_AMOUNT = \\\"LZ10003\\\";\\n    string internal constant INVALID_NONCE = \\\"LZ10004\\\";\\n    string internal constant SAME_VALUE = \\\"LZ10005\\\";\\n    string internal constant UNSORTED = \\\"LZ10006\\\";\\n    string internal constant INVALID_VERSION = \\\"LZ10007\\\";\\n    string internal constant INVALID_EID = \\\"LZ10008\\\";\\n    string internal constant INVALID_SIZE = \\\"LZ10009\\\";\\n    string internal constant ONLY_NON_DEFAULT = \\\"LZ10010\\\";\\n    string internal constant INVALID_VERIFIERS = \\\"LZ10011\\\";\\n    string internal constant DUPLICATED = \\\"LZ10012\\\";\\n    string internal constant INVALID_WORKER_ID = \\\"LZ10013\\\";\\n\\n    // Out of Range (http: 400)\\n    string internal constant OUT_OF_RANGE = \\\"LZ20000\\\";\\n\\n    // Invalid State (http: 400)\\n    string internal constant INVALID_STATE = \\\"LZ30000\\\";\\n    string internal constant SEND_REENTRANCY = \\\"LZ30001\\\";\\n    string internal constant RECEIVE_REENTRANCY = \\\"LZ30002\\\";\\n    string internal constant COMPOSE_REENTRANCY = \\\"LZ30003\\\";\\n\\n    // Permission Denied (http: 403)\\n    string internal constant PERMISSION_DENIED = \\\"LZ50000\\\";\\n\\n    // Not Found (http: 404)\\n    string internal constant NOT_FOUND = \\\"LZ60000\\\";\\n\\n    // Already Exists (http: 409)\\n    string internal constant ALREADY_EXISTS = \\\"LZ80000\\\";\\n\\n    // Not Implemented (http: 501)\\n    string internal constant NOT_IMPLEMENTED = \\\"LZC0000\\\";\\n    string internal constant UNSUPPORTED_INTERFACE = \\\"LZC0001\\\";\\n\\n    // Unavailable (http: 503)\\n    string internal constant UNAVAILABLE = \\\"LZD0000\\\";\\n    string internal constant NATIVE_COIN_UNAVAILABLE = \\\"LZD0001\\\";\\n    string internal constant TOKEN_UNAVAILABLE = \\\"LZD0002\\\";\\n    string internal constant DEFAULT_LIBRARY_UNAVAILABLE = \\\"LZD0003\\\";\\n    string internal constant VERIFIERS_UNAVAILABLE = \\\"LZD0004\\\";\\n}\\n\",\"keccak256\":\"0x00c68dee6968a14fa9a120a7447a3f568379c86f2a59d363e902128d4f361a6e\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/BitMaps.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\n// modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/BitMaps.sol\\npragma solidity ^0.8.19;\\n\\nlibrary BitMaps {\\n    type BitMap256 is uint;\\n\\n    /**\\n     * @dev Returns whether the bit at `index` is set.\\n     */\\n    function get(BitMap256 bitmap, uint8 index) internal pure returns (bool) {\\n        uint256 mask = 1 << (index & 0xff);\\n        return BitMap256.unwrap(bitmap) & mask != 0;\\n    }\\n\\n    /**\\n     * @dev Sets the bit at `index`.\\n     */\\n    function set(BitMap256 bitmap, uint8 index) internal pure returns (BitMap256) {\\n        uint256 mask = 1 << (index & 0xff);\\n        return BitMap256.wrap(BitMap256.unwrap(bitmap) | mask);\\n    }\\n}\\n\",\"keccak256\":\"0x29b1fb7dda9d3d6a699938da8610c0aa58d2eeb4244c6889a657eaf24117ac8e\",\"license\":\"BUSL-1.1\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/ExecutorOptions.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../libs/Errors.sol\\\";\\nimport \\\"../../libs/CalldataBytesLib.sol\\\";\\n\\nlibrary ExecutorOptions {\\n    using CalldataBytesLib for bytes;\\n\\n    uint8 internal constant WORKER_ID = 1;\\n\\n    uint8 internal constant OPTION_TYPE_LZRECEIVE = 1;\\n    uint8 internal constant OPTION_TYPE_AIRDROP = 2;\\n    uint8 internal constant OPTION_TYPE_LZCOMPOSE = 3;\\n    uint8 internal constant OPTION_TYPE_ORDERED_EXECUTION = 4;\\n\\n    /// @dev decode the next executor option from the options starting from the specified cursor\\n    /// @param _options [executor_id][executor_option][executor_id][executor_option]...\\n    ///        executor_option = [option_size][option_type][option]\\n    ///        option_size = len(option_type) + len(option)\\n    ///        executor_id: uint8, option_size: uint16, option_type: uint8, option: bytes\\n    /// @param _cursor the cursor to start decoding from\\n    /// @return optionType the type of the option\\n    /// @return option the option of the executor\\n    /// @return cursor the cursor to start decoding the next executor option\\n    function nextExecutorOption(\\n        bytes calldata _options,\\n        uint _cursor\\n    ) internal pure returns (uint8 optionType, bytes calldata option, uint cursor) {\\n        unchecked {\\n            // skip worker id\\n            cursor = _cursor + 1;\\n\\n            // read option size\\n            uint16 size = _options.toU16(cursor);\\n            cursor += 2;\\n\\n            // read option type\\n            optionType = _options.toU8(cursor);\\n\\n            // startCursor and endCursor are used to slice the option from _options\\n            uint startCursor = cursor + 1; // skip option type and verifier_idx\\n            uint endCursor = cursor + size;\\n            option = _options[startCursor:endCursor];\\n            cursor += size;\\n        }\\n    }\\n\\n    function decodeLzReceiveOption(bytes calldata _option) internal pure returns (uint128 gas, uint128 value) {\\n        require(_option.length == 16 || _option.length == 32, Errors.INVALID_SIZE);\\n        gas = _option.toU128(0);\\n        value = _option.length == 32 ? _option.toU128(16) : 0;\\n    }\\n\\n    function decodeAirdropOption(bytes calldata _option) internal pure returns (uint128 amount, bytes32 receiver) {\\n        require(_option.length == 48, Errors.INVALID_SIZE);\\n        amount = _option.toU128(0);\\n        receiver = _option.toB32(16);\\n    }\\n\\n    function decodeLzComposeOption(bytes calldata _option) internal pure returns (uint128 gas, uint128 value) {\\n        require(_option.length == 16 || _option.length == 32, Errors.INVALID_SIZE);\\n        gas = _option.toU128(0);\\n        value = _option.length == 32 ? _option.toU128(16) : 0;\\n    }\\n\\n    function encodeLzReceiveOption(uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\\n        return _value == 0 ? abi.encodePacked(_gas) : abi.encodePacked(_gas, _value);\\n    }\\n\\n    function encodeAirdropOption(uint128 _amount, bytes32 _receiver) internal pure returns (bytes memory) {\\n        return abi.encodePacked(_amount, _receiver);\\n    }\\n\\n    function encodeLzComposeOption(uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\\n        return _value == 0 ? abi.encodePacked(_gas) : abi.encodePacked(_gas, _value);\\n    }\\n}\\n\",\"keccak256\":\"0x2d317c33c60f628c83625a2622a76891789b7388b06596564bd08ae6af11058a\",\"license\":\"BUSL-1.1\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xba43b97fba0d32eb4254f6a5a297b39a19a247082a02d6e69349e071e2946218\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x3088eb2868e8d13d89d16670b5f8612c4ab9ff8956272837d8e90106c59c14a0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x52a8cfb0f5239d11b457dcdd1b326992ef672714ca8da71a157255bddd13f3ad\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"},\"contracts/OApp.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./interfaces/IOApp.sol\\\";\\nimport \\\"./interfaces/IPreCrime.sol\\\";\\n\\n/// @dev the template class for OApps. Refer to the OmniCounter for examples\\nabstract contract OApp is IOApp, Ownable {\\n    /// @dev we version the OApp to version the OApp Behaviours (e.g. future version might have different precrime interfaces)\\n    uint public constant override version = 1;\\n    ILayerZeroEndpointV2 public immutable endpoint;\\n    mapping(uint32 => bytes32) public peers;\\n\\n    IPreCrime public precrime;\\n\\n    constructor(address _endpoint) {\\n        endpoint = ILayerZeroEndpointV2(_endpoint);\\n    }\\n\\n    /// @dev the generic send interface to interact with the LayerZero EndpointV2.quote()\\n    function _quote(\\n        uint32 _eid,\\n        bytes memory _message,\\n        bool _useLZToken,\\n        bytes memory _options\\n    ) internal view virtual returns (uint nativeFee, uint lzTokenFee) {\\n        ILayerZeroEndpointV2.MessagingFee memory fee = endpoint.quote(\\n            address(this),\\n            _eid,\\n            _message,\\n            _useLZToken,\\n            _options\\n        );\\n        return (fee.nativeFee, fee.lzTokenFee);\\n    }\\n\\n    /// @dev the generic send interface to interact with the LayerZero EndpointV2.send()\\n    function _lzSend(\\n        ILayerZeroEndpointV2.MessagingParams memory _msgParams,\\n        ILayerZeroEndpointV2.MessagingFee memory _fee,\\n        address payable _refundAddress\\n    ) internal virtual returns (ILayerZeroEndpointV2.MessagingReceipt memory) {\\n        ILayerZeroEndpointV2.MessagingReceipt memory receipt = endpoint.send{value: _fee.nativeFee}(\\n            _msgParams,\\n            _fee.lzTokenFee,\\n            _refundAddress\\n        );\\n        return receipt;\\n    }\\n\\n    /// @dev Oapp can override this interface for custom logics (e.g. more assertion)\\n    function lzReceive(\\n        MessageOrigin calldata _origin,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        address _executor,\\n        bytes calldata _extraData\\n    ) public payable virtual {\\n        // assert the call is from the endpoint\\n        if (address(endpoint) != msg.sender) revert EndpointOnly(msg.sender);\\n        // assert that it is from a trusted peer\\n        if (safeGetPeer(_origin.srcEid) != _origin.sender) revert InvalidPeer(_origin.sender);\\n        // assert that the nonce is acceptable\\n        _acceptNonce(_origin.srcEid, _origin.sender, _origin.nonce);\\n\\n        // perform the state transition logic\\n        _lzReceive(_origin, _guid, _message, _executor, _extraData);\\n    }\\n\\n    /// @dev needs to be implemented by the OApp\\n    /// @dev basic security checks are already performed\\n    function _lzReceive(\\n        MessageOrigin calldata _origin,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        address _executor,\\n        bytes calldata _extraData\\n    ) internal virtual;\\n\\n    /// @dev a generic interface for precrime simulations\\n    /// @dev this function reverts at the end with the simulation results\\n    /// @dev value is provided as a lump sum, does not restrict how much each packet can consume\\n    function lzReceiveAndRevert(IPreCrime.Packet[] calldata _packets) external payable virtual override {\\n        if (address(precrime) != msg.sender) revert PreCrimeOnly(msg.sender);\\n\\n        for (uint i = 0; i < _packets.length; i++) {\\n            IPreCrime.Packet calldata packet = _packets[i];\\n            bytes32 peer = safeGetPeer(packet.origin.srcEid);\\n            if (peer != packet.origin.sender) {\\n                // packet from untrusted peer cannot be lzReceived, hence cannot change state\\n                continue;\\n            }\\n            // don't need to accept nonce, as by precrime protocol, all packets are sorted\\n            _lzReceive(packet.origin, packet.guid, packet.message, msg.sender, packet.callParams);\\n        }\\n        revert IPreCrime.LzReceiveRevert(1, precrime.simulationCallback());\\n    }\\n\\n    /// @dev path nonce starts from 1. if 0 it means that there is no specific nonce enforcement\\n    /// @dev only used to guide the executor actions if the app specify the msg execution to be ordered.\\n    function nextNonce(uint32 /*_srcEid*/, bytes32 /*_sender*/) public view virtual returns (uint64) {\\n        return 0;\\n    }\\n\\n    /// @dev if the app wants to enforce ordered execution, it should override this function to return the correct value\\n    /// @dev check OmniCounter for example\\n    function _acceptNonce(uint32 /*_srcEid*/, bytes32 /*_sender*/, uint64 /*_nonce*/) internal virtual {\\n        // do nth by default\\n    }\\n\\n    /// @dev receive native tokens. this might be used for the endpoint to refund\\n    receive() external payable virtual {}\\n\\n    /// ----------------------------- OAPP Config Functions -----------------------------\\n\\n    /// @dev set _peer to bytes32(0) (the default value) to \\\"untrust\\\"\\n    function setPeer(uint32 _eid, bytes32 _peer, bool _active) public virtual onlyOwner {\\n        bool currentlyActive = peers[_eid] != bytes32(0);\\n        if (currentlyActive == _active) revert InvalidPeerState();\\n\\n        peers[_eid] = _peer;\\n        emit SetPeer(_eid, _peer, _active);\\n    }\\n\\n    /// @dev check non-zero peer and return it\\n    function safeGetPeer(uint32 _eid) public view virtual returns (bytes32 peer) {\\n        peer = peers[_eid];\\n        if (peer == bytes32(0)) revert NoPeerSet(_eid);\\n    }\\n\\n    /// @dev set the precrime contract. can upgrade the precrime implementation overtime\\n    function setPrecrime(address _precrime) external onlyOwner {\\n        precrime = IPreCrime(_precrime);\\n        emit SetPrecrime(_precrime);\\n    }\\n\\n    /// @dev a generic interface to set the endpoint config\\n    /// @dev this is a low level interface, and should be used with caution\\n    /// @dev use our SDK to generate the properly abi.encoded config\\n    function setEndpointConfig(bytes calldata _config) public virtual onlyOwner {\\n        bytes4 functionSig = bytes4(_config);\\n        require(\\n            functionSig == IMessageLibManager.setConfig.selector ||\\n                functionSig == IMessageLibManager.snapshotConfig.selector ||\\n                functionSig == IMessageLibManager.resetConfig.selector ||\\n                functionSig == IMessageLibManager.setReceiveLibrary.selector ||\\n                functionSig == IMessageLibManager.setSendLibrary.selector ||\\n                functionSig == IMessageLibManager.setReceiveLibraryTimeout.selector,\\n            \\\"OApp: function not allowed\\\"\\n        );\\n\\n        (bool success, bytes memory reason) = address(endpoint).call(_config);\\n        if (!success) {\\n            assembly {\\n                revert(add(reason, 32), mload(reason))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xadc593b1f8410b831bc2c0b0b9fbbce8181fe79680c97fd9b7e792d7fc1251a1\",\"license\":\"MIT\"},\"contracts/PreCrime.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./PreCrimeBase.sol\\\";\\n\\nabstract contract PreCrime is PreCrimeBase {\\n    error SimulateRevert(uint16 code, bytes message);\\n\\n    constructor(address _endpoint) PreCrimeBase(_endpoint) {}\\n\\n    function simulate(Packet[] calldata _packets) external payable override returns (uint16 code, bytes memory data) {\\n        (code, data) = _checkPacketsMaxSizeAndNonceOrder(_packets);\\n        if (code != CODE_SUCCESS) {\\n            return (code, data);\\n        }\\n\\n        (bool success, bytes memory result) = address(this).call{value: msg.value}(\\n            abi.encodeWithSelector(this._simulateAndRevert.selector, _packets)\\n        );\\n        // refund for those who send eth to simulate accidentally\\n        if (msg.value > 0) {\\n            payable(msg.sender).transfer(msg.value);\\n        }\\n        // the _simulateAndRevert will never return success\\n        require(!success, \\\"simulate should never return success\\\");\\n\\n        (code, data) = _parseRevertResult(result, SimulateRevert.selector);\\n        if (code == CODE_SUCCESS) {\\n            data = abi.encode(localEid, data); // add localEid to the header\\n        }\\n    }\\n\\n    function simulateView(\\n        Packet[] calldata /*_packets*/\\n    ) external pure override returns (uint16 /*code*/, bytes memory /*result*/) {\\n        revert(\\\"not implemented\\\");\\n    }\\n\\n    function _parseRevertResult(\\n        bytes memory result,\\n        bytes4 _selector\\n    ) internal pure returns (uint16 code, bytes memory data) {\\n        // if not expected selector, bubble up error\\n        if (bytes4(result) != _selector) {\\n            assembly {\\n                revert(add(result, 0x20), mload(result))\\n            }\\n        }\\n        // parse code and result\\n        assembly {\\n            // Slice the sighash. Remove the selector which is the first 4 bytes\\n            result := add(result, 0x04)\\n        }\\n        return abi.decode(result, (uint16, bytes));\\n    }\\n\\n    function _simulateAndRevert(Packet[] calldata _packets) external payable {\\n        require(msg.sender == address(this), \\\"Precrime: only self\\\");\\n        (uint16 code, bytes memory result) = _simulate(_packets);\\n        revert SimulateRevert(code, result);\\n    }\\n\\n    // ----------------- to be implemented -----------------\\n    function _simulate(Packet[] calldata _packets) internal virtual returns (uint16 code, bytes memory result);\\n}\\n\",\"keccak256\":\"0x18411186959a83159508f0c56dc8fe152c5f210cfd539712432cdc19cd68ca62\",\"license\":\"MIT\"},\"contracts/PreCrimeBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\\\";\\nimport \\\"./interfaces/IPreCrime.sol\\\";\\n\\nabstract contract PreCrimeBase is IPreCrime {\\n    uint16 internal constant PRECRIME_VERSION = 1;\\n    uint16 internal constant CONFIG_VERSION = 1;\\n\\n    //---------------- error code ----------------------\\n    // --- UA scope code ---\\n    uint16 internal constant CODE_SUCCESS = 0; // success\\n    uint16 internal constant CODE_PRECRIME_FAILURE = 1; // !!! crimes found\\n\\n    // --- protocol scope error code ---\\n    // simualte\\n    uint16 internal constant CODE_PACKETS_OVERSIZE = 400; // packets number bigger then max size\\n    uint16 internal constant CODE_PACKETS_UNSORTED = 401; // packets are unsorted, need backfill and keep order\\n    // precrime\\n    uint16 internal constant CODE_MISS_SIMULATE_RESULT = 402; // miss simulation result\\n\\n    ILayerZeroEndpointV2 internal immutable lzEndpoint;\\n    uint32 internal immutable localEid;\\n\\n    address public pAdmin;\\n\\n    uint64 public pMaxBatchSize;\\n    uint32[] public precrimeEids;\\n    bytes32[] public precrimePeers;\\n    mapping(uint32 eid => bytes32 peer) public precrimeEidToPeer;\\n\\n    modifier onlyPrecrimeAdmin() {\\n        require(msg.sender == pAdmin, \\\"only admin\\\");\\n        _;\\n    }\\n\\n    constructor(address _endpoint) {\\n        lzEndpoint = ILayerZeroEndpointV2(_endpoint);\\n        localEid = lzEndpoint.eid();\\n        pAdmin = msg.sender;\\n    }\\n\\n    // ----------------- admin functions -----------------\\n    function setPrecrimeAdmin(address _admin) external onlyPrecrimeAdmin {\\n        pAdmin = _admin;\\n    }\\n\\n    function setPrecrimeMaxBatchSize(uint64 _maxBatchSize) external onlyPrecrimeAdmin {\\n        pMaxBatchSize = _maxBatchSize;\\n    }\\n\\n    function setPrecrimePeers(uint32[] memory _eids, bytes32[] memory _peers) external onlyPrecrimeAdmin {\\n        precrimeEids = _eids;\\n        precrimePeers = _peers;\\n        for (uint i = 0; i < _eids.length; i++) {\\n            precrimeEidToPeer[_eids[i]] = _peers[i];\\n        }\\n    }\\n\\n    // ----------------- view functions -----------------\\n\\n    function getPrecrimeConfig(Packet[] calldata _packets) external view virtual override returns (bytes memory) {\\n        (uint32[] memory eids, bytes32[] memory peers) = _getPrecrimePeers(_packets);\\n        return\\n            abi.encodePacked(\\n                CONFIG_VERSION,\\n                //---- max packets size for simulate batch ---\\n                pMaxBatchSize,\\n                //------------- peer precrimes -------------\\n                eids.length,\\n                eids,\\n                peers\\n            );\\n    }\\n\\n    // TODO packets is a completely optional parameter? it can be empty and doesnt do any validation in that case\\n    function precrime(\\n        Packet[] calldata _packets,\\n        bytes[] calldata _simulation\\n    ) external view override returns (uint16 code, bytes memory reason) {\\n        bytes[] memory originSimulateResult = new bytes[](_simulation.length);\\n        uint32[] memory eids = new uint32[](_simulation.length);\\n\\n        // extract all of the eids and results from the simulations\\n        for (uint256 i = 0; i < _simulation.length; i++) {\\n            (uint32 eid, bytes memory simulateResult) = abi.decode(_simulation[i], (uint32, bytes));\\n            eids[i] = eid;\\n            originSimulateResult[i] = simulateResult;\\n        }\\n\\n        (code, reason) = _checkResultsCompleteness(_packets, eids);\\n        if (code != CODE_SUCCESS) {\\n            return (code, reason);\\n        }\\n\\n        (code, reason) = _precrime(originSimulateResult);\\n    }\\n\\n    function precrimeVersion() external pure override returns (uint16) {\\n        return PRECRIME_VERSION;\\n    }\\n\\n    function _checkResultsCompleteness(\\n        Packet[] calldata _packets,\\n        uint32[] memory _resultEids\\n    ) internal view returns (uint16 code, bytes memory reason) {\\n        // check if all peers result included\\n        if (_packets.length > 0) {\\n            (uint32[] memory eids, ) = _getPrecrimePeers(_packets);\\n            for (uint256 i = 0; i < eids.length; i++) {\\n                bool resultEidChecked;\\n                for (uint256 j = 0; j < _resultEids.length; j++) {\\n                    if (_resultEids[j] == eids[i]) {\\n                        resultEidChecked = true;\\n                        break;\\n                    }\\n                }\\n                if (!resultEidChecked) {\\n                    return (CODE_MISS_SIMULATE_RESULT, \\\"missing peer simulation result\\\");\\n                }\\n            }\\n        }\\n\\n        // check if local result included\\n        bool localEidResultChecked;\\n        for (uint256 j = 0; j < _resultEids.length; j++) {\\n            if (_resultEids[j] == localEid) {\\n                localEidResultChecked = true;\\n                break;\\n            }\\n        }\\n        if (!localEidResultChecked) {\\n            return (CODE_MISS_SIMULATE_RESULT, \\\"missing local simulation result\\\");\\n        }\\n\\n        return (CODE_SUCCESS, \\\"\\\");\\n    }\\n\\n    function _checkPacketsMaxSizeAndNonceOrder(\\n        Packet[] calldata _packets\\n    ) internal view returns (uint16 code, bytes memory reason) {\\n        if (_packets.length > pMaxBatchSize) {\\n            return (\\n                CODE_PACKETS_OVERSIZE,\\n                abi.encodePacked(\\\"packets size exceed limited \\\", Strings.toString(uint256(pMaxBatchSize)))\\n            );\\n        }\\n\\n        // check packets nonce, sequence order\\n        // packets should group by srcEid and sender, then sort by nonce ascending\\n        if (_packets.length > 0) {\\n            uint32 srcEid;\\n            bytes32 sender;\\n            uint64 nonce;\\n            for (uint256 i = 0; i < _packets.length; i++) {\\n                Packet memory packet = _packets[i];\\n                // start from a new chain packet or a new source UA\\n                if (packet.origin.srcEid != srcEid || packet.origin.sender != sender) {\\n                    srcEid = packet.origin.srcEid;\\n                    sender = packet.origin.sender;\\n                    nonce = packet.origin.nonce;\\n                    uint64 nextInboundNonce = lzEndpoint.inboundNonce(_receiver(), srcEid, sender) + 1;\\n                    // the first packet's nonce must equal to dst InboundNonce+1\\n                    if (nonce != nextInboundNonce) {\\n                        return (\\n                            CODE_PACKETS_UNSORTED,\\n                            abi.encodePacked(\\\"skipped inboundNonce, packet index: \\\", Strings.toString(i))\\n                        );\\n                    }\\n                } else {\\n                    // the following packet's nonce add 1 in order\\n                    if (packet.origin.nonce != ++nonce) {\\n                        return (\\n                            CODE_PACKETS_UNSORTED,\\n                            abi.encodePacked(\\\"unsorted packets, packet index: \\\", Strings.toString(i))\\n                        );\\n                    }\\n                }\\n            }\\n        }\\n        return (CODE_SUCCESS, \\\"\\\");\\n    }\\n\\n    // ----------------- to be implemented -----------------\\n    function _getPrecrimePeers(\\n        Packet[] calldata _packets\\n    ) internal view virtual returns (uint32[] memory, bytes32[] memory);\\n\\n    function _receiver() internal view virtual returns (address);\\n\\n    function _precrime(bytes[] memory _simulation) internal view virtual returns (uint16 code, bytes memory reason);\\n}\\n\",\"keccak256\":\"0xacc117d3687a4c601b38931a81722b53e861d546e7290ebfcdcae00e54c19701\",\"license\":\"MIT\"},\"contracts/examples/OmniCounter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../OApp.sol\\\";\\nimport \\\"../libs/OptionsBuilder.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroComposer.sol\\\";\\n\\nlibrary MsgCodec {\\n    uint8 internal constant VANILLA_TYPE = 1;\\n    uint8 internal constant COMPOSED_TYPE = 2;\\n    uint8 internal constant ABA_TYPE = 3;\\n    uint8 internal constant COMPOSED_ABA_TYPE = 4;\\n\\n    uint8 internal constant MSG_TYPE_OFFSET = 0;\\n    uint8 internal constant SRC_EID_OFFSET = 1;\\n\\n    function encode(uint8 _type, uint32 _srcEid) internal pure returns (bytes memory) {\\n        return abi.encodePacked(_type, _srcEid);\\n    }\\n\\n    function msgType(bytes calldata _message) internal pure returns (uint8) {\\n        return uint8(bytes1(_message[MSG_TYPE_OFFSET:SRC_EID_OFFSET]));\\n    }\\n\\n    function srcEid(bytes calldata _message) internal pure returns (uint32) {\\n        return uint32(bytes4(_message[SRC_EID_OFFSET:]));\\n    }\\n}\\n\\ncontract OmniCounter is ILayerZeroComposer, OApp {\\n    using MsgCodec for bytes;\\n    using OptionsBuilder for bytes;\\n\\n    uint public count;\\n    uint public composedCount;\\n\\n    address public admin;\\n    uint32 public eid;\\n\\n    mapping(uint32 srcEid => mapping(bytes32 sender => uint64 nonce)) private maxReceivedNonce;\\n    bool private orderedNonce;\\n\\n    // for global assertions\\n    mapping(uint32 srcEid => uint count) public inboundCount;\\n    mapping(uint32 dstEid => uint count) public outboundCount;\\n\\n    constructor(address _endpoint) OApp(_endpoint) {\\n        admin = msg.sender;\\n        eid = endpoint.eid();\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"only admin\\\");\\n        _;\\n    }\\n\\n    // -------------------------------\\n    // Only Admin\\n    function setAdmin(address _admin) external onlyAdmin {\\n        admin = _admin;\\n    }\\n\\n    function withdraw(address payable _to, uint _amount) external onlyAdmin {\\n        _to.transfer(_amount);\\n    }\\n\\n    // -------------------------------\\n    // Send\\n    function increment(uint32 _eid, uint8 _type, bytes calldata _options) external payable {\\n        _lzSend(\\n            ILayerZeroEndpointV2.MessagingParams(_eid, safeGetPeer(_eid), MsgCodec.encode(_type, eid), _options),\\n            ILayerZeroEndpointV2.MessagingFee(msg.value, 0),\\n            payable(msg.sender)\\n        );\\n        _incrementOutbound(_eid);\\n    }\\n\\n    // this is a broken function to skip incrementing outbound count\\n    // so that precrime will fail\\n    function brokenIncrement(uint32 _eid, uint8 _type, bytes calldata _options) external payable onlyAdmin {\\n        _lzSend(\\n            ILayerZeroEndpointV2.MessagingParams(_eid, safeGetPeer(_eid), MsgCodec.encode(_type, eid), _options),\\n            ILayerZeroEndpointV2.MessagingFee(msg.value, 0),\\n            payable(msg.sender)\\n        );\\n    }\\n\\n    function batchIncrement(\\n        uint32[] calldata _eids,\\n        uint8[] calldata _types,\\n        bytes[] calldata _options\\n    ) external payable {\\n        require(_eids.length == _options.length && _eids.length == _types.length, \\\"OmniCounter: length mismatch\\\");\\n\\n        ILayerZeroEndpointV2.MessagingReceipt memory receipt;\\n        uint providedFee = msg.value;\\n        for (uint i = 0; i < _eids.length; i++) {\\n            address refundAddress = i == _eids.length - 1 ? msg.sender : address(this);\\n            receipt = _lzSend(\\n                ILayerZeroEndpointV2.MessagingParams(\\n                    _eids[i],\\n                    safeGetPeer(_eids[i]),\\n                    MsgCodec.encode(_types[i], eid),\\n                    _options[i]\\n                ),\\n                ILayerZeroEndpointV2.MessagingFee(providedFee, 0),\\n                payable(refundAddress)\\n            );\\n            _incrementOutbound(_eids[i]);\\n            providedFee -= receipt.fee.nativeFee;\\n        }\\n    }\\n\\n    // -------------------------------\\n    // View\\n    function quote(\\n        uint32 _eid,\\n        uint8 _type,\\n        bytes calldata _options\\n    ) public view returns (uint nativeFee, uint zroFee) {\\n        return _quote(_eid, MsgCodec.encode(_type, eid), false, _options);\\n    }\\n\\n    // -------------------------------\\n    // Receive\\n    function _lzReceive(\\n        MessageOrigin calldata _origin,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        address /*_executor*/,\\n        bytes calldata /*_extraData*/\\n    ) internal override {\\n        uint8 messageType = _message.msgType();\\n\\n        if (messageType == MsgCodec.VANILLA_TYPE) {\\n            count++;\\n            _incrementInbound(_origin.srcEid);\\n        } else if (messageType == MsgCodec.COMPOSED_TYPE || messageType == MsgCodec.COMPOSED_ABA_TYPE) {\\n            count++;\\n            _incrementInbound(_origin.srcEid);\\n            endpoint.deliverComposedMessage(address(this), _guid, _message);\\n        } else if (messageType == MsgCodec.ABA_TYPE) {\\n            count++;\\n            _incrementInbound(_origin.srcEid);\\n\\n            // send back to the sender\\n            _incrementOutbound(_origin.srcEid);\\n            bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200000, 0);\\n            _lzSend(\\n                ILayerZeroEndpointV2.MessagingParams(\\n                    _origin.srcEid,\\n                    safeGetPeer(_origin.srcEid),\\n                    MsgCodec.encode(MsgCodec.VANILLA_TYPE, eid),\\n                    options\\n                ),\\n                ILayerZeroEndpointV2.MessagingFee(msg.value, 0),\\n                payable(address(this))\\n            );\\n        } else {\\n            revert(\\\"invalid message type\\\");\\n        }\\n    }\\n\\n    function _incrementInbound(uint32 _srcEid) internal {\\n        inboundCount[_srcEid]++;\\n    }\\n\\n    function _incrementOutbound(uint32 _dstEid) internal {\\n        outboundCount[_dstEid]++;\\n    }\\n\\n    function lzCompose(\\n        address /*_oapp*/,\\n        bytes32 /*_guid*/,\\n        bytes calldata _message,\\n        address,\\n        bytes calldata\\n    ) external payable override {\\n        require(msg.sender == address(endpoint), \\\"!endpoint\\\");\\n\\n        uint8 msgType = _message.msgType();\\n        if (msgType == MsgCodec.COMPOSED_TYPE) {\\n            composedCount += 1;\\n        } else if (msgType == MsgCodec.COMPOSED_ABA_TYPE) {\\n            composedCount += 1;\\n\\n            uint32 srcEid = _message.srcEid();\\n            _incrementOutbound(srcEid);\\n            bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200000, 0);\\n            _lzSend(\\n                ILayerZeroEndpointV2.MessagingParams(\\n                    srcEid,\\n                    safeGetPeer(srcEid),\\n                    MsgCodec.encode(MsgCodec.VANILLA_TYPE, eid),\\n                    options\\n                ),\\n                ILayerZeroEndpointV2.MessagingFee(msg.value, 0),\\n                payable(address(this))\\n            );\\n        } else {\\n            revert(\\\"invalid message type\\\");\\n        }\\n    }\\n\\n    // -------------------------------\\n    // Ordered OApp\\n    // this demonstrates how to build an app that requires execution nonce ordering\\n    // normally an app should decide ordered or not on contract construction\\n    // this is just a demo\\n    function setOrderedNonce(bool _orderedNonce) external onlyOwner {\\n        orderedNonce = _orderedNonce;\\n    }\\n\\n    function _acceptNonce(uint32 _srcEid, bytes32 _sender, uint64 _nonce) internal virtual override {\\n        uint64 currentNonce = maxReceivedNonce[_srcEid][_sender];\\n        if (orderedNonce) {\\n            require(_nonce == currentNonce + 1, \\\"OApp: invalid nonce\\\");\\n        }\\n        // update the max nonce anyway. once the ordered mode is turned on, missing early nonces will be rejected\\n        if (_nonce > currentNonce) {\\n            maxReceivedNonce[_srcEid][_sender] = _nonce;\\n        }\\n    }\\n\\n    function nextNonce(uint32 _srcEid, bytes32 _sender) public view virtual override returns (uint64) {\\n        if (orderedNonce) {\\n            return maxReceivedNonce[_srcEid][_sender] + 1;\\n        } else {\\n            return 0; // path nonce starts from 1. if 0 it means that there is no specific nonce enforcement\\n        }\\n    }\\n\\n    // a governance function to skip nonce\\n    function skipInboundNonce(uint32 _srcEid, bytes32 _sender, uint64 _nonce) public virtual onlyOwner {\\n        endpoint.skip(_srcEid, _sender, _nonce);\\n        if (orderedNonce) {\\n            maxReceivedNonce[_srcEid][_sender]++;\\n        }\\n    }\\n\\n    // be able to receive ether\\n    fallback() external payable {}\\n}\\n\",\"keccak256\":\"0x6b9352a710334c0afc99f23f1ad8df8b4e71eaa78ebf643dbfab812c7f09ce8b\",\"license\":\"MIT\"},\"contracts/examples/OmniCounterPreCrime.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IOApp.sol\\\";\\nimport \\\"../PreCrime.sol\\\";\\nimport \\\"./OmniCounter.sol\\\";\\n\\ncontract OmniCounterPreCrime is PreCrime {\\n    OmniCounter counter;\\n\\n    constructor(address _endpoint, address payable _counter) PreCrime(_endpoint) {\\n        counter = OmniCounter(_counter);\\n    }\\n\\n    struct Count {\\n        uint32 eid;\\n        uint inboundCount;\\n        uint outboundCount;\\n    }\\n\\n    struct SimulationResult {\\n        uint32 eid;\\n        Count[] counts;\\n    }\\n\\n    // -------------------------------\\n    // Internal\\n    function _findCounts(SimulationResult memory _result, uint32 _eid) internal pure returns (uint, uint) {\\n        for (uint i = 0; i < _result.counts.length; i++) {\\n            if (_result.counts[i].eid == _eid) {\\n                return (_result.counts[i].inboundCount, _result.counts[i].outboundCount);\\n            }\\n        }\\n        return (0, 0);\\n    }\\n\\n    // -------------------------------\\n    // Precrime\\n    function _receiver() internal view override returns (address) {\\n        return address(counter);\\n    }\\n\\n    // outboundCount >= inboundCount\\n    function _precrime(bytes[] memory _simulation) internal view override returns (uint16 code, bytes memory reason) {\\n        SimulationResult memory localResult;\\n        // decode results\\n        SimulationResult[] memory results = new SimulationResult[](_simulation.length);\\n        for (uint i = 0; i < _simulation.length; i++) {\\n            results[i] = abi.decode(_simulation[i], (SimulationResult));\\n\\n            if (results[i].eid == localEid) {\\n                localResult = results[i];\\n            }\\n        }\\n\\n        // check results\\n        for (uint i = 0; i < results.length; i++) {\\n            (uint _inboundCount, ) = _findCounts(localResult, results[i].eid);\\n            (, uint _outboundCount) = _findCounts(results[i], localEid);\\n\\n            if (_inboundCount > _outboundCount) {\\n                return (CODE_PRECRIME_FAILURE, \\\"OmniCounterPreCrime: inboundCount > outboundCount\\\");\\n            }\\n        }\\n        return (CODE_SUCCESS, \\\"\\\");\\n    }\\n\\n    function simulationCallback() external view override returns (bytes memory) {\\n        Count[] memory counts = new Count[](precrimeEids.length);\\n        for (uint i = 0; i < precrimeEids.length; i++) {\\n            uint32 remoteEid = precrimeEids[i];\\n            counts[i] = Count(remoteEid, counter.inboundCount(remoteEid), counter.outboundCount(remoteEid));\\n        }\\n        return abi.encode(SimulationResult(localEid, counts));\\n    }\\n\\n    function _simulate(Packet[] calldata _packets) internal override returns (uint16, bytes memory) {\\n        (bool success, bytes memory result) = address(counter).call{value: msg.value}(\\n            abi.encodeWithSelector(IOApp.lzReceiveAndRevert.selector, _packets)\\n        );\\n        require(!success, \\\"OmniCounterPreCrime: simulationCallback should be called via revert\\\");\\n\\n        (, result) = _parseRevertResult(result, LzReceiveRevert.selector);\\n        return (CODE_SUCCESS, result);\\n    }\\n\\n    function _getPrecrimePeers(\\n        Packet[] calldata _packets\\n    ) internal view override returns (uint32[] memory, bytes32[] memory) {\\n        if (_packets.length == 0) {\\n            return (precrimeEids, precrimePeers);\\n        }\\n\\n        // only return related peers\\n        return _filterByPackets(_packets);\\n    }\\n\\n    function _filterByPackets(\\n        Packet[] calldata _packets\\n    ) internal view returns (uint32[] memory eids, bytes32[] memory peers) {\\n        uint16 size;\\n        for (uint i = 0; i < _packets.length; i++) {\\n            // TODO we have access to origin.srcAddress, why not check this against the stored 'precrimeEidToPeer'?\\n            if (precrimeEidToPeer[_packets[i].origin.srcEid] != bytes32(0x0)) {\\n                size++;\\n            }\\n        }\\n\\n        eids = new uint32[](size);\\n        peers = new bytes32[](size);\\n        for (uint i = 0; i < _packets.length; i++) {\\n            bytes32 peer = precrimeEidToPeer[_packets[i].origin.srcEid];\\n            if (peer != bytes32(0x0)) {\\n                eids[i] = _packets[i].origin.srcEid;\\n                peers[i] = peer;\\n            }\\n        }\\n        return (eids, peers);\\n    }\\n}\\n\",\"keccak256\":\"0xb0086cb1d08aa453300a675f7a2a2ac7e3462f09c7fd9ed8711bcdde8521c12b\",\"license\":\"MIT\"},\"contracts/interfaces/IOApp.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol\\\";\\nimport \\\"./IPreCrime.sol\\\";\\n\\ninterface IOApp is ILayerZeroReceiver {\\n    function setEndpointConfig(bytes calldata _config) external;\\n\\n    function nextNonce(uint32 _srcEid, bytes32 _sender) external view returns (uint64);\\n\\n    function version() external view returns (uint);\\n\\n    function lzReceiveAndRevert(IPreCrime.Packet[] calldata _packets) external payable;\\n\\n    error EndpointOnly(address addr);\\n    error PreCrimeOnly(address addr);\\n    error InvalidPeer(bytes32 addr);\\n    error InvalidPeerState();\\n    error NoPeerSet(uint32 eid);\\n\\n    event SetPeer(uint32 remoteEid, bytes32 peer, bool active);\\n    event SetPrecrime(address precrime);\\n}\\n\",\"keccak256\":\"0xdc1b904112f784f4c55bfb3465bed56d4831cae9a7ee09ce4433b73fd2ef4177\",\"license\":\"MIT\"},\"contracts/interfaces/IPreCrime.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageOrigin.sol\\\";\\n\\ninterface IPreCrime is IMessageOrigin {\\n    error LzReceiveRevert(uint16 code, bytes result);\\n\\n    struct Packet {\\n        MessageOrigin origin;\\n        bytes32 guid;\\n        bytes message;\\n        bytes callParams;\\n    }\\n\\n    function getPrecrimeConfig(Packet[] calldata _packets) external view returns (bytes memory);\\n\\n    function precrime(\\n        Packet[] calldata _packets,\\n        bytes[] calldata _simulation\\n    ) external view returns (uint16 code, bytes memory reason);\\n\\n    function precrimeVersion() external view returns (uint16);\\n\\n    function simulate(Packet[] calldata _packets) external payable returns (uint16 code, bytes memory result);\\n\\n    function simulateView(Packet[] calldata _packets) external view returns (uint16 code, bytes memory result);\\n\\n    function simulationCallback() external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0xfc56771ce13a2eeb40097ea2c05a64caa55d1125a7dd2b2e03633604d7bdc8d7\",\"license\":\"MIT\"},\"contracts/libs/OptionsBuilder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/ExecutorOptions.sol\\\";\\nimport \\\"@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/libs/VerifierOptions.sol\\\";\\n\\nlibrary OptionsBuilder {\\n    using SafeCast for uint;\\n    using BytesLib for bytes;\\n\\n    uint16 internal constant TYPE_1 = 1; // legacy options type 1\\n    uint16 internal constant TYPE_2 = 2; // legacy options type 2\\n    uint16 internal constant TYPE_3 = 3;\\n\\n    modifier onlyType3(bytes memory _options) {\\n        require(_options.toUint16(0) == TYPE_3, \\\"OptionsBuilder: invalid options type\\\");\\n        _;\\n    }\\n\\n    function newOptions() internal pure returns (bytes memory) {\\n        return abi.encodePacked(TYPE_3);\\n    }\\n\\n    function addExecutorLzReceiveOption(\\n        bytes memory _options,\\n        uint128 _gas,\\n        uint128 _value\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        bytes memory option = ExecutorOptions.encodeLzReceiveOption(_gas, _value);\\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZRECEIVE, option);\\n    }\\n\\n    function addExecutorAirdropOption(\\n        bytes memory _options,\\n        uint128 _amount,\\n        bytes32 _receiver\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        bytes memory option = ExecutorOptions.encodeAirdropOption(_amount, _receiver);\\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_AIRDROP, option);\\n    }\\n\\n    function addExecutorLzComposeOption(\\n        bytes memory _options,\\n        uint128 _gas,\\n        uint128 _value\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        bytes memory option = ExecutorOptions.encodeLzComposeOption(_gas, _value);\\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZCOMPOSE, option);\\n    }\\n\\n    function addExecutorOrderedExecutionOption(\\n        bytes memory _options\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_ORDERED_EXECUTION, bytes(\\\"\\\"));\\n    }\\n\\n    function addVerifierPrecrimeOption(\\n        bytes memory _options,\\n        uint8 _verifierIdx\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        return addVerifierOption(_options, _verifierIdx, VerifierOptions.OPTION_TYPE_PRECRIME, bytes(\\\"\\\"));\\n    }\\n\\n    function addExecutorOption(\\n        bytes memory _options,\\n        uint8 _optionType,\\n        bytes memory _option\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                _options,\\n                ExecutorOptions.WORKER_ID,\\n                _option.length.toUint16() + 1, // +1 for optionType\\n                _optionType,\\n                _option\\n            );\\n    }\\n\\n    function addVerifierOption(\\n        bytes memory _options,\\n        uint8 _verifierIdx,\\n        uint8 _optionType,\\n        bytes memory _option\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                _options,\\n                VerifierOptions.WORKER_ID,\\n                _option.length.toUint16() + 2, // +2 for optionType and verifierIdx\\n                _verifierIdx,\\n                _optionType,\\n                _option\\n            );\\n    }\\n\\n    function encodeLegacyOptionsType1(uint _executionGas) internal pure returns (bytes memory) {\\n        require(_executionGas <= type(uint128).max, Errors.INVALID_SIZE);\\n        return abi.encodePacked(TYPE_1, _executionGas);\\n    }\\n\\n    function encodeLegacyOptionsType2(\\n        uint _executionGas,\\n        uint _amount,\\n        bytes memory _receiver // use bytes instead of bytes32 in legacy type 2\\n    ) internal pure returns (bytes memory) {\\n        require(\\n            _executionGas <= type(uint128).max && _amount <= type(uint128).max && _receiver.length <= 32,\\n            Errors.INVALID_SIZE\\n        );\\n        return abi.encodePacked(TYPE_2, _executionGas, _amount, _receiver);\\n    }\\n}\\n\",\"keccak256\":\"0xb0b9666bd73151ace3988bf55c2c20317e7b8eca7182b174e0c7a7e48005174a\",\"license\":\"MIT\"},\"solidity-bytes-utils/contracts/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\\u00e7alo S\\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity >=0.8.0 <0.9.0;\\n\\n\\nlibrary BytesLib {\\n    function concat(\\n        bytes memory _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(0x40, and(\\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n              not(31) // Round down to the nearest 32 bytes.\\n            ))\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes.slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes.slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                                ),\\n                                // and now shift left the number of bytes to\\n                                // leave space for the length in the slot\\n                                exp(0x100, sub(32, newlength))\\n                            ),\\n                            // increase length by the double of the memory\\n                            // bytes length\\n                            mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(\\n                    sc,\\n                    add(\\n                        and(\\n                            fslot,\\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\\n                        ),\\n                        and(mload(mc), mask)\\n                    )\\n                )\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let mlengthmod := mod(mlength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n                for {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_bytes.length >= _start + 1 , \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\n        require(_bytes.length >= _start + 2, \\\"toUint16_outOfBounds\\\");\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\\n        require(_bytes.length >= _start + 4, \\\"toUint32_outOfBounds\\\");\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\\n        require(_bytes.length >= _start + 8, \\\"toUint64_outOfBounds\\\");\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\\n        require(_bytes.length >= _start + 12, \\\"toUint96_outOfBounds\\\");\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\\n        require(_bytes.length >= _start + 16, \\\"toUint128_outOfBounds\\\");\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n        require(_bytes.length >= _start + 32, \\\"toUint256_outOfBounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n        require(_bytes.length >= _start + 32, \\\"toBytes32_outOfBounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                // the next line is the loop condition:\\n                // while(uint256(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(\\n        bytes storage _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes.slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes.slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint256(mc < end) + cb == 2)\\n                        for {} eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n}\\n\",\"keccak256\":\"0xf75784dfc94ea43668eb195d5690a1dde1b6eda62017e73a3899721583821d29\",\"license\":\"Unlicense\"}},\"version\":1}",
  "bytecode": "0x60c06040523480156200001157600080fd5b5060405162002edd38038062002edd833981016040819052620000349162000110565b8180806001600160a01b03166080816001600160a01b0316815250506080516001600160a01b031663416ecebf6040518163ffffffff1660e01b8152600401602060405180830381865afa15801562000091573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620000b791906200014f565b63ffffffff1660a052505060008054336001600160a01b031991821617909155600480549091166001600160a01b0392909216919091179055506200017e565b6001600160a01b03811681146200010d57600080fd5b50565b600080604083850312156200012457600080fd5b82516200013181620000f7565b60208401519092506200014481620000f7565b809150509250929050565b6000602082840312156200016257600080fd5b815163ffffffff811681146200017757600080fd5b9392505050565b60805160a051612d1d620001c060003960008181610a7901528181610d1701528181610f710152818161111d01526111f4015260006113a30152612d1d6000f3fe6080604052600436106100e85760003560e01c80636ece7d361161008a578063d2968d5711610059578063d2968d57146102b3578063e51ac4b0146102d5578063e780f25414610327578063fd4c212e1461034757600080fd5b80636ece7d36146102405780637a4359d51461026057806392d99a7f1461028057806399877564146102a057600080fd5b80632c79305d116100c65780632c79305d1461018357806330515e561461019f57806354b3ab69146101f15780635bf88a001461021e57600080fd5b806312fb9ea5146100ed57806328318b621461012057806329c246281461014e575b600080fd5b3480156100f957600080fd5b5061010d610108366004611e79565b61035a565b6040519081526020015b60405180910390f35b34801561012c57600080fd5b5061014061013b366004611ed7565b61037b565b604051610117929190611fb1565b34801561015a57600080fd5b5061016e610169366004611e79565b6104f5565b60405163ffffffff9091168152602001610117565b34801561018f57600080fd5b5060405160018152602001610117565b3480156101ab57600080fd5b506000546101d89074010000000000000000000000000000000000000000900467ffffffffffffffff1681565b60405167ffffffffffffffff9091168152602001610117565b3480156101fd57600080fd5b5061010d61020c366004611feb565b60036020526000908152604090205481565b34801561022a57600080fd5b5061023e61023936600461218b565b61052f565b005b34801561024c57600080fd5b5061023e61025b366004612263565b610657565b34801561026c57600080fd5b5061014061027b366004612280565b61072b565b34801561028c57600080fd5b5061023e61029b3660046122c2565b610793565b6101406102ae366004612280565b61085b565b3480156102bf57600080fd5b506102c8610ac6565b60405161011791906122f8565b3480156102e157600080fd5b506000546103029073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610117565b34801561033357600080fd5b506102c8610342366004612280565b610d62565b61023e610355366004612280565b610dbf565b6002818154811061036a57600080fd5b600091825260209091200154905081565b60006060818367ffffffffffffffff8111156103995761039961200f565b6040519080825280602002602001820160405280156103cc57816020015b60608152602001906001900390816103b75790505b50905060008467ffffffffffffffff8111156103ea576103ea61200f565b604051908082528060200260200182016040528015610413578160200160208202803683370190505b50905060005b858110156104b9576000808888848181106104365761043661230b565b9050602002810190610448919061233a565b8101906104559190612436565b915091508184848151811061046c5761046c61230b565b602002602001019063ffffffff16908163ffffffff1681525050808584815181106104995761049961230b565b6020026020010181905250505080806104b1906124ab565b915050610419565b506104c5888883610e6f565b909450925061ffff8416156104db5750506104ec565b6104e482611039565b909450925050505b94509492505050565b6001818154811061050557600080fd5b9060005260206000209060089182820401919006600402915054906101000a900463ffffffff1681565b60005473ffffffffffffffffffffffffffffffffffffffff1633146105b5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f6f6e6c792061646d696e0000000000000000000000000000000000000000000060448201526064015b60405180910390fd5b81516105c8906001906020850190611d7a565b5080516105dc906002906020840190611e29565b5060005b8251811015610652578181815181106105fb576105fb61230b565b6020026020010151600360008584815181106106195761061961230b565b602002602001015163ffffffff1663ffffffff16815260200190815260200160002081905550808061064a906124ab565b9150506105e0565b505050565b60005473ffffffffffffffffffffffffffffffffffffffff1633146106d8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f6f6e6c792061646d696e0000000000000000000000000000000000000000000060448201526064016105ac565b6000805467ffffffffffffffff90921674010000000000000000000000000000000000000000027fffffffff0000000000000000ffffffffffffffffffffffffffffffffffffffff909216919091179055565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f6e6f7420696d706c656d656e746564000000000000000000000000000000000060448201526000906060906064016105ac565b60005473ffffffffffffffffffffffffffffffffffffffff163314610814576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f6f6e6c792061646d696e0000000000000000000000000000000000000000000060448201526064016105ac565b600080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b60006060610869848461127f565b909250905061ffff8216610abf576000803073ffffffffffffffffffffffffffffffffffffffff163463fd4c212e60e01b88886040516024016108ad929190612590565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090941693909317909252905161093691906126c0565b60006040518083038185875af1925050503d8060008114610973576040519150601f19603f3d011682016040523d82523d6000602084013e610978565b606091505b50909250905034156109b25760405133903480156108fc02916000818181858888f193505050501580156109b0573d6000803e3d6000fd5b505b8115610a3f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526024808201527f73696d756c6174652073686f756c64206e657665722072657475726e2073756360448201527f636573730000000000000000000000000000000000000000000000000000000060648201526084016105ac565b610a69817f3ef0530200000000000000000000000000000000000000000000000000000000611588565b909450925061ffff8416610abc577f000000000000000000000000000000000000000000000000000000000000000083604051602001610aaa9291906126dc565b60405160208183030381529060405292505b50505b9250929050565b60015460609060009067ffffffffffffffff811115610ae757610ae761200f565b604051908082528060200260200182016040528015610b4257816020015b610b2f6040518060600160405280600063ffffffff16815260200160008152602001600081525090565b815260200190600190039081610b055790505b50905060005b600154811015610d0657600060018281548110610b6757610b6761230b565b600091825260209182902060088204015460408051606081018252600790931660049081026101000a90920463ffffffff16808452825491517f56a472890000000000000000000000000000000000000000000000000000000081529283018190529450919283019173ffffffffffffffffffffffffffffffffffffffff16906356a4728990602401602060405180830381865afa158015610c0d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c3191906126fb565b8152600480546040517f622f17f600000000000000000000000000000000000000000000000000000000815263ffffffff86169281019290925260209092019173ffffffffffffffffffffffffffffffffffffffff169063622f17f690602401602060405180830381865afa158015610cae573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cd291906126fb565b815250838381518110610ce757610ce761230b565b6020026020010181905250508080610cfe906124ab565b915050610b48565b5060408051808201825263ffffffff7f000000000000000000000000000000000000000000000000000000000000000016815260208082018490529151610d4d9201612714565b60405160208183030381529060405291505090565b6060600080610d71858561160c565b915091506001600060149054906101000a900467ffffffffffffffff1683518484604051602001610da695949392919061278f565b6040516020818303038152906040529250505092915050565b333014610e28576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f5072656372696d653a206f6e6c792073656c660000000000000000000000000060448201526064016105ac565b600080610e3584846116ff565b9150915081816040517f3ef053020000000000000000000000000000000000000000000000000000000081526004016105ac929190611fb1565b600060608315610f62576000610e85868661160c565b50905060005b8151811015610f5f576000805b8651811015610f0157838381518110610eb357610eb361230b565b602002602001015163ffffffff16878281518110610ed357610ed361230b565b602002602001015163ffffffff1603610eef5760019150610f01565b80610ef9816124ab565b915050610e98565b5080610f4c576101926040518060400160405280601e81526020017f6d697373696e6720706565722073696d756c6174696f6e20726573756c74000081525094509450505050611031565b5080610f57816124ab565b915050610e8b565b50505b6000805b8451811015610fd6577f000000000000000000000000000000000000000000000000000000000000000063ffffffff16858281518110610fa857610fa861230b565b602002602001015163ffffffff1603610fc45760019150610fd6565b80610fce816124ab565b915050610f66565b508061101c57505060408051808201909152601f81527f6d697373696e67206c6f63616c2073696d756c6174696f6e20726573756c740060208201526101929150611031565b50506040805160208101909152600080825291505b935093915050565b600060606110606040518060400160405280600063ffffffff168152602001606081525090565b6000845167ffffffffffffffff81111561107c5761107c61200f565b6040519080825280602002602001820160405280156110c257816020015b60408051808201909152600081526060602082015281526020019060019003908161109a5790505b50905060005b855181101561119a578581815181106110e3576110e361230b565b60200260200101518060200190518101906110fe9190612853565b8282815181106111105761111061230b565b60200260200101819052507f000000000000000000000000000000000000000000000000000000000000000063ffffffff168282815181106111545761115461230b565b60200260200101516000015163ffffffff16036111885781818151811061117d5761117d61230b565b602002602001015192505b80611192816124ab565b9150506110c8565b5060005b81518110156112615760006111d0848484815181106111bf576111bf61230b565b602002602001015160000151611919565b50905060006112188484815181106111ea576111ea61230b565b60200260200101517f0000000000000000000000000000000000000000000000000000000000000000611919565b9150508082111561124c576001604051806060016040528060318152602001612cb760319139965096505050505050915091565b50508080611259906124ab565b91505061119e565b50600060405180602001604052806000815250935093505050915091565b6000805460609074010000000000000000000000000000000000000000900467ffffffffffffffff1683111561130957600054610190906112e19074010000000000000000000000000000000000000000900467ffffffffffffffff166119cd565b6040516020016112f19190612962565b60405160208183030381529060405291509150610abf565b821561156e5760008080805b868110156115695760008888838181106113315761133161230b565b905060200281019061134391906129a7565b61134c906129db565b80515190915063ffffffff868116911614158061136e57508051602001518414155b156114ef578051805160208201516040909201519096509094509250600073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001663a0dd43fc6113e760045473ffffffffffffffffffffffffffffffffffffffff1690565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815273ffffffffffffffffffffffffffffffffffffffff909116600482015263ffffffff8916602482015260448101889052606401602060405180830381865afa158015611463573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114879190612a9f565b611492906001612abc565b90508067ffffffffffffffff168467ffffffffffffffff16146114e9576101916114bb846119cd565b6040516020016114cb9190612ae4565b60405160208183030381529060405297509750505050505050610abf565b50611556565b6114f883612b4f565b92508267ffffffffffffffff1681600001516040015167ffffffffffffffff161461155657610191611529836119cd565b6040516020016115399190612b76565b604051602081830303815290604052965096505050505050610abf565b5080611561816124ab565b915050611315565b505050505b505060408051602081019091526000808252909250929050565b600060607fffffffff0000000000000000000000000000000000000000000000000000000083166115b885612bbb565b7fffffffff0000000000000000000000000000000000000000000000000000000016146115e757835160208501fd5b600484019350838060200190518101906116019190612c0b565b915091509250929050565b60608060008390036116f557600160028180548060200260200160405190810160405280929190818152602001828054801561169357602002820191906000526020600020906000905b82829054906101000a900463ffffffff1663ffffffff16815260200190600401906020826003010492830192600103820291508084116116565790505b50505050509150808054806020026020016040519081016040528092919081815260200182805480156116e557602002820191906000526020600020905b8154815260200190600101908083116116d1575b5050505050905091509150610abf565b6116018484611a8b565b6004546040516000916060918391829173ffffffffffffffffffffffffffffffffffffffff9091169034907ff5c6ba5a000000000000000000000000000000000000000000000000000000009061175c908a908a90602401612590565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff000000000000000000000000000000000000000000000000000000009094169390931790925290516117e591906126c0565b60006040518083038185875af1925050503d8060008114611822576040519150601f19603f3d011682016040523d82523d6000602084013e611827565b606091505b509150915081156118e0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604360248201527f4f6d6e69436f756e7465725072654372696d653a2073696d756c6174696f6e4360448201527f616c6c6261636b2073686f756c642062652063616c6c6564207669612072657660648201527f6572740000000000000000000000000000000000000000000000000000000000608482015260a4016105ac565b61190a817f0a78da8f00000000000000000000000000000000000000000000000000000000611588565b60009890975095505050505050565b60008060005b8460200151518110156119c0578363ffffffff16856020015182815181106119495761194961230b565b60200260200101516000015163ffffffff16036119ae57846020015181815181106119765761197661230b565b602002602001015160200151856020015182815181106119985761199861230b565b6020026020010151604001519250925050610abf565b806119b8816124ab565b91505061191f565b5060009485945092505050565b606060006119da83611c97565b600101905060008167ffffffffffffffff8111156119fa576119fa61200f565b6040519080825280601f01601f191660200182016040528015611a24576020820181803683370190505b5090508181016020015b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff017f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a8504945084611a2e57509392505050565b6060806000805b84811015611b11576000600381888885818110611ab157611ab161230b565b9050602002810190611ac391906129a7565b611ad1906020810190611feb565b63ffffffff1663ffffffff1681526020019081526020016000205414611aff5781611afb81612c9f565b9250505b80611b09816124ab565b915050611a92565b508061ffff1667ffffffffffffffff811115611b2f57611b2f61200f565b604051908082528060200260200182016040528015611b58578160200160208202803683370190505b5092508061ffff1667ffffffffffffffff811115611b7857611b7861200f565b604051908082528060200260200182016040528015611ba1578160200160208202803683370190505b50915060005b84811015610abc57600060036000888885818110611bc757611bc761230b565b9050602002810190611bd991906129a7565b611be7906020810190611feb565b63ffffffff16815260208101919091526040016000205490508015611c8457868683818110611c1857611c1861230b565b9050602002810190611c2a91906129a7565b611c38906020810190611feb565b858381518110611c4a57611c4a61230b565b602002602001019063ffffffff16908163ffffffff168152505080848381518110611c7757611c7761230b565b6020026020010181815250505b5080611c8f816124ab565b915050611ba7565b6000807a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008310611ce0577a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000830492506040015b6d04ee2d6d415b85acef81000000008310611d0c576d04ee2d6d415b85acef8100000000830492506020015b662386f26fc100008310611d2a57662386f26fc10000830492506010015b6305f5e1008310611d42576305f5e100830492506008015b6127108310611d5657612710830492506004015b60648310611d68576064830492506002015b600a8310611d74576001015b92915050565b82805482825590600052602060002090600701600890048101928215611e195791602002820160005b83821115611de757835183826101000a81548163ffffffff021916908363ffffffff1602179055509260200192600401602081600301049283019260010302611da3565b8015611e175782816101000a81549063ffffffff0219169055600401602081600301049283019260010302611de7565b505b50611e25929150611e64565b5090565b828054828255906000526020600020908101928215611e19579160200282015b82811115611e19578251825591602001919060010190611e49565b5b80821115611e255760008155600101611e65565b600060208284031215611e8b57600080fd5b5035919050565b60008083601f840112611ea457600080fd5b50813567ffffffffffffffff811115611ebc57600080fd5b6020830191508360208260051b8501011115610abf57600080fd5b60008060008060408587031215611eed57600080fd5b843567ffffffffffffffff80821115611f0557600080fd5b611f1188838901611e92565b90965094506020870135915080821115611f2a57600080fd5b50611f3787828801611e92565b95989497509550505050565b60005b83811015611f5e578181015183820152602001611f46565b50506000910152565b60008151808452611f7f816020860160208601611f43565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b61ffff83168152604060208201526000611fce6040830184611f67565b949350505050565b63ffffffff81168114611fe857600080fd5b50565b600060208284031215611ffd57600080fd5b813561200881611fd6565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040805190810167ffffffffffffffff811182821017156120615761206161200f565b60405290565b6040516060810167ffffffffffffffff811182821017156120615761206161200f565b6040516080810167ffffffffffffffff811182821017156120615761206161200f565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff811182821017156120f4576120f461200f565b604052919050565b600067ffffffffffffffff8211156121165761211661200f565b5060051b60200190565b600082601f83011261213157600080fd5b81356020612146612141836120fc565b6120ad565b82815260059290921b8401810191818101908684111561216557600080fd5b8286015b848110156121805780358352918301918301612169565b509695505050505050565b6000806040838503121561219e57600080fd5b823567ffffffffffffffff808211156121b657600080fd5b818501915085601f8301126121ca57600080fd5b813560206121da612141836120fc565b82815260059290921b840181019181810190898411156121f957600080fd5b948201945b8386101561222057853561221181611fd6565b825294820194908201906121fe565b9650508601359250508082111561223657600080fd5b5061224385828601612120565b9150509250929050565b67ffffffffffffffff81168114611fe857600080fd5b60006020828403121561227557600080fd5b81356120088161224d565b6000806020838503121561229357600080fd5b823567ffffffffffffffff8111156122aa57600080fd5b6122b685828601611e92565b90969095509350505050565b6000602082840312156122d457600080fd5b813573ffffffffffffffffffffffffffffffffffffffff8116811461200857600080fd5b6020815260006120086020830184611f67565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261236f57600080fd5b83018035915067ffffffffffffffff82111561238a57600080fd5b602001915036819003821315610abf57600080fd5b600067ffffffffffffffff8211156123b9576123b961200f565b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b600082601f8301126123f657600080fd5b81356124046121418261239f565b81815284602083860101111561241957600080fd5b816020850160208301376000918101602001919091529392505050565b6000806040838503121561244957600080fd5b823561245481611fd6565b9150602083013567ffffffffffffffff81111561247057600080fd5b612243858286016123e5565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036124dc576124dc61247c565b5060010190565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261251857600080fd5b830160208101925035905067ffffffffffffffff81111561253857600080fd5b803603821315610abf57600080fd5b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b60208082528181018390526000906040808401600586901b850182018785805b898110156126b1577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc089850301855282357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff418c3603018112612610578283fd5b8b0160c0813561261f81611fd6565b63ffffffff16865281890135898701528782013561263c8161224d565b67ffffffffffffffff1686890152606082810135908701526080612662818401846124e3565b83838a0152612674848a018284612547565b935050505060a0612687818401846124e3565b93508783038289015261269b838583612547565b988b0198975050509388019350506001016125b0565b50919998505050505050505050565b600082516126d2818460208701611f43565b9190910192915050565b63ffffffff83168152604060208201526000611fce6040830184611f67565b60006020828403121561270d57600080fd5b5051919050565b60006020808352606080840163ffffffff8087511684870152838701516040808189015283825180865260808a0191508784019550600093505b8084101561278157855180518616835288810151898401528301518383015294870194600193909301929086019061274e565b509998505050505050505050565b7fffff0000000000000000000000000000000000000000000000000000000000008660f01b1681527fffffffffffffffff0000000000000000000000000000000000000000000000008560c01b16600282015283600a8201526000602a82018451602080870160005b8381101561281a57815163ffffffff16855293820193908201906001016127f8565b5050855181870193925060005b8181101561284357845184529382019392820192600101612827565b50919a9950505050505050505050565b6000602080838503121561286657600080fd5b825167ffffffffffffffff8082111561287e57600080fd5b8185019150604080838803121561289457600080fd5b61289c61203e565b83516128a781611fd6565b815283850151838111156128ba57600080fd5b80850194505087601f8501126128cf57600080fd5b835192506128df612141846120fc565b8381526060938402850186019386820191908a8611156128fe57600080fd5b958701955b8587101561294f5780878c03121561291b5760008081fd5b612923612067565b875161292e81611fd6565b81528789015189820152858801518682015283529586019591870191612903565b5095820195909552979650505050505050565b7f7061636b6574732073697a6520657863656564206c696d69746564200000000081526000825161299a81601c850160208701611f43565b91909101601c0192915050565b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff418336030181126126d257600080fd5b600081360360c08112156129ee57600080fd5b6129f661208a565b6060821215612a0457600080fd5b612a0c612067565b91508335612a1981611fd6565b8252602084810135908301526040840135612a338161224d565b60408301529081526060830135602082015260808301359067ffffffffffffffff80831115612a6157600080fd5b612a6d368487016123e5565b604083015260a0850135925080831115612a8657600080fd5b50612a93368386016123e5565b60608201529392505050565b600060208284031215612ab157600080fd5b81516120088161224d565b67ffffffffffffffff818116838216019080821115612add57612add61247c565b5092915050565b7f736b697070656420696e626f756e644e6f6e63652c207061636b657420696e6481527f65783a2000000000000000000000000000000000000000000000000000000000602082015260008251612b42816024850160208701611f43565b9190910160240192915050565b600067ffffffffffffffff808316818103612b6c57612b6c61247c565b6001019392505050565b7f756e736f72746564207061636b6574732c207061636b657420696e6465783a20815260008251612bae816020850160208701611f43565b9190910160200192915050565b6000815160208301517fffffffff0000000000000000000000000000000000000000000000000000000080821693506004831015612c035780818460040360031b1b83161693505b505050919050565b60008060408385031215612c1e57600080fd5b825161ffff81168114612c3057600080fd5b602084015190925067ffffffffffffffff811115612c4d57600080fd5b8301601f81018513612c5e57600080fd5b8051612c6c6121418261239f565b818152866020838501011115612c8157600080fd5b612c92826020830160208601611f43565b8093505050509250929050565b600061ffff808316818103612b6c57612b6c61247c56fe4f6d6e69436f756e7465725072654372696d653a20696e626f756e64436f756e74203e206f7574626f756e64436f756e74a2646970667358221220b0b563348acce1a1f0a98afaf7f4e4e959f1466b530798f17973ffbcca4267cf64736f6c63430008130033",
  "deployedBytecode": "0x6080604052600436106100e85760003560e01c80636ece7d361161008a578063d2968d5711610059578063d2968d57146102b3578063e51ac4b0146102d5578063e780f25414610327578063fd4c212e1461034757600080fd5b80636ece7d36146102405780637a4359d51461026057806392d99a7f1461028057806399877564146102a057600080fd5b80632c79305d116100c65780632c79305d1461018357806330515e561461019f57806354b3ab69146101f15780635bf88a001461021e57600080fd5b806312fb9ea5146100ed57806328318b621461012057806329c246281461014e575b600080fd5b3480156100f957600080fd5b5061010d610108366004611e79565b61035a565b6040519081526020015b60405180910390f35b34801561012c57600080fd5b5061014061013b366004611ed7565b61037b565b604051610117929190611fb1565b34801561015a57600080fd5b5061016e610169366004611e79565b6104f5565b60405163ffffffff9091168152602001610117565b34801561018f57600080fd5b5060405160018152602001610117565b3480156101ab57600080fd5b506000546101d89074010000000000000000000000000000000000000000900467ffffffffffffffff1681565b60405167ffffffffffffffff9091168152602001610117565b3480156101fd57600080fd5b5061010d61020c366004611feb565b60036020526000908152604090205481565b34801561022a57600080fd5b5061023e61023936600461218b565b61052f565b005b34801561024c57600080fd5b5061023e61025b366004612263565b610657565b34801561026c57600080fd5b5061014061027b366004612280565b61072b565b34801561028c57600080fd5b5061023e61029b3660046122c2565b610793565b6101406102ae366004612280565b61085b565b3480156102bf57600080fd5b506102c8610ac6565b60405161011791906122f8565b3480156102e157600080fd5b506000546103029073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610117565b34801561033357600080fd5b506102c8610342366004612280565b610d62565b61023e610355366004612280565b610dbf565b6002818154811061036a57600080fd5b600091825260209091200154905081565b60006060818367ffffffffffffffff8111156103995761039961200f565b6040519080825280602002602001820160405280156103cc57816020015b60608152602001906001900390816103b75790505b50905060008467ffffffffffffffff8111156103ea576103ea61200f565b604051908082528060200260200182016040528015610413578160200160208202803683370190505b50905060005b858110156104b9576000808888848181106104365761043661230b565b9050602002810190610448919061233a565b8101906104559190612436565b915091508184848151811061046c5761046c61230b565b602002602001019063ffffffff16908163ffffffff1681525050808584815181106104995761049961230b565b6020026020010181905250505080806104b1906124ab565b915050610419565b506104c5888883610e6f565b909450925061ffff8416156104db5750506104ec565b6104e482611039565b909450925050505b94509492505050565b6001818154811061050557600080fd5b9060005260206000209060089182820401919006600402915054906101000a900463ffffffff1681565b60005473ffffffffffffffffffffffffffffffffffffffff1633146105b5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f6f6e6c792061646d696e0000000000000000000000000000000000000000000060448201526064015b60405180910390fd5b81516105c8906001906020850190611d7a565b5080516105dc906002906020840190611e29565b5060005b8251811015610652578181815181106105fb576105fb61230b565b6020026020010151600360008584815181106106195761061961230b565b602002602001015163ffffffff1663ffffffff16815260200190815260200160002081905550808061064a906124ab565b9150506105e0565b505050565b60005473ffffffffffffffffffffffffffffffffffffffff1633146106d8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f6f6e6c792061646d696e0000000000000000000000000000000000000000000060448201526064016105ac565b6000805467ffffffffffffffff90921674010000000000000000000000000000000000000000027fffffffff0000000000000000ffffffffffffffffffffffffffffffffffffffff909216919091179055565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f6e6f7420696d706c656d656e746564000000000000000000000000000000000060448201526000906060906064016105ac565b60005473ffffffffffffffffffffffffffffffffffffffff163314610814576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f6f6e6c792061646d696e0000000000000000000000000000000000000000000060448201526064016105ac565b600080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b60006060610869848461127f565b909250905061ffff8216610abf576000803073ffffffffffffffffffffffffffffffffffffffff163463fd4c212e60e01b88886040516024016108ad929190612590565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090941693909317909252905161093691906126c0565b60006040518083038185875af1925050503d8060008114610973576040519150601f19603f3d011682016040523d82523d6000602084013e610978565b606091505b50909250905034156109b25760405133903480156108fc02916000818181858888f193505050501580156109b0573d6000803e3d6000fd5b505b8115610a3f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526024808201527f73696d756c6174652073686f756c64206e657665722072657475726e2073756360448201527f636573730000000000000000000000000000000000000000000000000000000060648201526084016105ac565b610a69817f3ef0530200000000000000000000000000000000000000000000000000000000611588565b909450925061ffff8416610abc577f000000000000000000000000000000000000000000000000000000000000000083604051602001610aaa9291906126dc565b60405160208183030381529060405292505b50505b9250929050565b60015460609060009067ffffffffffffffff811115610ae757610ae761200f565b604051908082528060200260200182016040528015610b4257816020015b610b2f6040518060600160405280600063ffffffff16815260200160008152602001600081525090565b815260200190600190039081610b055790505b50905060005b600154811015610d0657600060018281548110610b6757610b6761230b565b600091825260209182902060088204015460408051606081018252600790931660049081026101000a90920463ffffffff16808452825491517f56a472890000000000000000000000000000000000000000000000000000000081529283018190529450919283019173ffffffffffffffffffffffffffffffffffffffff16906356a4728990602401602060405180830381865afa158015610c0d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c3191906126fb565b8152600480546040517f622f17f600000000000000000000000000000000000000000000000000000000815263ffffffff86169281019290925260209092019173ffffffffffffffffffffffffffffffffffffffff169063622f17f690602401602060405180830381865afa158015610cae573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cd291906126fb565b815250838381518110610ce757610ce761230b565b6020026020010181905250508080610cfe906124ab565b915050610b48565b5060408051808201825263ffffffff7f000000000000000000000000000000000000000000000000000000000000000016815260208082018490529151610d4d9201612714565b60405160208183030381529060405291505090565b6060600080610d71858561160c565b915091506001600060149054906101000a900467ffffffffffffffff1683518484604051602001610da695949392919061278f565b6040516020818303038152906040529250505092915050565b333014610e28576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f5072656372696d653a206f6e6c792073656c660000000000000000000000000060448201526064016105ac565b600080610e3584846116ff565b9150915081816040517f3ef053020000000000000000000000000000000000000000000000000000000081526004016105ac929190611fb1565b600060608315610f62576000610e85868661160c565b50905060005b8151811015610f5f576000805b8651811015610f0157838381518110610eb357610eb361230b565b602002602001015163ffffffff16878281518110610ed357610ed361230b565b602002602001015163ffffffff1603610eef5760019150610f01565b80610ef9816124ab565b915050610e98565b5080610f4c576101926040518060400160405280601e81526020017f6d697373696e6720706565722073696d756c6174696f6e20726573756c74000081525094509450505050611031565b5080610f57816124ab565b915050610e8b565b50505b6000805b8451811015610fd6577f000000000000000000000000000000000000000000000000000000000000000063ffffffff16858281518110610fa857610fa861230b565b602002602001015163ffffffff1603610fc45760019150610fd6565b80610fce816124ab565b915050610f66565b508061101c57505060408051808201909152601f81527f6d697373696e67206c6f63616c2073696d756c6174696f6e20726573756c740060208201526101929150611031565b50506040805160208101909152600080825291505b935093915050565b600060606110606040518060400160405280600063ffffffff168152602001606081525090565b6000845167ffffffffffffffff81111561107c5761107c61200f565b6040519080825280602002602001820160405280156110c257816020015b60408051808201909152600081526060602082015281526020019060019003908161109a5790505b50905060005b855181101561119a578581815181106110e3576110e361230b565b60200260200101518060200190518101906110fe9190612853565b8282815181106111105761111061230b565b60200260200101819052507f000000000000000000000000000000000000000000000000000000000000000063ffffffff168282815181106111545761115461230b565b60200260200101516000015163ffffffff16036111885781818151811061117d5761117d61230b565b602002602001015192505b80611192816124ab565b9150506110c8565b5060005b81518110156112615760006111d0848484815181106111bf576111bf61230b565b602002602001015160000151611919565b50905060006112188484815181106111ea576111ea61230b565b60200260200101517f0000000000000000000000000000000000000000000000000000000000000000611919565b9150508082111561124c576001604051806060016040528060318152602001612cb760319139965096505050505050915091565b50508080611259906124ab565b91505061119e565b50600060405180602001604052806000815250935093505050915091565b6000805460609074010000000000000000000000000000000000000000900467ffffffffffffffff1683111561130957600054610190906112e19074010000000000000000000000000000000000000000900467ffffffffffffffff166119cd565b6040516020016112f19190612962565b60405160208183030381529060405291509150610abf565b821561156e5760008080805b868110156115695760008888838181106113315761133161230b565b905060200281019061134391906129a7565b61134c906129db565b80515190915063ffffffff868116911614158061136e57508051602001518414155b156114ef578051805160208201516040909201519096509094509250600073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001663a0dd43fc6113e760045473ffffffffffffffffffffffffffffffffffffffff1690565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815273ffffffffffffffffffffffffffffffffffffffff909116600482015263ffffffff8916602482015260448101889052606401602060405180830381865afa158015611463573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114879190612a9f565b611492906001612abc565b90508067ffffffffffffffff168467ffffffffffffffff16146114e9576101916114bb846119cd565b6040516020016114cb9190612ae4565b60405160208183030381529060405297509750505050505050610abf565b50611556565b6114f883612b4f565b92508267ffffffffffffffff1681600001516040015167ffffffffffffffff161461155657610191611529836119cd565b6040516020016115399190612b76565b604051602081830303815290604052965096505050505050610abf565b5080611561816124ab565b915050611315565b505050505b505060408051602081019091526000808252909250929050565b600060607fffffffff0000000000000000000000000000000000000000000000000000000083166115b885612bbb565b7fffffffff0000000000000000000000000000000000000000000000000000000016146115e757835160208501fd5b600484019350838060200190518101906116019190612c0b565b915091509250929050565b60608060008390036116f557600160028180548060200260200160405190810160405280929190818152602001828054801561169357602002820191906000526020600020906000905b82829054906101000a900463ffffffff1663ffffffff16815260200190600401906020826003010492830192600103820291508084116116565790505b50505050509150808054806020026020016040519081016040528092919081815260200182805480156116e557602002820191906000526020600020905b8154815260200190600101908083116116d1575b5050505050905091509150610abf565b6116018484611a8b565b6004546040516000916060918391829173ffffffffffffffffffffffffffffffffffffffff9091169034907ff5c6ba5a000000000000000000000000000000000000000000000000000000009061175c908a908a90602401612590565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff000000000000000000000000000000000000000000000000000000009094169390931790925290516117e591906126c0565b60006040518083038185875af1925050503d8060008114611822576040519150601f19603f3d011682016040523d82523d6000602084013e611827565b606091505b509150915081156118e0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604360248201527f4f6d6e69436f756e7465725072654372696d653a2073696d756c6174696f6e4360448201527f616c6c6261636b2073686f756c642062652063616c6c6564207669612072657660648201527f6572740000000000000000000000000000000000000000000000000000000000608482015260a4016105ac565b61190a817f0a78da8f00000000000000000000000000000000000000000000000000000000611588565b60009890975095505050505050565b60008060005b8460200151518110156119c0578363ffffffff16856020015182815181106119495761194961230b565b60200260200101516000015163ffffffff16036119ae57846020015181815181106119765761197661230b565b602002602001015160200151856020015182815181106119985761199861230b565b6020026020010151604001519250925050610abf565b806119b8816124ab565b91505061191f565b5060009485945092505050565b606060006119da83611c97565b600101905060008167ffffffffffffffff8111156119fa576119fa61200f565b6040519080825280601f01601f191660200182016040528015611a24576020820181803683370190505b5090508181016020015b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff017f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a8504945084611a2e57509392505050565b6060806000805b84811015611b11576000600381888885818110611ab157611ab161230b565b9050602002810190611ac391906129a7565b611ad1906020810190611feb565b63ffffffff1663ffffffff1681526020019081526020016000205414611aff5781611afb81612c9f565b9250505b80611b09816124ab565b915050611a92565b508061ffff1667ffffffffffffffff811115611b2f57611b2f61200f565b604051908082528060200260200182016040528015611b58578160200160208202803683370190505b5092508061ffff1667ffffffffffffffff811115611b7857611b7861200f565b604051908082528060200260200182016040528015611ba1578160200160208202803683370190505b50915060005b84811015610abc57600060036000888885818110611bc757611bc761230b565b9050602002810190611bd991906129a7565b611be7906020810190611feb565b63ffffffff16815260208101919091526040016000205490508015611c8457868683818110611c1857611c1861230b565b9050602002810190611c2a91906129a7565b611c38906020810190611feb565b858381518110611c4a57611c4a61230b565b602002602001019063ffffffff16908163ffffffff168152505080848381518110611c7757611c7761230b565b6020026020010181815250505b5080611c8f816124ab565b915050611ba7565b6000807a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008310611ce0577a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000830492506040015b6d04ee2d6d415b85acef81000000008310611d0c576d04ee2d6d415b85acef8100000000830492506020015b662386f26fc100008310611d2a57662386f26fc10000830492506010015b6305f5e1008310611d42576305f5e100830492506008015b6127108310611d5657612710830492506004015b60648310611d68576064830492506002015b600a8310611d74576001015b92915050565b82805482825590600052602060002090600701600890048101928215611e195791602002820160005b83821115611de757835183826101000a81548163ffffffff021916908363ffffffff1602179055509260200192600401602081600301049283019260010302611da3565b8015611e175782816101000a81549063ffffffff0219169055600401602081600301049283019260010302611de7565b505b50611e25929150611e64565b5090565b828054828255906000526020600020908101928215611e19579160200282015b82811115611e19578251825591602001919060010190611e49565b5b80821115611e255760008155600101611e65565b600060208284031215611e8b57600080fd5b5035919050565b60008083601f840112611ea457600080fd5b50813567ffffffffffffffff811115611ebc57600080fd5b6020830191508360208260051b8501011115610abf57600080fd5b60008060008060408587031215611eed57600080fd5b843567ffffffffffffffff80821115611f0557600080fd5b611f1188838901611e92565b90965094506020870135915080821115611f2a57600080fd5b50611f3787828801611e92565b95989497509550505050565b60005b83811015611f5e578181015183820152602001611f46565b50506000910152565b60008151808452611f7f816020860160208601611f43565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b61ffff83168152604060208201526000611fce6040830184611f67565b949350505050565b63ffffffff81168114611fe857600080fd5b50565b600060208284031215611ffd57600080fd5b813561200881611fd6565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040805190810167ffffffffffffffff811182821017156120615761206161200f565b60405290565b6040516060810167ffffffffffffffff811182821017156120615761206161200f565b6040516080810167ffffffffffffffff811182821017156120615761206161200f565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff811182821017156120f4576120f461200f565b604052919050565b600067ffffffffffffffff8211156121165761211661200f565b5060051b60200190565b600082601f83011261213157600080fd5b81356020612146612141836120fc565b6120ad565b82815260059290921b8401810191818101908684111561216557600080fd5b8286015b848110156121805780358352918301918301612169565b509695505050505050565b6000806040838503121561219e57600080fd5b823567ffffffffffffffff808211156121b657600080fd5b818501915085601f8301126121ca57600080fd5b813560206121da612141836120fc565b82815260059290921b840181019181810190898411156121f957600080fd5b948201945b8386101561222057853561221181611fd6565b825294820194908201906121fe565b9650508601359250508082111561223657600080fd5b5061224385828601612120565b9150509250929050565b67ffffffffffffffff81168114611fe857600080fd5b60006020828403121561227557600080fd5b81356120088161224d565b6000806020838503121561229357600080fd5b823567ffffffffffffffff8111156122aa57600080fd5b6122b685828601611e92565b90969095509350505050565b6000602082840312156122d457600080fd5b813573ffffffffffffffffffffffffffffffffffffffff8116811461200857600080fd5b6020815260006120086020830184611f67565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261236f57600080fd5b83018035915067ffffffffffffffff82111561238a57600080fd5b602001915036819003821315610abf57600080fd5b600067ffffffffffffffff8211156123b9576123b961200f565b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b600082601f8301126123f657600080fd5b81356124046121418261239f565b81815284602083860101111561241957600080fd5b816020850160208301376000918101602001919091529392505050565b6000806040838503121561244957600080fd5b823561245481611fd6565b9150602083013567ffffffffffffffff81111561247057600080fd5b612243858286016123e5565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036124dc576124dc61247c565b5060010190565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261251857600080fd5b830160208101925035905067ffffffffffffffff81111561253857600080fd5b803603821315610abf57600080fd5b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b60208082528181018390526000906040808401600586901b850182018785805b898110156126b1577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc089850301855282357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff418c3603018112612610578283fd5b8b0160c0813561261f81611fd6565b63ffffffff16865281890135898701528782013561263c8161224d565b67ffffffffffffffff1686890152606082810135908701526080612662818401846124e3565b83838a0152612674848a018284612547565b935050505060a0612687818401846124e3565b93508783038289015261269b838583612547565b988b0198975050509388019350506001016125b0565b50919998505050505050505050565b600082516126d2818460208701611f43565b9190910192915050565b63ffffffff83168152604060208201526000611fce6040830184611f67565b60006020828403121561270d57600080fd5b5051919050565b60006020808352606080840163ffffffff8087511684870152838701516040808189015283825180865260808a0191508784019550600093505b8084101561278157855180518616835288810151898401528301518383015294870194600193909301929086019061274e565b509998505050505050505050565b7fffff0000000000000000000000000000000000000000000000000000000000008660f01b1681527fffffffffffffffff0000000000000000000000000000000000000000000000008560c01b16600282015283600a8201526000602a82018451602080870160005b8381101561281a57815163ffffffff16855293820193908201906001016127f8565b5050855181870193925060005b8181101561284357845184529382019392820192600101612827565b50919a9950505050505050505050565b6000602080838503121561286657600080fd5b825167ffffffffffffffff8082111561287e57600080fd5b8185019150604080838803121561289457600080fd5b61289c61203e565b83516128a781611fd6565b815283850151838111156128ba57600080fd5b80850194505087601f8501126128cf57600080fd5b835192506128df612141846120fc565b8381526060938402850186019386820191908a8611156128fe57600080fd5b958701955b8587101561294f5780878c03121561291b5760008081fd5b612923612067565b875161292e81611fd6565b81528789015189820152858801518682015283529586019591870191612903565b5095820195909552979650505050505050565b7f7061636b6574732073697a6520657863656564206c696d69746564200000000081526000825161299a81601c850160208701611f43565b91909101601c0192915050565b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff418336030181126126d257600080fd5b600081360360c08112156129ee57600080fd5b6129f661208a565b6060821215612a0457600080fd5b612a0c612067565b91508335612a1981611fd6565b8252602084810135908301526040840135612a338161224d565b60408301529081526060830135602082015260808301359067ffffffffffffffff80831115612a6157600080fd5b612a6d368487016123e5565b604083015260a0850135925080831115612a8657600080fd5b50612a93368386016123e5565b60608201529392505050565b600060208284031215612ab157600080fd5b81516120088161224d565b67ffffffffffffffff818116838216019080821115612add57612add61247c565b5092915050565b7f736b697070656420696e626f756e644e6f6e63652c207061636b657420696e6481527f65783a2000000000000000000000000000000000000000000000000000000000602082015260008251612b42816024850160208701611f43565b9190910160240192915050565b600067ffffffffffffffff808316818103612b6c57612b6c61247c565b6001019392505050565b7f756e736f72746564207061636b6574732c207061636b657420696e6465783a20815260008251612bae816020850160208701611f43565b9190910160200192915050565b6000815160208301517fffffffff0000000000000000000000000000000000000000000000000000000080821693506004831015612c035780818460040360031b1b83161693505b505050919050565b60008060408385031215612c1e57600080fd5b825161ffff81168114612c3057600080fd5b602084015190925067ffffffffffffffff811115612c4d57600080fd5b8301601f81018513612c5e57600080fd5b8051612c6c6121418261239f565b818152866020838501011115612c8157600080fd5b612c92826020830160208601611f43565b8093505050509250929050565b600061ffff808316818103612b6c57612b6c61247c56fe4f6d6e69436f756e7465725072654372696d653a20696e626f756e64436f756e74203e206f7574626f756e64436f756e74a2646970667358221220b0b563348acce1a1f0a98afaf7f4e4e959f1466b530798f17973ffbcca4267cf64736f6c63430008130033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 6822,
        "contract": "contracts/examples/OmniCounterPreCrime.sol:OmniCounterPreCrime",
        "label": "pAdmin",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 6824,
        "contract": "contracts/examples/OmniCounterPreCrime.sol:OmniCounterPreCrime",
        "label": "pMaxBatchSize",
        "offset": 20,
        "slot": "0",
        "type": "t_uint64"
      },
      {
        "astId": 6827,
        "contract": "contracts/examples/OmniCounterPreCrime.sol:OmniCounterPreCrime",
        "label": "precrimeEids",
        "offset": 0,
        "slot": "1",
        "type": "t_array(t_uint32)dyn_storage"
      },
      {
        "astId": 6830,
        "contract": "contracts/examples/OmniCounterPreCrime.sol:OmniCounterPreCrime",
        "label": "precrimePeers",
        "offset": 0,
        "slot": "2",
        "type": "t_array(t_bytes32)dyn_storage"
      },
      {
        "astId": 6834,
        "contract": "contracts/examples/OmniCounterPreCrime.sol:OmniCounterPreCrime",
        "label": "precrimeEidToPeer",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_uint32,t_bytes32)"
      },
      {
        "astId": 8267,
        "contract": "contracts/examples/OmniCounterPreCrime.sol:OmniCounterPreCrime",
        "label": "counter",
        "offset": 0,
        "slot": "4",
        "type": "t_contract(OmniCounter)8257"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_bytes32)dyn_storage": {
        "base": "t_bytes32",
        "encoding": "dynamic_array",
        "label": "bytes32[]",
        "numberOfBytes": "32"
      },
      "t_array(t_uint32)dyn_storage": {
        "base": "t_uint32",
        "encoding": "dynamic_array",
        "label": "uint32[]",
        "numberOfBytes": "32"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(OmniCounter)8257": {
        "encoding": "inplace",
        "label": "contract OmniCounter",
        "numberOfBytes": "20"
      },
      "t_mapping(t_uint32,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_uint32",
        "label": "mapping(uint32 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      }
    }
  }
}