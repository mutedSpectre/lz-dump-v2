{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/Endpoint.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\nimport \"./interfaces/ILayerZeroMessagingLibrary.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Endpoint is Ownable, ILayerZeroEndpoint {\n    uint16 public immutable chainId;\n\n    // installed libraries and reserved versions\n    uint16 public constant BLOCK_VERSION = 65535;\n    uint16 public constant DEFAULT_VERSION = 0;\n    uint16 public latestVersion;\n    mapping(uint16 => ILayerZeroMessagingLibrary) public libraryLookup; // version -> ILayerZeroEndpointLibrary\n\n    // default send/receive libraries\n    uint16 public defaultSendVersion;\n    uint16 public defaultReceiveVersion;\n    ILayerZeroMessagingLibrary public defaultSendLibrary;\n    address public defaultReceiveLibraryAddress;\n\n    struct LibraryConfig {\n        uint16 sendVersion;\n        uint16 receiveVersion;\n        address receiveLibraryAddress;\n        ILayerZeroMessagingLibrary sendLibrary;\n    }\n\n    struct StoredPayload {\n        uint64 payloadLength;\n        address dstAddress;\n        bytes32 payloadHash;\n    }\n\n    // user app config = [uaAddress]\n    mapping(address => LibraryConfig) public uaConfigLookup;\n    // inboundNonce = [srcChainId][srcAddress].\n    mapping(uint16 => mapping(bytes => uint64)) public inboundNonce;\n    // outboundNonce = [dstChainId][srcAddress].\n    mapping(uint16 => mapping(address => uint64)) public outboundNonce;\n    // storedPayload = [srcChainId][srcAddress]\n    mapping(uint16 => mapping(bytes => StoredPayload)) public storedPayload;\n\n    // library versioning events\n    event NewLibraryVersionAdded(uint16 version);\n    event DefaultSendVersionSet(uint16 version);\n    event DefaultReceiveVersionSet(uint16 version);\n    event UaSendVersionSet(address ua, uint16 version);\n    event UaReceiveVersionSet(address ua, uint16 version);\n    event UaForceResumeReceive(uint16 chainId, bytes srcAddress);\n    // payload events\n    event PayloadCleared(uint16 srcChainId, bytes srcAddress, uint64 nonce, address dstAddress);\n    event PayloadStored(uint16 srcChainId, bytes srcAddress, address dstAddress, uint64 nonce, bytes payload, bytes reason);\n\n    constructor(uint16 _chainId) {\n        chainId = _chainId;\n    }\n\n    //---------------------------------------------------------------------------\n    // send and receive nonreentrant lock\n    uint8 internal constant _NOT_ENTERED = 1;\n    uint8 internal constant _ENTERED = 2;\n    uint8 internal _send_entered_state = 1;\n    uint8 internal _receive_entered_state = 1;\n\n    modifier sendNonReentrant() {\n        require(_send_entered_state == _NOT_ENTERED, \"LayerZero: no send reentrancy\");\n        _send_entered_state = _ENTERED;\n        _;\n        _send_entered_state = _NOT_ENTERED;\n    }\n    modifier receiveNonReentrant() {\n        require(_receive_entered_state == _NOT_ENTERED, \"LayerZero: no receive reentrancy\");\n        _receive_entered_state = _ENTERED;\n        _;\n        _receive_entered_state = _NOT_ENTERED;\n    }\n\n    // BLOCK_VERSION is also a valid version\n    modifier validVersion(uint16 _version) {\n        require(_version <= latestVersion || _version == BLOCK_VERSION, \"LayerZero: invalid messaging library version\");\n        _;\n    }\n\n    //---------------------------------------------------------------------------\n    // User Application Calls - Endpoint Interface\n\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable override sendNonReentrant {\n        LibraryConfig storage uaConfig = uaConfigLookup[msg.sender];\n        uint64 nonce = ++outboundNonce[_dstChainId][msg.sender];\n        _getSendLibrary(uaConfig).send{value: msg.value}(msg.sender, nonce, _dstChainId, _destination, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    //---------------------------------------------------------------------------\n    // authenticated Library (msg.sender) Calls to pass through Endpoint to UA (dstAddress)\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external override receiveNonReentrant {\n        // assert and increment the nonce. no message shuffling\n        require(_nonce == ++inboundNonce[_srcChainId][_srcAddress], \"LayerZero: wrong nonce\");\n\n        LibraryConfig storage uaConfig = uaConfigLookup[_dstAddress];\n\n        // authentication to prevent cross-version message validation\n        // protects against a malicious library from passing arbitrary data\n        if (uaConfig.receiveVersion == DEFAULT_VERSION) {\n            require(defaultReceiveLibraryAddress == msg.sender, \"LayerZero: invalid default library\");\n        } else {\n            require(uaConfig.receiveLibraryAddress == msg.sender, \"LayerZero: invalid library\");\n        }\n\n        // block if any message blocking\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        require(sp.payloadHash == bytes32(0), \"LayerZero: in message blocking\");\n\n        try ILayerZeroReceiver(_dstAddress).lzReceive{gas: _gasLimit}(_srcChainId, _srcAddress, _nonce, _payload) {\n            // success, do nothing, end of the message delivery\n        } catch (bytes memory reason) {\n            // revert nonce if any uncaught errors/exceptions if the ua chooses the blocking mode\n            storedPayload[_srcChainId][_srcAddress] = StoredPayload(uint64(_payload.length), _dstAddress, keccak256(_payload));\n            emit PayloadStored(_srcChainId, _srcAddress, _dstAddress, _nonce, _payload, reason);\n        }\n    }\n\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external override receiveNonReentrant {\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        require(sp.payloadHash != bytes32(0), \"LayerZero: no stored payload\");\n        require(_payload.length == sp.payloadLength && keccak256(_payload) == sp.payloadHash, \"LayerZero: invalid payload\");\n\n        address dstAddress = sp.dstAddress;\n        // empty the storedPayload\n        sp.payloadLength = 0;\n        sp.dstAddress = address(0);\n        sp.payloadHash = bytes32(0);\n\n        uint64 nonce = inboundNonce[_srcChainId][_srcAddress];\n\n        ILayerZeroReceiver(dstAddress).lzReceive(_srcChainId, _srcAddress, nonce, _payload);\n        emit PayloadCleared(_srcChainId, _srcAddress, nonce, dstAddress);\n    }\n\n    //---------------------------------------------------------------------------\n    // Owner Calls, only new library version upgrade (3 steps)\n\n    // note libraryLookup[0] = 0x0, no library implementation\n    // LIBRARY UPGRADE step 1: set _newLayerZeroLibraryAddress be the new version\n    function newVersion(address _newLayerZeroLibraryAddress) external onlyOwner {\n        require(_newLayerZeroLibraryAddress != address(0x0), \"LayerZero: new version cannot be zero address\");\n        require(latestVersion < 65535, \"LayerZero: can not add new messaging library\");\n        latestVersion++;\n        libraryLookup[latestVersion] = ILayerZeroMessagingLibrary(_newLayerZeroLibraryAddress);\n        emit NewLibraryVersionAdded(latestVersion);\n    }\n\n    // LIBRARY UPGRADE step 2: stop sending messages from the old version\n    function setDefaultSendVersion(uint16 _newDefaultSendVersion) external onlyOwner validVersion(_newDefaultSendVersion) {\n        require(_newDefaultSendVersion != DEFAULT_VERSION, \"LayerZero: default send version must > 0\");\n        defaultSendVersion = _newDefaultSendVersion;\n        defaultSendLibrary = libraryLookup[defaultSendVersion];\n        emit DefaultSendVersionSet(_newDefaultSendVersion);\n    }\n\n    // LIBRARY UPGRADE step 3: stop receiving messages from the old version\n    function setDefaultReceiveVersion(uint16 _newDefaultReceiveVersion) external onlyOwner validVersion(_newDefaultReceiveVersion) {\n        require(_newDefaultReceiveVersion != DEFAULT_VERSION, \"LayerZero: default receive version must > 0\");\n        defaultReceiveVersion = _newDefaultReceiveVersion;\n        defaultReceiveLibraryAddress = address(libraryLookup[defaultReceiveVersion]);\n        emit DefaultReceiveVersionSet(_newDefaultReceiveVersion);\n    }\n\n    //---------------------------------------------------------------------------\n    // User Application Calls - UA set/get Interface\n\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override validVersion(_version) {\n        if (_version == DEFAULT_VERSION) {\n            require(defaultSendVersion == defaultReceiveVersion, \"LayerZero: can not set Config during DEFAULT migration\");\n            _version = defaultSendVersion;\n        }\n        require(_version != BLOCK_VERSION, \"LayerZero: can not set config for BLOCK_VERSION\");\n        libraryLookup[_version].setConfig(_chainId, msg.sender, _configType, _config);\n    }\n\n    // Migration step 1: set the send version\n    // Define what library the UA points too\n    function setSendVersion(uint16 _newVersion) external override validVersion(_newVersion) {\n        // write into config\n        LibraryConfig storage uaConfig = uaConfigLookup[msg.sender];\n        uaConfig.sendVersion = _newVersion;\n        // the libraryLookup[BLOCK_VERSION || DEFAULT_VERSION] = 0x0\n        uaConfig.sendLibrary = libraryLookup[_newVersion];\n        emit UaSendVersionSet(msg.sender, _newVersion);\n    }\n\n    // Migration step 2: set the receive version\n    // after all messages sent from the old version are received\n    // the UA can now safely switch to the new receive version\n    // it is the UA's responsibility make sure all messages from the old version are processed\n    function setReceiveVersion(uint16 _newVersion) external override validVersion(_newVersion) {\n        // write into config\n        LibraryConfig storage uaConfig = uaConfigLookup[msg.sender];\n        uaConfig.receiveVersion = _newVersion;\n        // the libraryLookup[BLOCK_VERSION || DEFAULT_VERSION] = 0x0\n        uaConfig.receiveLibraryAddress = address(libraryLookup[_newVersion]);\n        emit UaReceiveVersionSet(msg.sender, _newVersion);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override {\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        // revert if no messages are cached. safeguard malicious UA behaviour\n        require(sp.payloadHash != bytes32(0), \"LayerZero: no stored payload\");\n        require(sp.dstAddress == msg.sender, \"LayerZero: invalid caller\");\n\n        // empty the storedPayload\n        sp.payloadLength = 0;\n        sp.dstAddress = address(0);\n        sp.payloadHash = bytes32(0);\n\n        // emit the event with the new nonce\n        emit UaForceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    //---------------------------------------------------------------------------\n    // view helper function\n\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParams) external view override returns (uint nativeFee, uint zroFee) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        ILayerZeroMessagingLibrary lib = uaConfig.sendVersion == DEFAULT_VERSION ? defaultSendLibrary : uaConfig.sendLibrary;\n        return lib.estimateFees(_dstChainId, _userApplication, _payload, _payInZRO, _adapterParams);\n    }\n\n    function _getSendLibrary(LibraryConfig storage uaConfig) internal view returns (ILayerZeroMessagingLibrary) {\n        if (uaConfig.sendVersion == DEFAULT_VERSION) {\n            // check if the in send-blocking upgrade\n            require(defaultSendVersion != BLOCK_VERSION, \"LayerZero: default in BLOCK_VERSION\");\n            return defaultSendLibrary;\n        } else {\n            // check if the in send-blocking upgrade\n            require(uaConfig.sendVersion != BLOCK_VERSION, \"LayerZero: in BLOCK_VERSION\");\n            return uaConfig.sendLibrary;\n        }\n    }\n\n    function getSendLibraryAddress(address _userApplication) external view override returns (address sendLibraryAddress) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        uint16 sendVersion = uaConfig.sendVersion;\n        require(sendVersion != BLOCK_VERSION, \"LayerZero: send version is BLOCK_VERSION\");\n        if (sendVersion == DEFAULT_VERSION) {\n            require(defaultSendVersion != BLOCK_VERSION, \"LayerZero: send version (default) is BLOCK_VERSION\");\n            sendLibraryAddress = address(defaultSendLibrary);\n        } else {\n            sendLibraryAddress = address(uaConfig.sendLibrary);\n        }\n    }\n\n    function getReceiveLibraryAddress(address _userApplication) external view override returns (address receiveLibraryAddress) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        uint16 receiveVersion = uaConfig.receiveVersion;\n        require(receiveVersion != BLOCK_VERSION, \"LayerZero: receive version is BLOCK_VERSION\");\n        if (receiveVersion == DEFAULT_VERSION) {\n            require(defaultReceiveVersion != BLOCK_VERSION, \"LayerZero: receive version (default) is BLOCK_VERSION\");\n            receiveLibraryAddress = defaultReceiveLibraryAddress;\n        } else {\n            receiveLibraryAddress = uaConfig.receiveLibraryAddress;\n        }\n    }\n\n    function isSendingPayload() external view override returns (bool) {\n        return _send_entered_state == _ENTERED;\n    }\n\n    function isReceivingPayload() external view override returns (bool) {\n        return _receive_entered_state == _ENTERED;\n    }\n\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view override returns (uint64) {\n        return inboundNonce[_srcChainId][_srcAddress];\n    }\n\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view override returns (uint64) {\n        return outboundNonce[_dstChainId][_srcAddress];\n    }\n\n    function getChainId() external view override returns (uint16) {\n        return chainId;\n    }\n\n    function getSendVersion(address _userApplication) external view override returns (uint16) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        return uaConfig.sendVersion == DEFAULT_VERSION ? defaultSendVersion : uaConfig.sendVersion;\n    }\n\n    function getReceiveVersion(address _userApplication) external view override returns (uint16) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        return uaConfig.receiveVersion == DEFAULT_VERSION ? defaultReceiveVersion : uaConfig.receiveVersion;\n    }\n\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view override validVersion(_version) returns (bytes memory) {\n        if (_version == DEFAULT_VERSION) {\n            require(defaultSendVersion == defaultReceiveVersion, \"LayerZero: no DEFAULT config while migration\");\n            _version = defaultSendVersion;\n        }\n        require(_version != BLOCK_VERSION, \"LayerZero: can not get config for BLOCK_VERSION\");\n        return libraryLookup[_version].getConfig(_chainId, _userApplication, _configType);\n    }\n\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view override returns (bool) {\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        return sp.payloadHash != bytes32(0);\n    }\n}\n"
    },
    "contracts/EndpointLite.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\nimport \"./interfaces/ILayerZeroMessagingLibrary.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract EndpointLite is Ownable, ILayerZeroEndpoint {\n    uint16 public immutable chainId;\n\n    // installed libraries and reserved versions\n    uint16 public constant BLOCK_VERSION = 65535;\n    uint16 public constant DEFAULT_VERSION = 0;\n    uint16 public latestVersion;\n    mapping(uint16 => ILayerZeroMessagingLibrary) public libraryLookup; // version -> ILayerZeroEndpointLibrary\n\n    // default send/receive libraries\n    uint16 public defaultSendVersion;\n    uint16 public defaultReceiveVersion;\n    ILayerZeroMessagingLibrary public defaultSendLibrary;\n    address public defaultReceiveLibraryAddress;\n\n    struct LibraryConfig {\n        uint16 sendVersion;\n        uint16 receiveVersion;\n        address receiveLibraryAddress;\n        ILayerZeroMessagingLibrary sendLibrary;\n    }\n\n    struct StoredPayload {\n        uint64 payloadLength;\n        address dstAddress;\n        bytes32 payloadHash;\n    }\n\n    // user app config = [uaAddress]\n    mapping(address => LibraryConfig) public uaConfigLookup;\n    // inboundNonce = [srcChainId][srcAddress].\n    mapping(uint16 => mapping(bytes => uint64)) public inboundNonce;\n    // storedPayload = [srcChainId][srcAddress]\n    mapping(uint16 => mapping(bytes => StoredPayload)) public storedPayload;\n\n    // library versioning events\n    event NewLibraryVersionAdded(uint16 version);\n    event DefaultSendVersionSet(uint16 version);\n    event DefaultReceiveVersionSet(uint16 version);\n    event UaSendVersionSet(address ua, uint16 version);\n    event UaReceiveVersionSet(address ua, uint16 version);\n    event UaForceResumeReceive(uint16 chainId, bytes srcAddress);\n    // payload events\n    event PayloadCleared(uint16 srcChainId, bytes srcAddress, uint64 nonce, address dstAddress);\n    event PayloadStored(uint16 srcChainId, bytes srcAddress, address dstAddress, uint64 nonce, bytes payload, bytes reason);\n\n    constructor(uint16 _chainId) {\n        chainId = _chainId;\n    }\n\n    //---------------------------------------------------------------------------\n    // send and receive nonreentrant lock\n    uint8 internal constant _NOT_ENTERED = 1;\n    uint8 internal constant _ENTERED = 2;\n    uint8 internal _send_entered_state = 1;\n    uint8 internal _receive_entered_state = 1;\n\n    modifier sendNonReentrant() {\n        require(_send_entered_state == _NOT_ENTERED, \"LayerZero: no send reentrancy\");\n        _send_entered_state = _ENTERED;\n        _;\n        _send_entered_state = _NOT_ENTERED;\n    }\n    modifier receiveNonReentrant() {\n        require(_receive_entered_state == _NOT_ENTERED, \"LayerZero: no receive reentrancy\");\n        _receive_entered_state = _ENTERED;\n        _;\n        _receive_entered_state = _NOT_ENTERED;\n    }\n\n    // BLOCK_VERSION is also a valid version\n    modifier validVersion(uint16 _version) {\n        require(_version <= latestVersion || _version == BLOCK_VERSION, \"LayerZero: invalid messaging library version\");\n        _;\n    }\n\n    //---------------------------------------------------------------------------\n    // User Application Calls - Endpoint Interface\n\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable override sendNonReentrant {\n        LibraryConfig storage uaConfig = uaConfigLookup[msg.sender];\n        _getSendLibrary(uaConfig).send{value: msg.value}(msg.sender, 0, _dstChainId, _destination, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    //---------------------------------------------------------------------------\n    // authenticated Library (msg.sender) Calls to pass through Endpoint to UA (dstAddress)\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external override receiveNonReentrant {\n        // assert and increment the nonce. no message shuffling\n        require(_nonce == ++inboundNonce[_srcChainId][_srcAddress], \"LayerZero: wrong nonce\");\n\n        LibraryConfig storage uaConfig = uaConfigLookup[_dstAddress];\n\n        // authentication to prevent cross-version message validation\n        // protects against a malicious library from passing arbitrary data\n        if (uaConfig.receiveVersion == DEFAULT_VERSION) {\n            require(defaultReceiveLibraryAddress == msg.sender, \"LayerZero: invalid default library\");\n        } else {\n            require(uaConfig.receiveLibraryAddress == msg.sender, \"LayerZero: invalid library\");\n        }\n\n        // block if any message blocking\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        require(sp.payloadHash == bytes32(0), \"LayerZero: in message blocking\");\n\n        try ILayerZeroReceiver(_dstAddress).lzReceive{gas: _gasLimit}(_srcChainId, _srcAddress, _nonce, _payload) {\n            // success, do nothing, end of the message delivery\n        } catch (bytes memory reason) {\n            // revert nonce if any uncaught errors/exceptions if the ua chooses the blocking mode\n            storedPayload[_srcChainId][_srcAddress] = StoredPayload(uint64(_payload.length), _dstAddress, keccak256(_payload));\n            emit PayloadStored(_srcChainId, _srcAddress, _dstAddress, _nonce, _payload, reason);\n        }\n    }\n\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external override receiveNonReentrant {\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        require(sp.payloadHash != bytes32(0), \"LayerZero: no stored payload\");\n        require(_payload.length == sp.payloadLength && keccak256(_payload) == sp.payloadHash, \"LayerZero: invalid payload\");\n\n        address dstAddress = sp.dstAddress;\n        // empty the storedPayload\n        sp.payloadLength = 0;\n        sp.dstAddress = address(0);\n        sp.payloadHash = bytes32(0);\n\n        uint64 nonce = inboundNonce[_srcChainId][_srcAddress];\n\n        ILayerZeroReceiver(dstAddress).lzReceive(_srcChainId, _srcAddress, nonce, _payload);\n        emit PayloadCleared(_srcChainId, _srcAddress, nonce, dstAddress);\n    }\n\n    //---------------------------------------------------------------------------\n    // Owner Calls, only new library version upgrade (3 steps)\n\n    // note libraryLookup[0] = 0x0, no library implementation\n    // LIBRARY UPGRADE step 1: set _newLayerZeroLibraryAddress be the new version\n    function newVersion(address _newLayerZeroLibraryAddress) external onlyOwner {\n        require(_newLayerZeroLibraryAddress != address(0x0), \"LayerZero: new version cannot be zero address\");\n        require(latestVersion < 65535, \"LayerZero: can not add new messaging library\");\n        latestVersion++;\n        libraryLookup[latestVersion] = ILayerZeroMessagingLibrary(_newLayerZeroLibraryAddress);\n        emit NewLibraryVersionAdded(latestVersion);\n    }\n\n    // LIBRARY UPGRADE step 2: stop sending messages from the old version\n    function setDefaultSendVersion(uint16 _newDefaultSendVersion) external onlyOwner validVersion(_newDefaultSendVersion) {\n        require(_newDefaultSendVersion != DEFAULT_VERSION, \"LayerZero: default send version must > 0\");\n        defaultSendVersion = _newDefaultSendVersion;\n        defaultSendLibrary = libraryLookup[defaultSendVersion];\n        emit DefaultSendVersionSet(_newDefaultSendVersion);\n    }\n\n    // LIBRARY UPGRADE step 3: stop receiving messages from the old version\n    function setDefaultReceiveVersion(uint16 _newDefaultReceiveVersion) external onlyOwner validVersion(_newDefaultReceiveVersion) {\n        require(_newDefaultReceiveVersion != DEFAULT_VERSION, \"LayerZero: default receive version must > 0\");\n        defaultReceiveVersion = _newDefaultReceiveVersion;\n        defaultReceiveLibraryAddress = address(libraryLookup[defaultReceiveVersion]);\n        emit DefaultReceiveVersionSet(_newDefaultReceiveVersion);\n    }\n\n    //---------------------------------------------------------------------------\n    // User Application Calls - UA set/get Interface\n\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override validVersion(_version) {\n        if (_version == DEFAULT_VERSION) {\n            require(defaultSendVersion == defaultReceiveVersion, \"LayerZero: can not set Config during DEFAULT migration\");\n            _version = defaultSendVersion;\n        }\n        require(_version != BLOCK_VERSION, \"LayerZero: can not set config for BLOCK_VERSION\");\n        libraryLookup[_version].setConfig(_chainId, msg.sender, _configType, _config);\n    }\n\n    // Migration step 1: set the send version\n    // Define what library the UA points too\n    function setSendVersion(uint16 _newVersion) external override validVersion(_newVersion) {\n        // write into config\n        LibraryConfig storage uaConfig = uaConfigLookup[msg.sender];\n        uaConfig.sendVersion = _newVersion;\n        // the libraryLookup[BLOCK_VERSION || DEFAULT_VERSION] = 0x0\n        uaConfig.sendLibrary = libraryLookup[_newVersion];\n        emit UaSendVersionSet(msg.sender, _newVersion);\n    }\n\n    // Migration step 2: set the receive version\n    // after all messages sent from the old version are received\n    // the UA can now safely switch to the new receive version\n    // it is the UA's responsibility make sure all messages from the old version are processed\n    function setReceiveVersion(uint16 _newVersion) external override validVersion(_newVersion) {\n        // write into config\n        LibraryConfig storage uaConfig = uaConfigLookup[msg.sender];\n        uaConfig.receiveVersion = _newVersion;\n        // the libraryLookup[BLOCK_VERSION || DEFAULT_VERSION] = 0x0\n        uaConfig.receiveLibraryAddress = address(libraryLookup[_newVersion]);\n        emit UaReceiveVersionSet(msg.sender, _newVersion);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override {\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        // revert if no messages are cached. safeguard malicious UA behaviour\n        require(sp.payloadHash != bytes32(0), \"LayerZero: no stored payload\");\n        require(sp.dstAddress == msg.sender, \"LayerZero: invalid caller\");\n\n        // empty the storedPayload\n        sp.payloadLength = 0;\n        sp.dstAddress = address(0);\n        sp.payloadHash = bytes32(0);\n\n        // emit the event with the new nonce\n        emit UaForceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    //---------------------------------------------------------------------------\n    // view helper function\n\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParams) external view override returns (uint nativeFee, uint zroFee) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        ILayerZeroMessagingLibrary lib = uaConfig.sendVersion == DEFAULT_VERSION ? defaultSendLibrary : uaConfig.sendLibrary;\n        return lib.estimateFees(_dstChainId, _userApplication, _payload, _payInZRO, _adapterParams);\n    }\n\n    function _getSendLibrary(LibraryConfig storage uaConfig) internal view returns (ILayerZeroMessagingLibrary) {\n        if (uaConfig.sendVersion == DEFAULT_VERSION) {\n            // check if the in send-blocking upgrade\n            require(defaultSendVersion != BLOCK_VERSION, \"LayerZero: default in BLOCK_VERSION\");\n            return defaultSendLibrary;\n        } else {\n            // check if the in send-blocking upgrade\n            require(uaConfig.sendVersion != BLOCK_VERSION, \"LayerZero: in BLOCK_VERSION\");\n            return uaConfig.sendLibrary;\n        }\n    }\n\n    function getSendLibraryAddress(address _userApplication) external view override returns (address sendLibraryAddress) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        uint16 sendVersion = uaConfig.sendVersion;\n        require(sendVersion != BLOCK_VERSION, \"LayerZero: send version is BLOCK_VERSION\");\n        if (sendVersion == DEFAULT_VERSION) {\n            require(defaultSendVersion != BLOCK_VERSION, \"LayerZero: send version (default) is BLOCK_VERSION\");\n            sendLibraryAddress = address(defaultSendLibrary);\n        } else {\n            sendLibraryAddress = address(uaConfig.sendLibrary);\n        }\n    }\n\n    function getReceiveLibraryAddress(address _userApplication) external view override returns (address receiveLibraryAddress) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        uint16 receiveVersion = uaConfig.receiveVersion;\n        require(receiveVersion != BLOCK_VERSION, \"LayerZero: receive version is BLOCK_VERSION\");\n        if (receiveVersion == DEFAULT_VERSION) {\n            require(defaultReceiveVersion != BLOCK_VERSION, \"LayerZero: receive version (default) is BLOCK_VERSION\");\n            receiveLibraryAddress = defaultReceiveLibraryAddress;\n        } else {\n            receiveLibraryAddress = uaConfig.receiveLibraryAddress;\n        }\n    }\n\n    function isSendingPayload() external view override returns (bool) {\n        return _send_entered_state == _ENTERED;\n    }\n\n    function isReceivingPayload() external view override returns (bool) {\n        return _receive_entered_state == _ENTERED;\n    }\n\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view override returns (uint64) {\n        return inboundNonce[_srcChainId][_srcAddress];\n    }\n\n    function getOutboundNonce(uint16, address) external pure override returns (uint64) {\n        revert(\"LayerZero: no outbound nonce at endpoint\");\n    }\n\n    function getChainId() external view override returns (uint16) {\n        return chainId;\n    }\n\n    function getSendVersion(address _userApplication) external view override returns (uint16) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        return uaConfig.sendVersion == DEFAULT_VERSION ? defaultSendVersion : uaConfig.sendVersion;\n    }\n\n    function getReceiveVersion(address _userApplication) external view override returns (uint16) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        return uaConfig.receiveVersion == DEFAULT_VERSION ? defaultReceiveVersion : uaConfig.receiveVersion;\n    }\n\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view override validVersion(_version) returns (bytes memory) {\n        if (_version == DEFAULT_VERSION) {\n            require(defaultSendVersion == defaultReceiveVersion, \"LayerZero: no DEFAULT config while migration\");\n            _version = defaultSendVersion;\n        }\n        require(_version != BLOCK_VERSION, \"LayerZero: can not get config for BLOCK_VERSION\");\n        return libraryLookup[_version].getConfig(_chainId, _userApplication, _configType);\n    }\n\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view override returns (bool) {\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        return sp.payloadHash != bytes32(0);\n    }\n}\n"
    },
    "contracts/example/AltTokenUA.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/ILayerZeroEndpoint.sol\";\nimport \"../interfaces/ILayerZeroReceiver.sol\";\n\n// An example UA running on Shrapnel using ERC20 as payment token\n// To demonstrate how feeToken payment needs to be atomic with layerzero send\ncontract AltTokenUA is ILayerZeroReceiver {\n    ILayerZeroEndpoint public endpoint;\n    IERC20 public feeToken;\n    address public feeHandler;\n\n    constructor(address _endpoint, address _feeToken, address _feeHandler) {\n        endpoint = ILayerZeroEndpoint(_endpoint);\n        feeToken = IERC20(_feeToken);\n        feeHandler = _feeHandler;\n    }\n\n    function send(uint16 _dstChainId, address _dstAddress, bytes memory _payload, bytes memory _adapterParams, uint _fee) public payable {\n        feeToken.transferFrom(msg.sender, feeHandler, _fee);\n\n        bytes memory path = abi.encodePacked(_dstAddress, address(this));\n        endpoint.send(_dstChainId, path, _payload, msg.sender, address(0), _adapterParams);\n    }\n\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes memory _fromAddress,\n        uint64, /*_nonce*/\n        bytes memory _payload\n    ) external virtual override {\n        //do nothing\n    }\n}"
    },
    "contracts/FeeHandler.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract FeeHandler is Ownable {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable feeToken;\n    mapping(address => bool) public approved;\n\n    constructor(address _feeToken) {\n        feeToken = IERC20(_feeToken);\n    }\n\n    function approve(address _uln) external onlyOwner {\n        approved[_uln] = true;\n    }\n\n    function creditFee(address[] calldata _receivers, uint[] calldata _amounts, address _refundAddress) external {\n        require(approved[msg.sender], \"FeeHandler: not approved\");\n\n        for(uint i = 0; i < _receivers.length; i++) {\n            feeToken.safeTransfer(_receivers[i], _amounts[i]);\n        }\n        uint remaining = feeToken.balanceOf(address(this));\n        if(remaining > 0) {\n            feeToken.safeTransfer(_refundAddress, remaining);\n        }\n    }\n}"
    },
    "contracts/interfaces/IContractOne.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface IContractOne {\n    function setIt(uint x) external;\n}"
    },
    "contracts/interfaces/ILayerZeroEndpoint.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\n\n    // @notice get the inboundNonce of a receiver from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}\n"
    },
    "contracts/interfaces/ILayerZeroMessagingLibrary.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface ILayerZeroMessagingLibrary {\n    // send(), messages will be inflight.\n    function send(address _userApplication, uint64 _lastNonce, uint16 _chainId, bytes calldata _destination, bytes calldata _payload, address payable refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    // estimate native fee at the send side\n    function estimateFees(uint16 _chainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n    //---------------------------------------------------------------------------\n    // setConfig / getConfig are User Application (UA) functions to specify Oracle, Relayer, blockConfirmations, libraryVersion\n    function setConfig(uint16 _chainId, address _userApplication, uint _configType, bytes calldata _config) external;\n\n    function getConfig(uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n}\n"
    },
    "contracts/interfaces/ILayerZeroMessagingLibraryV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\nimport \"./ILayerZeroMessagingLibrary.sol\";\n\ninterface ILayerZeroMessagingLibraryV2 is ILayerZeroMessagingLibrary {\n    function getOutboundNonce(uint16 _chainId, bytes calldata _path) external view returns (uint64);\n}\n"
    },
    "contracts/interfaces/ILayerZeroOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\n\ninterface ILayerZeroOracle {\n    // @notice query the oracle price for relaying block information to the destination chain\n    // @param _dstChainId the destination endpoint identifier\n    // @param _outboundProofType the proof type identifier to specify the data to be relayed\n    function getPrice(uint16 _dstChainId, uint16 _outboundProofType) external view returns (uint price);\n\n    // @notice Ultra-Light Node notifies the Oracle of a new block information relaying request\n    // @param _dstChainId the destination endpoint identifier\n    // @param _outboundProofType the proof type identifier to specify the data to be relayed\n    // @param _outboundBlockConfirmations the number of source chain block confirmation needed\n    function notifyOracle(uint16 _dstChainId, uint16 _outboundProofType, uint64 _outboundBlockConfirmations) external;\n\n    // @notice query if the address is an approved actor for privileges like data submission and fee withdrawal etc.\n    // @param _address the address to be checked\n    function isApproved(address _address) external view returns (bool approved);\n}\n"
    },
    "contracts/interfaces/ILayerZeroOracleV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\n\ninterface ILayerZeroOracleV2 {\n    // @notice query price and assign jobs at the same time\n    // @param _dstChainId - the destination endpoint identifier\n    // @param _outboundProofType - the proof type identifier to specify proof to be relayed\n    // @param _outboundBlockConfirmation - block confirmation delay before relaying blocks\n    // @param _userApplication - the source sending contract address\n    function assignJob(uint16 _dstChainId, uint16 _outboundProofType, uint64 _outboundBlockConfirmation, address _userApplication) external returns (uint price);\n\n    // @notice query the oracle price for relaying block information to the destination chain\n    // @param _dstChainId the destination endpoint identifier\n    // @param _outboundProofType the proof type identifier to specify the data to be relayed\n    // @param _outboundBlockConfirmation - block confirmation delay before relaying blocks\n    // @param _userApplication - the source sending contract address\n    function getFee(uint16 _dstChainId, uint16 _outboundProofType, uint64 _outboundBlockConfirmation, address _userApplication) external view returns (uint price);\n\n    // @notice withdraw the accrued fee in ultra light node\n    // @param _to - the fee receiver\n    // @param _amount - the withdrawal amount\n    function withdrawFee(address payable _to, uint _amount) external;\n}\n"
    },
    "contracts/interfaces/ILayerZeroPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\ninterface ILayerZeroPriceFeed {\n    /**\n     * @dev\n     * priceRatio: (USD price of 1 unit of remote native token in unit of local native token) * PRICE_RATIO_DENOMINATOR\n     */\n\n    struct Price {\n        uint128 priceRatio; // float value * 10 ^ 10, decimal awared. for aptos to evm, the basis would be (10^18 / 10^8) * 10 ^10 = 10 ^ 20.\n        uint64 gasPriceInUnit; // for evm, it is in wei, for aptos, it is in octas.\n        uint32 gasPerByte;\n    }\n\n    struct UpdatePrice {\n        uint16 chainId;\n        Price price;\n    }\n\n    /**\n     * @dev\n     *    ArbGasInfo.go:GetPricesInArbGas\n     *\n     */\n    struct ArbitrumPriceExt {\n        uint64 gasPerL2Tx; // L2 overhead\n        uint32 gasPerL1CallDataByte;\n    }\n\n    struct UpdatePriceExt {\n        uint16 chainId;\n        Price price;\n        ArbitrumPriceExt extend;\n    }\n\n    function getPrice(uint16 _dstChainId) external view returns (Price memory);\n\n    function getPriceRatioDenominator() external view returns (uint128);\n    function estimateFeeByChain(uint16 _dstChainId, uint _callDataSize, uint _gas) external view returns (uint fee, uint128 priceRatio);\n}\n"
    },
    "contracts/interfaces/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroReceiver {\n    // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\n    // @param _srcChainId - the source endpoint identifier\n    // @param _srcAddress - the source sending contract address from the source chain\n    // @param _nonce - the ordered message nonce\n    // @param _payload - the signed payload is the UA bytes has encoded to be sent\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\n}\n"
    },
    "contracts/interfaces/ILayerZeroRelayer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\n\ninterface ILayerZeroRelayer {\n    // @notice query the relayer price for relaying the payload and its proof to the destination chain\n    // @param _dstChainId - the destination endpoint identifier\n    // @param _outboundProofType - the proof type identifier to specify proof to be relayed\n    // @param _userApplication - the source sending contract address. relayers may apply price discrimination to user apps\n    // @param _payloadSize - the length of the payload. it is an indicator of gas usage for relaying cross-chain messages\n    // @param _adapterParams - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain\n    function getPrice(uint16 _dstChainId, uint16 _outboundProofType, address _userApplication, uint _payloadSize, bytes calldata _adapterParams) external view returns (uint price);\n\n    // @notice Ultra-Light Node notifies the Oracle of a new block information relaying request\n    // @param _dstChainId - the destination endpoint identifier\n    // @param _outboundProofType - the proof type identifier to specify the data to be relayed\n    // @param _adapterParams - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain\n    function notifyRelayer(uint16 _dstChainId, uint16 _outboundProofType, bytes calldata _adapterParams) external;\n\n    // @notice query if the address is an approved actor for privileges like data submission and fee withdrawal etc.\n    // @param _address - the address to be checked\n    function isApproved(address _address) external view returns (bool approved);\n}\n"
    },
    "contracts/interfaces/ILayerZeroRelayerV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\n\ninterface ILayerZeroRelayerV2 {\n    // @notice query price and assign jobs at the same time\n    // @param _dstChainId - the destination endpoint identifier\n    // @param _outboundProofType - the proof type identifier to specify proof to be relayed\n    // @param _userApplication - the source sending contract address. relayers may apply price discrimination to user apps\n    // @param _payloadSize - the length of the payload. it is an indicator of gas usage for relaying cross-chain messages\n    // @param _adapterParams - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain\n    function assignJob(uint16 _dstChainId, uint16 _outboundProofType, address _userApplication, uint _payloadSize, bytes calldata _adapterParams) external returns (uint price);\n\n    // @notice query the relayer price for relaying the payload and its proof to the destination chain\n    // @param _dstChainId - the destination endpoint identifier\n    // @param _outboundProofType - the proof type identifier to specify proof to be relayed\n    // @param _userApplication - the source sending contract address. relayers may apply price discrimination to user apps\n    // @param _payloadSize - the length of the payload. it is an indicator of gas usage for relaying cross-chain messages\n    // @param _adapterParams - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain\n    function getFee(uint16 _dstChainId, uint16 _outboundProofType, address _userApplication, uint _payloadSize, bytes calldata _adapterParams) external view returns (uint price);\n\n    // @notice withdraw the accrued fee in ultra light node\n    // @param _to - the fee receiver\n    // @param _amount - the withdrawal amount\n    function withdrawFee(address payable _to, uint _amount) external;\n}\n"
    },
    "contracts/interfaces/ILayerZeroRelayerV2PriceData.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\n\npragma abicoder v2;\n\ninterface ILayerZeroRelayerV2PriceData {\n\n    struct DstPrice {\n        uint128 dstPriceRatio; // 10^10\n        uint128 dstGasPriceInWei;\n    }\n\n    struct DstConfig {\n        uint128 dstNativeAmtCap;\n        uint64 baseGas;\n        uint64 gasPerByte;\n    }\n\n    function dstPriceLookup(uint16 _chainId) external view returns (DstPrice memory);\n\n    function dstConfigLookup(uint16 _chainId, uint16 _outboundProofType) external view returns (DstConfig memory);\n}"
    },
    "contracts/interfaces/ILayerZeroTreasury.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroTreasury {\n    function getFees(bool payInZro, uint relayerFee, uint oracleFee) external view returns (uint);\n}\n"
    },
    "contracts/interfaces/ILayerZeroUltraLightNodeV1.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\n\ninterface ILayerZeroUltraLightNodeV1 {\n    // a Relayer can execute the validateTransactionProof()\n    function validateTransactionProof(uint16 _srcChainId, address _dstAddress, uint _gasLimit, bytes32 _lookupHash, bytes calldata _transactionProof) external;\n\n    // an Oracle delivers the block data using updateHash()\n    function updateHash(uint16 _remoteChainId, bytes32 _lookupHash, uint _confirmations, bytes32 _data) external;\n\n    // can only withdraw the receivable of the msg.sender\n    function withdrawNative(uint8 _type, address _owner, address payable _to, uint _amount) external;\n\n    function withdrawZRO(address _to, uint _amount) external;\n\n    // view functions\n    function oracleQuotedAmount(address _oracle) external view returns (uint);\n\n    function relayerQuotedAmount(address _relayer) external view returns (uint);\n}\n"
    },
    "contracts/interfaces/ILayerZeroUltraLightNodeV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\ninterface ILayerZeroUltraLightNodeV2 {\n    // Relayer functions\n    function validateTransactionProof(uint16 _srcChainId, address _dstAddress, uint _gasLimit, bytes32 _lookupHash, bytes32 _blockData, bytes calldata _transactionProof) external;\n\n    // an Oracle delivers the block data using updateHash()\n    function updateHash(uint16 _srcChainId, bytes32 _lookupHash, uint _confirmations, bytes32 _blockData) external;\n\n    // can only withdraw the receivable of the msg.sender\n    function withdrawNative(address payable _to, uint _amount) external;\n\n    function withdrawZRO(address _to, uint _amount) external;\n\n    // view functions\n    function getAppConfig(uint16 _remoteChainId, address _userApplicationAddress) external view returns (ApplicationConfiguration memory);\n\n    function accruedNativeFee(address _address) external view returns (uint);\n\n    struct ApplicationConfiguration {\n        uint16 inboundProofLibraryVersion;\n        uint64 inboundBlockConfirmations;\n        address relayer;\n        uint16 outboundProofType;\n        uint64 outboundBlockConfirmations;\n        address oracle;\n    }\n\n    event HashReceived(uint16 indexed srcChainId, address indexed oracle, bytes32 lookupHash, bytes32 blockData, uint confirmations);\n    event RelayerParams(bytes adapterParams, uint16 outboundProofType);\n    event Packet(bytes payload);\n    event InvalidDst(uint16 indexed srcChainId, bytes srcAddress, address indexed dstAddress, uint64 nonce, bytes32 payloadHash);\n    event PacketReceived(uint16 indexed srcChainId, bytes srcAddress, address indexed dstAddress, uint64 nonce, bytes32 payloadHash);\n    event AppConfigUpdated(address indexed userApplication, uint indexed configType, bytes newConfig);\n    event AddInboundProofLibraryForChain(uint16 indexed chainId, address lib);\n    event EnableSupportedOutboundProof(uint16 indexed chainId, uint16 proofType);\n    event SetChainAddressSize(uint16 indexed chainId, uint size);\n    event SetDefaultConfigForChainId(uint16 indexed chainId, uint16 inboundProofLib, uint64 inboundBlockConfirm, address relayer, uint16 outboundProofType, uint64 outboundBlockConfirm, address oracle);\n    event SetDefaultAdapterParamsForChainId(uint16 indexed chainId, uint16 indexed proofType, bytes adapterParams);\n    event SetLayerZeroToken(address indexed tokenAddress);\n    event SetRemoteUln(uint16 indexed chainId, bytes32 uln);\n    event SetTreasury(address indexed treasuryAddress);\n    event WithdrawZRO(address indexed msgSender, address indexed to, uint amount);\n    event WithdrawNative(address indexed msgSender, address indexed to, uint amount);\n}\n"
    },
    "contracts/interfaces/ILayerZeroUserApplicationConfig.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroUserApplicationConfig {\n    // @notice set the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    // @param _config - configuration in the bytes. can encode arbitrary content.\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\n\n    // @notice set the send() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setSendVersion(uint16 _version) external;\n\n    // @notice set the lzReceive() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setReceiveVersion(uint16 _version) external;\n\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n    // @param _srcChainId - the chainId of the source chain\n    // @param _srcAddress - the contract address of the source contract at the source chain\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}\n"
    },
    "contracts/interfaces/ILayerZeroValidationLibrary.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\nimport \"../proof/utility/LayerZeroPacket.sol\";\n\ninterface ILayerZeroValidationLibrary {\n    function validateProof(bytes32 blockData, bytes calldata _data, uint _remoteAddressSize) external returns (LayerZeroPacket.Packet memory packet);\n}\n"
    },
    "contracts/interfaces/IValidationLibraryHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\nimport \"../proof/utility/LayerZeroPacket.sol\";\nimport \"./ILayerZeroValidationLibrary.sol\";\n\ninterface IValidationLibraryHelper {\n    struct ULNLog {\n        bytes32 contractAddress;\n        bytes32 topicZeroSig;\n        bytes data;\n    }\n\n    function getVerifyLog(bytes32 hashRoot, uint[] memory receiptSlotIndex, uint logIndex, bytes[] memory proof) external pure returns (ULNLog memory);\n\n    function getPacket(bytes memory data, uint16 srcChain, uint sizeOfSrcAddress, bytes32 ulnAddress) external pure returns (LayerZeroPacket.Packet memory);\n\n    function getUtilsVersion() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IValidationLibraryHelperV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\nimport \"../proof/utility/LayerZeroPacket.sol\";\n\ninterface IValidationLibraryHelperV2 {\n    struct ULNLog {\n        bytes32 contractAddress;\n        bytes32 topicZeroSig;\n        bytes data;\n    }\n\n    function getVerifyLog(bytes32 hashRoot, uint[] calldata receiptSlotIndex, uint logIndex, bytes[] calldata proof) external pure returns (ULNLog memory);\n\n    function getPacket(bytes calldata data, uint sizeOfSrcAddress, bytes32 ulnAddress) external pure returns (LayerZeroPacket.Packet memory);\n\n    function getUtilsVersion() external view returns (uint8);\n\n    function getProofType() external view returns (uint8);\n}\n"
    },
    "contracts/mocks/ContractTwo.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\n\nimport \"../interfaces/IContractOne.sol\";\n\ncontract ContractTwo {\n\n    address contractOne;\n\n    constructor(address _contractOne){\n        contractOne = _contractOne;\n    }\n\n    function callSetIt(uint _gasLimit) external {\n        IContractOne(contractOne).setIt{gas:_gasLimit}(1);\n    }\n\n}\n"
    },
    "contracts/mocks/GIN.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\npragma abicoder v2;\nimport \"../interfaces/ILayerZeroReceiver.sol\";\nimport \"../interfaces/ILayerZeroEndpoint.sol\";\n\ncontract GIN is ILayerZeroReceiver {\n    bool public messageComplete;\n    ILayerZeroEndpoint public endpoint;\n\n    event Message(bytes32 indexed message);\n\n    constructor(address _endpoint) {\n        endpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(\n        uint16,\n        bytes memory, /*_fromAddress*/\n        uint64,\n        bytes memory _payload\n    ) external override {\n        require(msg.sender == address(endpoint));\n        bytes32 message;\n        assembly {\n            message := mload(add(_payload, 32))\n        }\n        emit Message(message);\n        messageComplete = true;\n    }\n\n    function sendFirstMessage(uint gasAmountForDst, uint16[] calldata chainIds, bytes[] calldata dstAddresses) external payable {\n        require(!messageComplete, \"The first message of LayerZero has already been sent\");\n        uint16 version = 1;\n        bytes memory _relayerParams = abi.encodePacked(version, gasAmountForDst);\n\n        bytes32 message = \"GIN\";\n        bytes memory messageString = bytes(abi.encodePacked(message));\n        uint length = chainIds.length;\n        uint fee = msg.value / length;\n        for (uint i = 0; i < length; i++) {\n            endpoint.send{value: fee}(chainIds[i], dstAddresses[i], messageString, msg.sender, address(0x0), _relayerParams);\n        }\n    }\n}\n"
    },
    "contracts/mocks/LayerZeroOracleBadMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/ILayerZeroOracle.sol\";\nimport \"../interfaces/ILayerZeroUltraLightNodeV1.sol\";\nimport \"../interfaces/ILayerZeroEndpoint.sol\";\n\n// mock is designed to try and send the msg it just received again to trigger a revert\ncontract LayerZeroOracleBadMock is ILayerZeroOracle, Ownable, ReentrancyGuard {\n    mapping(address => bool) public approvedAddresses;\n    mapping(uint16 => mapping(uint16 => uint)) public chainPriceLookup;\n    uint public fee;\n    ILayerZeroUltraLightNodeV1 public uln; // ultraLightNode instance\n    ILayerZeroEndpoint public endpoint; // for bad oracles trying to talk to endpoint\n\n    event OracleNotified(uint16 dstChainId, uint16 _outboundProofType, uint blockConfirmations);\n    event Withdraw(address to, uint amount);\n\n    constructor() {\n        approvedAddresses[msg.sender] = true;\n    }\n\n    function notifyOracle(uint16 _dstChainId, uint16 _outboundProofType, uint64 _outboundBlockConfirmations) external override {\n        // oracle is set to do bad things and try to call send again, this should revert\n        endpoint.send(_dstChainId, \"0x\", \"0x\", address(0), address(0), \"0x\");\n        emit OracleNotified(_dstChainId, _outboundProofType, _outboundBlockConfirmations);\n    }\n\n    function updateHash(uint16 _remoteChainId, bytes32 _blockHash, uint _confirmations, bytes32 _data) external {\n        require(approvedAddresses[msg.sender], \"LayerZeroOracleMock: caller must be approved\");\n        uln.updateHash(_remoteChainId, _blockHash, _confirmations, _data);\n    }\n\n    function withdraw(address payable _to, uint _amount) public onlyOwner nonReentrant {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"failed to withdraw\");\n        emit Withdraw(_to, _amount);\n    }\n\n    // owner can set uln\n    function setUln(address ulnAddress) external onlyOwner {\n        uln = ILayerZeroUltraLightNodeV1(ulnAddress);\n    }\n\n    // owner can set uln\n    function setEndpoint(address endpointAddress) external onlyOwner {\n        endpoint = ILayerZeroEndpoint(endpointAddress);\n    }\n\n    // mock, doesnt do anything\n    function setJob(uint16 _chain, address _oracle, bytes32 _id, uint _fee) public onlyOwner {}\n\n    // mocked for now\n    function assignJob(\n        uint16 _dstChainId,\n        uint16, /*_outboundProofType*/\n        uint64, /*_outboundBlockConfirmation*/\n        address\n    ) external returns (uint price) {\n        // oracle is set to do bad things and try to call send again, this should revert\n        endpoint.send(_dstChainId, \"0x\", \"0x\", address(0), address(0), \"0x\");\n        return 1;\n    }\n\n    function setDeliveryAddress(uint16 _dstChainId, address _deliveryAddress) public onlyOwner {}\n\n    function setPrice(uint16 _destinationChainId, uint16 _outboundProofType, uint _price) external onlyOwner {\n        chainPriceLookup[_outboundProofType][_destinationChainId] = _price;\n    }\n\n    function setApprovedAddress(address _oracleAddress, bool _approve) external {\n        approvedAddresses[_oracleAddress] = _approve;\n    }\n\n    function isApproved(address _relayerAddress) public view override returns (bool) {\n        return approvedAddresses[_relayerAddress];\n    }\n\n    function getPrice(uint16 _destinationChainId, uint16 _outboundProofType) external view override returns (uint) {\n        return chainPriceLookup[_outboundProofType][_destinationChainId];\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}\n"
    },
    "contracts/mocks/LayerZeroOracleMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/ILayerZeroOracle.sol\";\nimport \"../interfaces/ILayerZeroUltraLightNodeV1.sol\";\n\ncontract LayerZeroOracleMock is ILayerZeroOracle, Ownable, ReentrancyGuard {\n    mapping(address => bool) public approvedAddresses;\n    mapping(uint16 => mapping(uint16 => uint)) public chainPriceLookup;\n    uint public fee;\n    ILayerZeroUltraLightNodeV1 public uln; // ultraLightNode instance\n\n    event OracleNotified(uint16 dstChainId, uint16 _outboundProofType, uint blockConfirmations);\n    event Withdraw(address to, uint amount);\n\n    constructor() {\n        approvedAddresses[msg.sender] = true;\n    }\n\n    function notifyOracle(uint16 _dstChainId, uint16 _outboundProofType, uint64 _outboundBlockConfirmations) external override {\n        emit OracleNotified(_dstChainId, _outboundProofType, _outboundBlockConfirmations);\n    }\n\n    function updateHash(uint16 _remoteChainId, bytes32 _blockHash, uint _confirmations, bytes32 _data) external {\n        require(approvedAddresses[msg.sender], \"LayerZeroOracleMock: caller must be approved\");\n        uln.updateHash(_remoteChainId, _blockHash, _confirmations, _data);\n    }\n\n    function withdraw(address payable _to, uint _amount) public onlyOwner nonReentrant {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"failed to withdraw\");\n        emit Withdraw(_to, _amount);\n    }\n\n    // owner can set uln\n    function setUln(address ulnAddress) external onlyOwner {\n        uln = ILayerZeroUltraLightNodeV1(ulnAddress);\n    }\n\n    // mock, doesnt do anything\n    function setJob(uint16 _chain, address _oracle, bytes32 _id, uint _fee) public onlyOwner {}\n\n    function setDeliveryAddress(uint16 _dstChainId, address _deliveryAddress) public onlyOwner {}\n\n    function setPrice(uint16 _destinationChainId, uint16 _outboundProofType, uint _price) external onlyOwner {\n        chainPriceLookup[_outboundProofType][_destinationChainId] = _price;\n    }\n\n    function setApprovedAddress(address _oracleAddress, bool _approve) external {\n        approvedAddresses[_oracleAddress] = _approve;\n    }\n\n    function isApproved(address _relayerAddress) public view override returns (bool) {\n        return approvedAddresses[_relayerAddress];\n    }\n\n    function getPrice(uint16 _destinationChainId, uint16 _outboundProofType) external view override returns (uint) {\n        return chainPriceLookup[_outboundProofType][_destinationChainId];\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}\n"
    },
    "contracts/mocks/LayerZeroOracleMockV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/ILayerZeroOracleV2.sol\";\nimport \"../interfaces/ILayerZeroUltraLightNodeV2.sol\";\n\ncontract LayerZeroOracleMockV2 is ILayerZeroOracleV2, Ownable, ReentrancyGuard {\n    mapping(address => bool) public approvedAddresses;\n    mapping(uint16 => mapping(uint16 => uint)) public chainPriceLookup;\n    mapping(uint16 => mapping(uint16 => uint64)) public jobs; // mocked, not used for anything yet\n    uint public fee;\n    ILayerZeroUltraLightNodeV2 public uln; // ultraLightNode instance\n\n    event OracleNotified(uint16 dstChainId, uint16 _outboundProofType, uint blockConfirmations);\n    event Withdraw(address to, uint amount);\n\n    constructor() {\n        approvedAddresses[msg.sender] = true;\n    }\n\n    // mocked for now, will auto accept the job, and return the price at the same time\n    function assignJob(uint16 _dstChainId, uint16 _outboundProofType, uint64 _outboundBlockConfirmation, address) external override returns (uint price) {\n        jobs[_dstChainId][_outboundProofType] = _outboundBlockConfirmation;\n        return chainPriceLookup[_outboundProofType][_dstChainId];\n    }\n\n    function getFee(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        uint64, /*_outboundBlockConfirmation*/\n        address\n    ) external view override returns (uint) {\n        return chainPriceLookup[_outboundProofType][_dstChainId];\n    }\n\n    function withdrawFee(address payable _to, uint _amount) public override onlyOwner nonReentrant {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"failed to withdraw\");\n        emit Withdraw(_to, _amount);\n    }\n\n    function updateHash(uint16 _remoteChainId, bytes32 _blockHash, uint _confirmations, bytes32 _data) external {\n        require(approvedAddresses[msg.sender], \"LayerZeroOracleMock: caller must be approved\");\n        uln.updateHash(_remoteChainId, _blockHash, _confirmations, _data);\n    }\n\n    function setUln(address ulnAddress) external onlyOwner {\n        uln = ILayerZeroUltraLightNodeV2(ulnAddress);\n    }\n\n    function setDeliveryAddress(uint16 _dstChainId, address _deliveryAddress) public onlyOwner {}\n\n    function setPrice(uint16 _destinationChainId, uint16 _outboundProofType, uint _price) external onlyOwner {\n        chainPriceLookup[_outboundProofType][_destinationChainId] = _price;\n    }\n\n    function setApprovedAddress(address _oracleAddress, bool _approve) external {\n        approvedAddresses[_oracleAddress] = _approve;\n    }\n\n    function isApproved(address _relayerAddress) public view returns (bool) {\n        return approvedAddresses[_relayerAddress];\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}\n"
    },
    "contracts/mocks/LayerZeroTokenMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract LayerZeroTokenMock is ERC20 {\n    constructor() ERC20(\"LayerZeroTokenMock\", \"LZTM\") {\n        _mint(msg.sender, 1_000_000 * 10**18);\n    }\n}\n"
    },
    "contracts/mocks/MockToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n// this is a MOCK\ncontract MockToken is ERC20 {\n    // this is a MOCK\n    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {\n        _mint(msg.sender, 1000000000000000000000);\n    }\n\n    // this is a MOCK\n    function mint(address _to, uint _amount) public {\n        _mint(_to, _amount);\n    }\n\n    //Mocked to imitate what happens if a transfer fails\n    function transfer(address recipient, uint amount) public virtual override returns (bool) {\n        require(recipient != address(0x1));\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n}\n"
    },
    "contracts/mocks/OmniCounter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\npragma abicoder v2;\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/ILayerZeroReceiver.sol\";\nimport \"../interfaces/ILayerZeroEndpoint.sol\";\nimport \"../interfaces/ILayerZeroUserApplicationConfig.sol\";\nimport \"../Relayer.sol\";\n\ncontract OmniCounter is Ownable, ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\n    using SafeMath for uint;\n\n    // keep track of how many messages have been received from other chains\n    uint public messageCounter;\n    mapping(address => uint) public remoteAddressCounter;\n    // required: the LayerZero endpoint which is passed in the constructor\n    ILayerZeroEndpoint public endpoint;\n    bool public payInZRO;\n\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n\n    constructor(address _endpoint) {\n        endpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function getCounter() public view returns (uint) {\n        return messageCounter;\n    }\n\n    // overrides lzReceive function in ILayerZeroReceiver.\n    // automatically invoked on the receiving chain after the source chain calls endpoint.send(...)\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes memory _fromAddress,\n        uint64, /*_nonce*/\n        bytes memory _payload\n    ) external virtual override {\n        require(msg.sender == address(endpoint));\n        _verifySourceAddress(_srcChainId, _fromAddress);\n\n        address fromAddress;\n        assembly {\n            fromAddress := mload(add(_fromAddress, 20))\n        }\n\n        // used for testing reentrant, retry sending the payload through the relayer before the initial receive has been resolved\n        // ff == '0x6666' on the payload side\n        if (keccak256(abi.encodePacked((_payload))) == keccak256(abi.encodePacked((bytes2(\"ff\")))) || keccak256(abi.encodePacked((_payload))) == keccak256(abi.encodePacked((bytes10(\"ff\"))))) {\n            endpoint.receivePayload(1, bytes(\"\"), address(0x0), 1, 1, bytes(\"\"));\n        }\n\n        remoteAddressCounter[fromAddress] += 1;\n        messageCounter += 1;\n    }\n\n    function incrementCounter(uint16 _dstChainId, bytes calldata _adapterParams, bytes calldata payload) public payable {\n        address zroPaymentAddress = payInZRO ? address(this) : address(0x0);\n        _incrementCounter(_dstChainId, payload, msg.sender, zroPaymentAddress, _adapterParams);\n    }\n\n    // call send() to multiple destinations in the same transaction!\n    function multiIncrementCounter(uint16[] calldata _dstChainIds, bytes calldata _adapterParams, bytes calldata payload) public payable {\n        // send() each chainId + dst address pair\n        uint16[] memory dstChainIds = _dstChainIds;\n        bytes memory adapterParams = _adapterParams;\n\n        uint _refund = msg.value;\n        // send() each chainId + dst address pair\n        for (uint i = 0; i < dstChainIds.length; ++i) {\n            (uint valueToSend, ) = endpoint.estimateFees(dstChainIds[i], address(this), payload, payInZRO, adapterParams);\n            _refund = _refund.sub(valueToSend);\n            // a Communicator.sol instance is the 'endpoint'\n            // .send() each payload to the destination chainId + UA destination address\n            address zroPaymentAddress = payInZRO ? address(this) : address(0x0);\n            _incrementCounter(_dstChainIds[i], payload, msg.sender, zroPaymentAddress, adapterParams);\n        }\n        // refund eth if too much was sent into this contract call\n        msg.sender.transfer(_refund);\n    }\n\n    function _incrementCounter(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) public payable {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length > 0, \"*** trustedRemote cant be 0x \");\n        endpoint.send{value: msg.value}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function setConfig(\n        uint16, /*_version*/\n        uint16 _chainId,\n        uint _configType,\n        bytes calldata _config\n    ) external override {\n        endpoint.setConfig(endpoint.getSendVersion(address(this)), _chainId, _configType, _config);\n    }\n\n    function getConfig(uint16, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return endpoint.getConfig(endpoint.getSendVersion(address(this)), _chainId, address(this), _configType);\n    }\n\n    function setSendVersion(uint16 version) external override {\n        endpoint.setSendVersion(version);\n    }\n\n    function setReceiveVersion(uint16 version) external override {\n        endpoint.setReceiveVersion(version);\n    }\n\n    function getSendVersion() external view returns (uint16) {\n        return endpoint.getSendVersion(address(this));\n    }\n\n    function getReceiveVersion() external view returns (uint16) {\n        return endpoint.getReceiveVersion(address(this));\n    }\n\n    function setOutboundBlockConfirmations(uint16 dstChainId, uint64 confirmations) external {\n        // should technically be onlyOwner but this is a mock\n        uint TYPE_OUTBOUND_BLOCK_CONFIRMATIONS = 6;\n        endpoint.setConfig(endpoint.getSendVersion(address(this)), dstChainId, TYPE_OUTBOUND_BLOCK_CONFIRMATIONS, abi.encodePacked(confirmations));\n    }\n\n    function getOutboundBlockConfirmations(uint16 remoteChainId) external view returns (bytes memory _confirmations) {\n        return endpoint.getConfig(endpoint.getSendVersion(address(this)), remoteChainId, address(this), 5);\n    }\n\n    // set the Oracle to be used by this UA for LayerZero messages\n    function setOracle(uint16 dstChainId, address oracle) external {\n        // should technically be onlyOwner but this is a mock\n        uint TYPE_ORACLE = 6; // from UltraLightNode\n        // set the Oracle\n        // uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config\n        endpoint.setConfig(endpoint.getSendVersion(address(this)), dstChainId, TYPE_ORACLE, abi.encode(oracle));\n    }\n\n    // get the configured oracle\n    function getOracle(uint16 remoteChainId) external view returns (address _oracle) {\n        bytes memory bytesOracle = endpoint.getConfig(endpoint.getSendVersion(address(this)), remoteChainId, address(this), 6);\n        assembly {\n            _oracle := mload(add(bytesOracle, 32))\n        }\n    }\n\n    // set the Relayer to be used by this UA for LayerZero messages\n    function setRelayer(uint16 dstChainId, address relayer) external {\n        uint TYPE_RELAYER = 3;\n        endpoint.setConfig(endpoint.getSendVersion(address(this)), dstChainId, TYPE_RELAYER, abi.encode(relayer));\n    }\n\n    // set the inbound block confirmations\n    function setInboundConfirmations(uint16 remoteChainId, uint16 confirmations) external {\n        endpoint.setConfig(\n            endpoint.getSendVersion(address(this)),\n            remoteChainId,\n            2, // CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS\n            abi.encode(confirmations)\n        );\n    }\n\n    // set outbound block confirmations\n    function setOutboundConfirmations(uint16 remoteChainId, uint16 confirmations) external {\n        endpoint.setConfig(\n            endpoint.getSendVersion(address(this)),\n            remoteChainId,\n            5, // CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS\n            abi.encode(confirmations)\n        );\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override {\n        // ignored for this contract\n    }\n\n    function setPayInZRO(bool _payInZRO) external onlyOwner {\n        payInZRO = _payInZRO;\n    }\n\n    function approveTokenSpender(address token, address spender, uint amount) external onlyOwner {\n        IERC20(token).approve(spender, amount);\n    }\n\n    // allow this contract to receive ether\n    fallback() external payable {}\n\n    receive() external payable {\n        // Mock the ability to reject payments\n        require(msg.value < 1000 && msg.value != 10, \"Did you mean to send a blocked amount - check receive() / fallback()\");\n    }\n\n    // allow owner to set it multiple times.\n    function setTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external onlyOwner {\n        trustedRemoteLookup[_srcChainId] = _srcAddress;\n    }\n\n    function _verifySourceAddress(uint16 _srcChainId, bytes memory _fromAddress) internal view {\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        require(trustedRemote.length != 0 && keccak256(_fromAddress) == keccak256(trustedRemote), \"source counter is not trusted\");\n    }\n}\n"
    },
    "contracts/mocks/PingPong.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n//\n// Note: you will need to fund each deployed contract with gas\n//\n// PingPong sends a LayerZero message back and forth between chains until stopped!\n//\n// Demonstrates:\n//  1. a recursive feature of calling send() from inside lzReceive()\n//  2. how to `estimateFees` for a send()'ing a LayerZero message\n//  3. the contract pays the message fee\n\npragma solidity ^0.7.6;\npragma abicoder v2;\nimport \"../interfaces/ILayerZeroReceiver.sol\";\nimport \"../interfaces/ILayerZeroEndpoint.sol\";\nimport \"../interfaces/ILayerZeroUserApplicationConfig.sol\";\n\ncontract PingPong is ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\n    // the LayerZero endpoint calls .send() to send a cross chain message\n    ILayerZeroEndpoint public endpoint;\n    // whether PingPong is ping-ponging\n    bool public pingsEnabled;\n    // event emitted every ping() to keep track of consecutive pings count\n    event Ping(uint pings);\n    // the maxPings before ending the loop\n    uint public maxPings;\n    // keep track of the totalPings sent\n    uint public numPings;\n    bool public isUlnV2;\n\n    // constructor requires the LayerZero endpoint for this chain\n    constructor(address _layerZeroEndpoint, bool _isUlnV2) {\n        pingsEnabled = true;\n        endpoint = ILayerZeroEndpoint(_layerZeroEndpoint);\n        maxPings = 5;\n        isUlnV2 = _isUlnV2;\n    }\n\n    // disable ping-ponging\n    function disable() external {\n        pingsEnabled = false;\n    }\n\n    // pings the destination chain, along with the current number of pings sent\n    function ping(\n        uint16 _dstChainId, // send a ping to this destination chainId\n        address _dstPingPongAddr, // destination address of PingPong contract\n        uint pings // the uint to start at. use 0 as a default\n    ) public {\n        require(address(this).balance > 0, \"the balance of this contract is 0. pls send gas for message fees\");\n        require(pingsEnabled, \"pingsEnabled is false. messages stopped\");\n        require(maxPings > pings, \"maxPings has been reached, no more looping\");\n\n        emit Ping(pings);\n\n        // abi.encode() the payload with the number of pings sent\n        bytes memory payload = abi.encode(pings);\n\n        // encode adapterParams to specify more gas for the destination\n        uint16 version = 1;\n        uint gasForDestinationLzReceive = 350000;\n        bytes memory adapterParams = abi.encodePacked(version, gasForDestinationLzReceive);\n\n        // get the fees we need to pay to LayerZero + Relayer to cover message delivery\n        // see Communicator.sol's .estimateNativeFees() function for more details.\n        (uint messageFee, ) = endpoint.estimateFees(_dstChainId, address(this), payload, false, adapterParams);\n        require(address(this).balance >= messageFee, \"address(this).balance < messageFee. pls send gas for message fees\");\n\n        bytes memory path = isUlnV2 ? abi.encodePacked(_dstPingPongAddr, address(this)) : abi.encodePacked(_dstPingPongAddr);\n\n        // send LayerZero message\n        endpoint.send{value: messageFee}( // {value: messageFee} will be paid out of this contract!\n            _dstChainId, // destination chainId\n            path,\n            payload, // abi.encode()'ed bytes\n            payable(this), // (msg.sender will be this contract) refund address (LayerZero will refund any extra gas back to caller of send()\n            address(0x0), // 'zroPaymentAddress' unused for this mock/example\n            adapterParams // 'adapterParams' unused for this mock/example\n        );\n    }\n\n    // receive the bytes payload from the source chain via LayerZero\n    // _srcChainId: the chainId that we are receiving the message from.\n    // _fromAddress: the source PingPong address\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes memory _fromAddress,\n        uint64, /*_nonce*/\n        bytes memory _payload\n    ) external override {\n        require(msg.sender == address(endpoint)); // boilerplate! lzReceive must be called by the endpoint for security\n\n        // use assembly to extract the address from the bytes memory parameter\n        address fromAddress;\n        assembly {\n            fromAddress := mload(add(_fromAddress, 20))\n        }\n\n        // decode the number of pings sent thus far\n        uint pings = abi.decode(_payload, (uint));\n\n        // \"recursively\" call ping in order to *pong*     (and increment pings)\n        ++pings;\n        numPings = pings;\n\n        ping(_srcChainId, fromAddress, pings);\n    }\n\n    function setConfig(\n        uint16, /*_version*/\n        uint16 _dstChainId,\n        uint _configType,\n        bytes memory _config\n    ) external override {\n        endpoint.setConfig(_dstChainId, endpoint.getSendVersion(address(this)), _configType, _config);\n    }\n\n    function getConfig(\n        uint16, /*_dstChainId*/\n        uint16 _chainId,\n        address,\n        uint _configType\n    ) external view returns (bytes memory) {\n        return endpoint.getConfig(endpoint.getSendVersion(address(this)), _chainId, address(this), _configType);\n    }\n\n    function setSendVersion(uint16 version) external override {\n        endpoint.setSendVersion(version);\n    }\n\n    function setReceiveVersion(uint16 version) external override {\n        endpoint.setReceiveVersion(version);\n    }\n\n    function getSendVersion() external view returns (uint16) {\n        return endpoint.getSendVersion(address(this));\n    }\n\n    function getReceiveVersion() external view returns (uint16) {\n        return endpoint.getReceiveVersion(address(this));\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override {\n        // do nth\n    }\n\n    // allow this contract to receive ether\n    fallback() external payable {}\n\n    receive() external payable {}\n}\n"
    },
    "contracts/mocks/Token.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract Token is ERC20 {\n    event tried();\n    event caught();\n\n    constructor() ERC20(\"test\", \"test\") {\n        _mint(msg.sender, 10_000_000_000 * 10**18);\n    }\n\n    function selfDestruct() public {\n        selfdestruct(address(0x0));\n    }\n\n    function tryCatch(address _tokenAddress) public {\n        try ERC20(_tokenAddress).totalSupply() {\n            emit tried();\n        } catch {\n            emit caught();\n        }\n    }\n}\n"
    },
    "contracts/mocks/UltraLightNodeV2Mock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\nimport \"../interfaces/ILayerZeroUltraLightNodeV2.sol\";\n\ncontract UltraLightNodeV2Mock is ILayerZeroUltraLightNodeV2{\n\n    event executed();\n    event paidTo(address _to,uint _amount);\n\n    mapping(address => mapping(uint16 => mapping(bytes32 => mapping(bytes32 => uint)))) public hashLookup; //[oracle][srcChainId][blockhash][datahash] -> confirmation\n\n    constructor() {\n        \n    }\n//Mock version of uln for testing the withdraw fee function. If we need to use this again we can expand on it.\n // Relayer functions\n    function validateTransactionProof(uint16 _srcChainId, address _dstAddress, uint _gasLimit, bytes32 _lookupHash, bytes32 _blockData, bytes calldata _transactionProof) external override {\n        emit executed();\n    }\n\n    // an Oracle delivers the block data using updateHash()\n    function updateHash(uint16 _srcChainId, bytes32 _lookupHash, uint _confirmations, bytes32 _blockData) external override {\n        emit executed();\n    }\n\n    // can only withdraw the receivable of the msg.sender\n    function withdrawNative(address payable _to, uint _amount) external override {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        emit paidTo(_to, _amount);\n    }\n\n    function withdrawZRO(address _to, uint _amount) external override {\n        emit executed();\n    }\n\n    // view functions\n    function getAppConfig(uint16 _remoteChainId, address _userApplicationAddress) external view override returns (ApplicationConfiguration memory) {\n        \n    }\n\n    function accruedNativeFee(address _address) external view override returns (uint) {\n\n    }\n\n    receive() external payable {\n\n    }\n\n   \n\n}\n"
    },
    "contracts/NonceContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\n\ncontract NonceContract {\n    ILayerZeroEndpoint public immutable endpoint;\n    // outboundNonce = [dstChainId][remoteAddress + localAddress]\n    mapping(uint16 => mapping(bytes => uint64)) public outboundNonce;\n\n    constructor(address _endpoint) {\n        endpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function increment(uint16 _chainId, address _ua, bytes calldata _path) external returns (uint64) {\n        require(endpoint.getSendLibraryAddress(_ua) == msg.sender, \"NonceContract: msg.sender is not valid sendlibrary\");\n        return ++outboundNonce[_chainId][_path];\n    }\n}\n"
    },
    "contracts/NonceContractRadar.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\n\ncontract NonceContractRadar {\n    ILayerZeroEndpoint public immutable endpoint;\n    address public immutable ulnv2Radar;\n    // outboundNonce = [dstChainId][remoteAddress + localAddress]\n    mapping(uint16 => mapping(bytes => uint64)) public outboundNonce;\n\n    constructor(address _endpoint, address _ulnv2Radar) {\n        endpoint = ILayerZeroEndpoint(_endpoint);\n        ulnv2Radar = _ulnv2Radar;\n    }\n\n    function increment(uint16 _chainId, address _ua, bytes calldata _path) external returns (uint64) {\n        require(endpoint.getSendLibraryAddress(_ua) == msg.sender, \"NonceContract: msg.sender is not valid sendlibrary\");\n        return ++outboundNonce[_chainId][_path];\n    }\n\n    // only ulnv2Radar can call this function\n    function initRadarOutboundNonce(uint16 _dstChainId, bytes calldata _path, uint64 _nonce) external {\n        require(msg.sender == ulnv2Radar, \"NonceContract: only ulnv2Radar\");\n        outboundNonce[_dstChainId][_path] = _nonce;\n    }\n}\n"
    },
    "contracts/oracle/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nabstract contract AccessControl {\n\n    mapping(address => bool) public allowlist;\n    mapping(address => bool) public denylist;\n    uint64 public allowlistSize;\n\n    event UpdateAllowlist(address _addr, bool _active);\n    event UpdateDenylist(address _addr, bool _active);\n\n    function _setAllowlist(address _addr, bool _allowed) internal {\n        require(allowlist[_addr] != _allowed, \"AccessControl: address already in that state\");\n        allowlist[_addr] = _allowed;\n        allowlistSize = _allowed ? allowlistSize + 1 : allowlistSize - 1;\n        emit UpdateAllowlist(_addr, _allowed);\n    }\n\n    function _setDenylist(address _addr, bool _denied) internal {\n        require(denylist[_addr] != _denied, \"AccessControl: address already in that state\");\n        denylist[_addr] = _denied;\n        emit UpdateDenylist(_addr, _denied);\n    }\n\n    /// 1) If one address is in the deny list, it is denied\n    /// 2) If the allow list is empty and not in the deny list, it is allowed\n    /// 3) If one address is in the allow list and not in the deny list, it is allowed\n    /// 4) If the allow list is not empty and the address is not in the allow list, it is denied\n    function checkPermission(address _address) public view returns (bool) {\n        if (denylist[_address]) {\n            return false;\n        } else if (allowlist[_address]) {\n            return true;\n        } else if (allowlistSize > 0) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n}\n"
    },
    "contracts/oracle/MultiSig.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nabstract contract MultiSig {\n    using SafeMath for uint;\n\n    mapping(address => bool) public signers;\n    uint64 public signerSize;\n    uint64 public quorum;\n\n    event UpdateSigner(address _signer, bool _active);\n    event UpdateQuorum(uint64 _quorum);\n\n    modifier onlySigner() {\n        require(signers[msg.sender], \"MultiSigOracle: caller must be signer\");\n        _;\n    }\n\n    constructor(address[] memory _signers, uint64 _quorum) {\n        require(_signers.length >= _quorum && _quorum > 0, \"MultiSig: signers too few\");\n\n        address lastSigner = address(0);\n        for (uint i = 0; i < _signers.length; i++) {\n            address signer = _signers[i];\n            require(signer > lastSigner, \"MultiSig: signers not sorted\"); // to ensure no duplicates\n            signers[signer] = true;\n            lastSigner = signer;\n        }\n        signerSize = uint64(_signers.length);\n        quorum = _quorum;\n    }\n\n    function _setSigner(address _signer, bool _active) internal {\n        require(signers[_signer] != _active, \"MultiSig: signer already in that state\");\n        signers[_signer] = _active;\n        signerSize = _active ? signerSize + 1 : signerSize - 1;\n        require(signerSize >= quorum, \"MultiSig: committee size < threshold\");\n        emit UpdateSigner(_signer, _active);\n    }\n\n    function _setQuorum(uint64 _quorum) internal {\n        require(_quorum <= signerSize && _quorum > 0, \"MultiSig: invalid quorum\");\n        quorum = _quorum;\n        emit UpdateQuorum(_quorum);\n    }\n\n    function verifySignatures(bytes32 _hash, bytes calldata _signatures) public view {\n        require(_signatures.length >= uint(quorum).mul(65), \"MultiSig: signatures too short\");\n\n        bytes32 messageDigest = _getEthSignedMessageHash(_hash);\n\n        address lastSigner = address(0); // There cannot be a signer with address 0.\n        for (uint i = 0; i < quorum; i++) {\n            (uint8 v, bytes32 r, bytes32 s) = _splitSignature(_signatures, i);\n            address currentSigner = ecrecover(messageDigest, v, r, s);\n\n            require(currentSigner > lastSigner, \"MultiSig: signatures must be in ascending order\"); // prevent duplicate signatures\n            require(signers[currentSigner], \"MultiSig: signature is not from a signer\");\n            lastSigner = currentSigner;\n        }\n    }\n\n    /// divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.\n    function _splitSignature(bytes memory _signatures, uint256 _pos)\n        internal\n        pure\n        returns (\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        )\n    {\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let signaturePos := mul(0x41, _pos)\n            r := mload(add(_signatures, add(signaturePos, 0x20)))\n            s := mload(add(_signatures, add(signaturePos, 0x40)))\n            // Here we are loading the last 32 bytes, including 31 bytes\n            // of 's'. There is no 'mload8' to do this.\n            //\n            // 'byte' is not working due to the Solidity parser, so lets\n            // use the second best option, 'and'\n            v := and(mload(add(_signatures, add(signaturePos, 0x41))), 0xff)\n        }\n    }\n\n    function _getEthSignedMessageHash(bytes32 _messageHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _messageHash));\n    }\n}\n"
    },
    "contracts/oracle/MultiSigOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/ILayerZeroOracleV2.sol\";\nimport \"../interfaces/ILayerZeroUltraLightNodeV2.sol\";\nimport \"../interfaces/ILayerZeroPriceFeed.sol\";\nimport \"./MultiSig.sol\";\nimport \"./AccessControl.sol\";\n\n// (1) can interact with multiple ulnv2-like contracts\n// (2) has an 'admin' role to manage the fee related non-security calls\n// (3) multi-sig can call arbitrary calldata (with expiration check, no msg replaying)\ncontract MultiSigOracle is MultiSig, AccessControl, ILayerZeroOracleV2 {\n    using SafeMath for uint;\n\n    mapping(address => bool) public ulns; // to call assignJob\n    mapping(address => bool) public admins; // sets pricing\n\n    mapping(uint16 => mapping(uint16 => uint64)) public dstGasLookup; // [_chainId][_outboundProofType]\n\n    ILayerZeroPriceFeed public priceFeed;\n    uint128 public multiplierBps = 12000; // 20%\n    mapping(bytes32 => bool) public usedHashes;\n\n    event UpdateAdmin(address _addr, bool _active);\n    event SetUln(address _addr, bool _active);\n    event AssignJob(uint16 _dstChainId, uint16 _outboundProofType, uint _outboundBlockConfirmations, address _userApplication, uint _fee);\n    event SetDstGas(uint16 _dstChainId, uint16 _outboundProofType, uint64 _gas);\n    event Execute(address _target, bytes32 _callDataHash, bool _success, bytes _data);\n    event UpdatePriceFeed(address _priceFeed);\n    event UpdatePriceMultiplierBps(uint128 _multiplierBps);\n\n    uint16 constant executeFixedBytes = 68; // encoded: funcSigHash + params -> 4  + (32 * 2)\n    uint16 constant signatureRawBytes = 65; // not encoded\n    // callData(updateHash) = 132 (4 + 32 * 4), padded to 32 = 160 and encoded as bytes with an 64 byte overhead = 224\n    uint16 constant updateHashBytes = 224;\n\n    modifier onlySelf() {\n        require(address(this) == msg.sender, \"MultiSigOracle: caller must be self\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(admins[msg.sender], \"MultiSigOracle: caller must be admin\");\n        _;\n    }\n\n    constructor(address _priceFeed, address[] memory _signers, uint64 _quorum, address[] memory _admins, address _uln) MultiSig(_signers, _quorum) {\n        priceFeed = ILayerZeroPriceFeed(_priceFeed);\n        ulns[_uln] = true;\n        for (uint i = 0; i < _admins.length; i++) {\n            admins[_admins[i]] = true;\n        }\n    }\n\n    function assignJob(uint16 _dstChainId, uint16 _outboundProofType, uint64 _outboundBlockConfirmation, address _userApplication) external override returns (uint fee) {\n        require(ulns[msg.sender], \"MultiSigOracle: caller must be uln\");\n        fee = getFee(_dstChainId, _outboundProofType, _outboundBlockConfirmation, _userApplication);\n        emit AssignJob(_dstChainId, _outboundProofType, _outboundBlockConfirmation, _userApplication, fee);\n    }\n\n    // signer can call this function to:\n    // 1. submit a block data to ULN\n    // 2. change configuration of this oracle\n    // 3. withdraw fee from ULN\n    function execute(address _target, bytes calldata _callData, uint _expiration, bytes calldata _signatures) external onlyAdmin {\n        require(ulns[_target] || _target == address(this), \"MultiSigOracle: target must be uln or self\");\n        require(_expiration > block.timestamp, \"MultiSigOracle: call data expired\");\n\n        // generate and validate hash\n        bytes32 hash = hashCallData(_target, _callData, _expiration);\n        require(!usedHashes[hash], \"MultiSigOracle: call data already executed\");\n        usedHashes[hash] = true; // prevent reentry and replay attack\n\n        // check signatures\n        verifySignatures(hash, _signatures);\n\n        // execute call data\n        (bool success, bytes memory rtnData) = _target.call(_callData);\n        emit Execute(_target, hash, success, rtnData);\n    }\n\n    // ---------------------- only self, by address(this).call() ----------------------\n    function setSigner(address _signer, bool _active) external onlySelf {\n        _setSigner(_signer, _active);\n    }\n\n    function setQuorum(uint64 _quorum) external onlySelf {\n        _setQuorum(_quorum);\n    }\n\n    function setAllowlist(address _userApplication, bool _allowed) external onlySelf {\n        _setAllowlist(_userApplication, _allowed);\n    }\n\n    function setDenylist(address _userApplication, bool _denied) external onlySelf {\n        _setDenylist(_userApplication, _denied);\n    }\n\n    function setUln(address _uln, bool _active) external onlySelf {\n        require(ulns[_uln] != _active, \"MultiSigOracle: uln already in that state\");\n        ulns[_uln] = _active;\n        emit SetUln(_uln, _active);\n    }\n\n    function setAdmin(address _admin, bool _active) external onlySelf {\n        require(admins[_admin] != _active, \"MultiSigOracle: admin already in that state\");\n        admins[_admin] = _active;\n        emit UpdateAdmin(_admin, _active);\n    }\n\n    // ---------------------- fee functions, only admin ----------------------\n    function setDstGas(uint16 _dstChainId, uint16 _proofType, uint64 _gas) external onlyAdmin {\n        dstGasLookup[_dstChainId][_proofType] = _gas;\n        emit SetDstGas(_dstChainId, _proofType, _gas);\n    }\n\n    function setPriceFeed(address _priceFeed) external onlyAdmin {\n        priceFeed = ILayerZeroPriceFeed(_priceFeed);\n        emit UpdatePriceFeed(_priceFeed);\n    }\n\n    function setPriceMultiplierBps(uint128 _multiplierBps) external onlyAdmin {\n        multiplierBps = _multiplierBps;\n        emit UpdatePriceMultiplierBps(_multiplierBps);\n    }\n\n    function withdrawFee(address payable _to, uint _amount) external view override onlyAdmin {\n        revert(\"MultiSigOracle: not implemented\");\n    }\n\n    function withdrawFeeFromUlnV2Like(address _uln, address payable _to, uint _amount) external onlyAdmin {\n        require(ulns[_uln], \"MultiSigOracle: _uln is not allowed\");\n        ILayerZeroUltraLightNodeV2(_uln).withdrawNative(_to, _amount);\n    }\n\n    // ---------------------- view functions ----------------------\n    function getFee(uint16 _dstChainId, uint16 _outboundProofType, uint64, address _userApplication) public view override returns (uint) {\n        require(checkPermission(_userApplication), \"MultiSigOracle: _userApplication is not allowed\");\n\n        uint dstGas = dstGasLookup[_dstChainId][_outboundProofType];\n\n        uint totalSignatureBytes = uint(quorum).mul(signatureRawBytes);\n        uint totalSignatureBytesPadded = totalSignatureBytes;\n        if (totalSignatureBytes.mod(32) != 0) {\n            totalSignatureBytesPadded = totalSignatureBytes.sub(totalSignatureBytes.mod(32)).add(32);\n        }\n        // getFee should charge on execute(updateHash)\n        // totalSignatureBytesPadded also has 64 overhead for bytes\n        uint callDataSize = uint(executeFixedBytes).add(updateHashBytes).add(totalSignatureBytesPadded.add(64));\n        uint16 dstChainId = _dstChainId; // stack too deep\n        (uint fee, ) = priceFeed.estimateFeeByChain(dstChainId, callDataSize, dstGas);\n        return fee.mul(multiplierBps).div(10000);\n    }\n\n    function hashCallData(address _target, bytes calldata _callData, uint _expiration) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_target, _expiration, _callData));\n    }\n}"
    },
    "contracts/PriceFeed.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"hardhat-deploy/solc_0.7/proxy/Proxied.sol\";\nimport \"./interfaces/ILayerZeroPriceFeed.sol\";\n\n\ncontract PriceFeed is ILayerZeroPriceFeed, OwnableUpgradeable, Proxied {\n    using SafeMath for uint;\n\n    uint128 public PRICE_RATIO_DENOMINATOR;\n\n    // sets pricing\n    mapping(address => bool) public priceUpdater;\n\n    // [_chainId]\n    mapping(uint16 => Price) public defaultModelPrice;\n    ArbitrumPriceExt public arbitrumPriceExt;\n\n    // ============================ Constructor ===================================\n\n    function initialize(address _priceUpdater) public proxied initializer {\n        __Ownable_init();\n        priceUpdater[_priceUpdater] = true;\n        PRICE_RATIO_DENOMINATOR = 1e10;\n    }\n\n    function onUpgrade() public proxied {\n        PRICE_RATIO_DENOMINATOR = 1e10;\n    }\n\n    // ============================ Modifier ======================================\n\n    // owner is always approved\n    modifier onlyPriceUpdater() {\n        if (owner() != msg.sender) {\n            require(priceUpdater[msg.sender], \"PriceFeed: not price updater\");\n        }\n        _;\n    }\n\n    // ============================ OnlyOwner =====================================\n\n    function setPriceUpdater(address _addr, bool _active) external onlyOwner {\n        priceUpdater[_addr] = _active;\n    }\n\n    function setPriceRatioDenominator(uint128 _denominator) external onlyOwner {\n        PRICE_RATIO_DENOMINATOR = _denominator;\n    }\n\n    // ============================ OnlyPriceUpdater =====================================\n\n    function setPrice(UpdatePrice[] calldata _price) external onlyPriceUpdater {\n        for (uint i = 0; i < _price.length; i++) {\n            UpdatePrice calldata _update = _price[i];\n            _setPrice(_update.chainId, _update.price);\n        }\n    }\n\n    function setPriceForArbitrum(UpdatePriceExt[] calldata _price) external onlyPriceUpdater {\n        for (uint i = 0; i < _price.length; i++) {\n            UpdatePriceExt calldata _update = _price[i];\n\n            _setPrice(_update.chainId, _update.price);\n\n            uint64 gasPerL2Tx = _update.extend.gasPerL2Tx;\n            uint32 gasPerL1CalldataByte = _update.extend.gasPerL1CallDataByte;\n\n            arbitrumPriceExt.gasPerL2Tx = gasPerL2Tx;\n            arbitrumPriceExt.gasPerL1CallDataByte = gasPerL1CalldataByte;\n        }\n    }\n\n    // ============================ Internal ==========================================\n    function _setPrice(uint16 chainId, Price memory _price) internal {\n        uint128 priceRatio = _price.priceRatio;\n        uint64 gasPriceInUnit = _price.gasPriceInUnit;\n        uint32 gasPerByte = _price.gasPerByte;\n        defaultModelPrice[chainId] = Price(priceRatio, gasPriceInUnit, gasPerByte);\n    }\n\n    function _getL1LookupId(uint16 _l2ChainId) internal pure returns (uint16) {\n        if (_l2ChainId == 110 || _l2ChainId == 111 || _l2ChainId == 151) {\n            return 101;\n        } else if (_l2ChainId == 10132 || _l2ChainId == 10143 || _l2ChainId == 10151) {\n            return 10121; // ethereum-goerli\n        } else if (_l2ChainId == 20132 || _l2ChainId == 20143 || _l2ChainId == 20151) {\n            return 20121; // ethereum-goerli\n        } else {\n            revert(\"PriceFeed: unknown l2 chain id\");\n        }\n    }\n\n    // ============================ View ==========================================\n\n    function getPrice(uint16 _dstChainId) external view override returns (Price memory price) {\n        price = defaultModelPrice[_dstChainId];\n    }\n\n    function getPriceRatioDenominator() external view override returns (uint128) {\n        return PRICE_RATIO_DENOMINATOR;\n    }\n\n    function estimateFeeByChain(uint16 _dstChainId, uint _callDataSize, uint _gas) external view override returns (uint fee, uint128 priceRatio) {\n        if (_dstChainId == 110 || _dstChainId == 10143 || _dstChainId == 20143) {\n            return estimateFeeWithArbitrumModel(_dstChainId, _callDataSize, _gas);\n        } else if (\n            _dstChainId == 111 || _dstChainId == 10132 || _dstChainId == 20132 ||\n            _dstChainId == 151 || _dstChainId == 10151 || _dstChainId == 20151\n        ) {\n            return estimateFeeWithOptimismModel(_dstChainId, _callDataSize, _gas);\n        } else {\n            return estimateFeeWithDefaultModel(_dstChainId, _callDataSize, _gas);\n        }\n    }\n\n    function estimateFeeWithDefaultModel(uint16 _dstChainId, uint _callDataSize, uint _gas) public view returns (uint fee, uint128 priceRatio) {\n        Price storage remotePrice = defaultModelPrice[_dstChainId];\n\n        // assuming the _gas includes (1) the 21,000 overhead and (2) not the calldata gas\n        uint gasForCallData = _callDataSize.mul(remotePrice.gasPerByte);\n        uint remoteFee = (gasForCallData.add(_gas)).mul(remotePrice.gasPriceInUnit);\n        return ((remoteFee.mul(remotePrice.priceRatio)).div(PRICE_RATIO_DENOMINATOR), remotePrice.priceRatio);\n    }\n\n    function estimateFeeWithOptimismModel(uint16 _dstChainId, uint _callDataSize, uint _gas) public view returns (uint fee, uint128 priceRatio) {\n        uint16 ethereumId = _getL1LookupId(_dstChainId);\n\n        // L1 fee\n        Price storage ethereumPrice = defaultModelPrice[ethereumId];\n        uint gasForL1CallData = _callDataSize.mul(ethereumPrice.gasPerByte).add(3188); // 2100 + 68 * 16\n        uint l1Fee = gasForL1CallData.mul(ethereumPrice.gasPriceInUnit);\n\n        // L2 fee\n        Price storage optimismPrice = defaultModelPrice[_dstChainId];\n        uint gasForL2CallData = _callDataSize.mul(optimismPrice.gasPerByte);\n        uint l2Fee = (gasForL2CallData.add(_gas)).mul(optimismPrice.gasPriceInUnit);\n\n        uint l1FeeInSrcPrice = l1Fee.mul(ethereumPrice.priceRatio).div(PRICE_RATIO_DENOMINATOR);\n        uint l2FeeInSrcPrice = l2Fee.mul(optimismPrice.priceRatio).div(PRICE_RATIO_DENOMINATOR);\n        uint gasFee = l1FeeInSrcPrice.add(l2FeeInSrcPrice);\n        return (gasFee, optimismPrice.priceRatio);\n    }\n\n    function estimateFeeWithArbitrumModel(uint16 _dstChainId, uint _callDataSize, uint _gas) public view returns (uint fee, uint128 priceRatio) {\n        Price storage arbitrumPrice = defaultModelPrice[_dstChainId];\n\n        // L1 fee\n        uint gasForL1CallData = _callDataSize.mul(arbitrumPriceExt.gasPerL1CallDataByte);\n        // L2 Fee\n        uint gasForL2CallData = _callDataSize.mul(arbitrumPrice.gasPerByte);\n        uint gasFee = (_gas.add(arbitrumPriceExt.gasPerL2Tx).add(gasForL1CallData).add(gasForL2CallData)).mul(arbitrumPrice.gasPriceInUnit);\n\n        return ((gasFee.mul(arbitrumPrice.priceRatio)).div(PRICE_RATIO_DENOMINATOR), arbitrumPrice.priceRatio);\n    }\n}\n"
    },
    "contracts/proof/FPValidator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./utility/LayerZeroPacket.sol\";\nimport \"../interfaces/ILayerZeroValidationLibrary.sol\";\nimport \"../interfaces/IValidationLibraryHelperV2.sol\";\n\ninterface IStargate {\n    // Stargate objects for abi encoding / decoding\n    struct SwapObj {\n        uint amount;\n        uint eqFee;\n        uint eqReward;\n        uint lpFee;\n        uint protocolFee;\n        uint lkbRemove;\n    }\n\n    struct CreditObj {\n        uint credits;\n        uint idealBalance;\n    }\n}\n\ncontract FPValidator is ILayerZeroValidationLibrary, IValidationLibraryHelperV2 {\n    uint8 public proofType = 2;\n    uint8 public utilsVersion = 1;\n\n    address public immutable stargateBridgeAddress;\n    address public immutable stargateTokenAddress;\n\n    constructor(address _stargateBridgeAddress, address _stargateTokenAddress) {\n        stargateBridgeAddress = _stargateBridgeAddress;\n        stargateTokenAddress = _stargateTokenAddress;\n    }\n\n    function validateProof(bytes32 _packetHash, bytes calldata _transactionProof, uint _remoteAddressSize) external view override returns (LayerZeroPacket.Packet memory packet) {\n        require(_remoteAddressSize > 0, \"ProofLib: invalid address size\");\n        // _transactionProof = srcUlnAddress (32 bytes) + lzPacket\n        require(_transactionProof.length > 32 && keccak256(_transactionProof) == _packetHash, \"ProofLib: invalid transaction proof\");\n\n        bytes memory ulnAddressBytes = bytes(_transactionProof[0:32]);\n        bytes32 ulnAddress;\n        assembly {\n            ulnAddress := mload(add(ulnAddressBytes, 32))\n        }\n        packet = LayerZeroPacket.getPacketV3(_transactionProof[32:], _remoteAddressSize, ulnAddress);\n\n        if (packet.dstAddress == stargateBridgeAddress) packet.payload = _secureStgPayload(packet.payload);\n        if (packet.dstAddress == stargateTokenAddress) packet.payload = _secureStgTokenPayload(packet.payload);\n\n        return packet;\n    }\n\n    function _secureStgTokenPayload(bytes memory _payload) internal pure returns (bytes memory) {\n        (bytes memory toAddressBytes, uint qty) = abi.decode(_payload, (bytes, uint));\n\n        address toAddress = address(0);\n        if (toAddressBytes.length > 0) {\n            assembly {\n                toAddress := mload(add(toAddressBytes, 20))\n            }\n        }\n\n        if (toAddress == address(0)) {\n            address deadAddress = address(0x000000000000000000000000000000000000dEaD);\n            bytes memory newToAddressBytes = abi.encodePacked(deadAddress);\n            return abi.encode(newToAddressBytes, qty);\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function _secureStgPayload(bytes memory _payload) internal view returns (bytes memory) {\n        // functionType is uint8 even though the encoding will take up the side of uint256\n        uint8 functionType;\n        assembly {\n            functionType := mload(add(_payload, 32))\n        }\n\n        // TYPE_SWAP_REMOTE == 1 && only if the payload has a payload\n        // only swapRemote inside of stargate can call sgReceive on an user supplied to address\n        // thus we do not care about the other type functions even if the toAddress is overly long.\n        if (functionType == 1) {\n            // decode the _payload with its types\n            (, uint srcPoolId, uint dstPoolId, uint dstGasForCall, IStargate.CreditObj memory c, IStargate.SwapObj memory s, bytes memory toAddressBytes, bytes memory contractCallPayload) = abi.decode(_payload, (uint8, uint, uint, uint, IStargate.CreditObj, IStargate.SwapObj, bytes, bytes));\n\n            // if contractCallPayload.length > 0 need to check if the to address is a contract or not\n            if (contractCallPayload.length > 0) {\n                // otherwise, need to check if the payload can be delivered to the toAddress\n                address toAddress = address(0);\n                if (toAddressBytes.length > 0) {\n                    assembly {\n                        toAddress := mload(add(toAddressBytes, 20))\n                    }\n                }\n\n                // check if the toAddress is a contract. We are not concerned about addresses that pretend to be wallets. because worst case we just delete their payload if being malicious\n                // we can guarantee that if a size > 0, then the contract is definitely a contract address in this context\n                uint size;\n                assembly {\n                    size := extcodesize(toAddress)\n                }\n\n                if (size == 0) {\n                    // size == 0 indicates its not a contract, payload wont be delivered\n                    // secure the _payload to make sure funds can be delivered to the toAddress\n                    bytes memory newToAddressBytes = abi.encodePacked(toAddress);\n                    bytes memory securePayload = abi.encode(functionType, srcPoolId, dstPoolId, dstGasForCall, c, s, newToAddressBytes, bytes(\"\"));\n                    return securePayload;\n                }\n            }\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function secureStgTokenPayload(bytes memory _payload) external pure returns (bytes memory) {\n        return _secureStgTokenPayload(_payload);\n    }\n\n    function secureStgPayload(bytes memory _payload) external view returns (bytes memory) {\n        return _secureStgPayload(_payload);\n    }\n\n    function getUtilsVersion() external view override returns (uint8) {\n        return utilsVersion;\n    }\n\n    function getProofType() external view override returns (uint8) {\n        return proofType;\n    }\n\n    function getVerifyLog(bytes32, uint[] calldata, uint, bytes[] calldata proof) external pure override returns (ULNLog memory log) {}\n\n    function getPacket(bytes memory data, uint sizeOfSrcAddress, bytes32 ulnAddress) external pure override returns (LayerZeroPacket.Packet memory) {\n        return LayerZeroPacket.getPacketV3(data, sizeOfSrcAddress, ulnAddress);\n    }\n}\n"
    },
    "contracts/proof/MPTValidator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./utility/LayerZeroPacket.sol\";\nimport \"./utility/Buffer.sol\";\nimport \"../interfaces/ILayerZeroValidationLibrary.sol\";\nimport \"./utility/UltraLightNodeEVMDecoder.sol\";\n\ncontract MPTValidator is ILayerZeroValidationLibrary {\n    using RLPDecode for RLPDecode.RLPItem;\n    using RLPDecode for RLPDecode.Iterator;\n    using Buffer for Buffer.buffer;\n    using SafeMath for uint;\n\n    bytes32 public constant PACKET_SIGNATURE = 0xe8d23d927749ec8e512eb885679c2977d57068839d8cca1a85685dbbea0648f6;\n\n    struct ULNLog {\n        bytes32 contractAddress;\n        bytes32 topicZeroSig;\n        bytes data;\n    }\n\n    function validateProof(bytes32 _receiptsRoot, bytes calldata _transactionProof, uint _remoteAddressSize) external pure override returns (LayerZeroPacket.Packet memory packet) {\n        (uint16 remoteChainId, bytes[] memory proof, uint[] memory pointers, uint receiptIndex, uint logIndex) = abi.decode(_transactionProof, (uint16, bytes[], uint[], uint, uint));\n\n        ULNLog memory log = _getVerifiedLog(_receiptsRoot, receiptIndex, logIndex, proof, pointers);\n        require(log.topicZeroSig == PACKET_SIGNATURE, \"LayerZero: packet not recognized\"); //data\n\n        return getPacket(log.data, remoteChainId, _remoteAddressSize, log.contractAddress);\n    }\n\n    function _getVerifiedLog(bytes32 hashRoot, uint receiptSlotIndex, uint logIndex, bytes[] memory proof, uint[] memory pointers) internal pure returns (ULNLog memory) {\n        // walk and assert the hash links of MPT\n        uint pointer;\n        bytes memory proofBytes;\n        for (uint i = 0; i < proof.length; i++) {\n            proofBytes = proof[i];\n            require(hashRoot == keccak256(proofBytes), \"LayerZero: invalid hashlink\");\n            if (i < pointers.length) {\n                pointer = pointers[i];\n                assembly {\n                    hashRoot := mload(add(add(proofBytes, pointer), 32))\n                }\n            }\n        }\n\n        // build the iterator for the proofBytes\n        RLPDecode.Iterator memory it = RLPDecode.toRlpItem(proofBytes).iterator();\n\n        // get the receipt item from either branch or leaf node\n        RLPDecode.RLPItem memory receiptItem = it.item.getItemByIndex(receiptSlotIndex);\n        // it = targetReceiptIter\n        it = receiptItem.typeOffset().iterator();\n        it.next(); // status\n        it.next(); // gasUsed\n        it.next(); // logBloom\n\n        // it = targetLogIter\n        it = it.next().getItemByIndex(logIndex).iterator();\n        ULNLog memory log;\n        log.contractAddress = bytes32(it.next().toUint());\n        log.topicZeroSig = bytes32(it.next().getItemByIndex(0).toUint());\n        log.data = it.next().toBytes();\n\n        return log;\n    }\n\n    // profiling and test\n    function getVerifyLog(bytes32 hashRoot, uint receiptSlotIndex, uint logIndex, bytes[] memory proof, uint[] memory pointers) external pure returns (ULNLog memory) {\n        return _getVerifiedLog(hashRoot, receiptSlotIndex, logIndex, proof, pointers);\n    }\n\n    function getPacket(bytes memory data, uint16 srcChain, uint sizeOfSrcAddress, bytes32 ulnAddress) internal pure returns (LayerZeroPacket.Packet memory) {\n        uint16 dstChainId;\n        address dstAddress;\n        uint size;\n        uint64 nonce;\n\n        // The log consists of the destination chain id and then a bytes payload\n        //      0--------------------------------------------31\n        // 0   |  destination chain id\n        // 32  |  defines bytes array\n        // 64  |\n        // 96  |  bytes array size\n        // 128 |  payload\n        assembly {\n            dstChainId := mload(add(data, 32))\n            size := mload(add(data, 96)) /// size of the byte array\n            nonce := mload(add(data, 104)) // offset to convert to uint64  128  is index -24\n            dstAddress := mload(add(data, sub(add(128, sizeOfSrcAddress), 4))) // offset to convert to address 12 -8\n        }\n\n        Buffer.buffer memory srcAddressBuffer;\n        srcAddressBuffer.init(sizeOfSrcAddress);\n        srcAddressBuffer.writeRawBytes(0, data, 136, sizeOfSrcAddress); // 128 + 8\n\n        uint payloadSize = size.sub(20).sub(sizeOfSrcAddress);\n        Buffer.buffer memory payloadBuffer;\n        payloadBuffer.init(payloadSize);\n        payloadBuffer.writeRawBytes(0, data, sizeOfSrcAddress.add(156), payloadSize); // 148 + 8\n        return LayerZeroPacket.Packet(srcChain, dstChainId, nonce, address(dstAddress), srcAddressBuffer.buf, ulnAddress, payloadBuffer.buf);\n    }\n}\n"
    },
    "contracts/proof/MPTValidator01.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./utility/LayerZeroPacket.sol\";\nimport \"./utility/UltraLightNodeEVMDecoder.sol\";\nimport \"../interfaces/IValidationLibraryHelperV2.sol\";\nimport \"../interfaces/ILayerZeroValidationLibrary.sol\";\n\ninterface IStargate {\n    // Stargate objects for abi encoding / decoding\n    struct SwapObj {\n        uint amount;\n        uint eqFee;\n        uint eqReward;\n        uint lpFee;\n        uint protocolFee;\n        uint lkbRemove;\n    }\n\n    struct CreditObj {\n        uint credits;\n        uint idealBalance;\n    }\n}\n\ncontract MPTValidator01 is ILayerZeroValidationLibrary, IValidationLibraryHelperV2 {\n    using RLPDecode for RLPDecode.RLPItem;\n    using RLPDecode for RLPDecode.Iterator;\n\n    uint8 public proofType = 1;\n    uint8 public utilsVersion = 4;\n    bytes32 public constant PACKET_SIGNATURE = 0xe9bded5f24a4168e4f3bf44e00298c993b22376aad8c58c7dda9718a54cbea82;\n\n    address public immutable stargateBridgeAddress;\n    address public immutable stargateTokenAddress;\n\n    constructor(address _stargateBridgeAddress, address _stargateTokenAddress) {\n        stargateBridgeAddress = _stargateBridgeAddress;\n        stargateTokenAddress = _stargateTokenAddress;\n    }\n\n    function validateProof(bytes32 _receiptsRoot, bytes calldata _transactionProof, uint _remoteAddressSize) external view override returns (LayerZeroPacket.Packet memory packet) {\n        require(_remoteAddressSize > 0, \"ProofLib: invalid address size\");\n        (bytes[] memory proof, uint[] memory receiptSlotIndex, uint logIndex) = abi.decode(_transactionProof, (bytes[], uint[], uint));\n\n        ULNLog memory log = _getVerifiedLog(_receiptsRoot, receiptSlotIndex, logIndex, proof);\n        require(log.topicZeroSig == PACKET_SIGNATURE, \"ProofLib: packet not recognized\"); //data\n\n        packet = LayerZeroPacket.getPacketV2(log.data, _remoteAddressSize, log.contractAddress);\n\n        if (packet.dstAddress == stargateBridgeAddress) packet.payload = _secureStgPayload(packet.payload);\n\n        if (packet.dstAddress == stargateTokenAddress) packet.payload = _secureStgTokenPayload(packet.payload);\n\n        return packet;\n    }\n\n    function _secureStgTokenPayload(bytes memory _payload) internal pure returns (bytes memory) {\n        (bytes memory toAddressBytes, uint qty) = abi.decode(_payload, (bytes, uint));\n\n        address toAddress = address(0);\n        if (toAddressBytes.length > 0) {\n            assembly {\n                toAddress := mload(add(toAddressBytes, 20))\n            }\n        }\n\n        if (toAddress == address(0)) {\n            address deadAddress = address(0x000000000000000000000000000000000000dEaD);\n            bytes memory newToAddressBytes = abi.encodePacked(deadAddress);\n            return abi.encode(newToAddressBytes, qty);\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function _secureStgPayload(bytes memory _payload) internal view returns (bytes memory) {\n        // functionType is uint8 even though the encoding will take up the side of uint256\n        uint8 functionType;\n        assembly {\n            functionType := mload(add(_payload, 32))\n        }\n\n        // TYPE_SWAP_REMOTE == 1 && only if the payload has a payload\n        // only swapRemote inside of stargate can call sgReceive on an user supplied to address\n        // thus we do not care about the other type functions even if the toAddress is overly long.\n        if (functionType == 1) {\n            // decode the _payload with its types\n            (, uint srcPoolId, uint dstPoolId, uint dstGasForCall, IStargate.CreditObj memory c, IStargate.SwapObj memory s, bytes memory toAddressBytes, bytes memory contractCallPayload) = abi.decode(_payload, (uint8, uint, uint, uint, IStargate.CreditObj, IStargate.SwapObj, bytes, bytes));\n\n            // if contractCallPayload.length > 0 need to check if the to address is a contract or not\n            if (contractCallPayload.length > 0) {\n                // otherwise, need to check if the payload can be delivered to the toAddress\n                address toAddress = address(0);\n                if (toAddressBytes.length > 0) {\n                    assembly {\n                        toAddress := mload(add(toAddressBytes, 20))\n                    }\n                }\n\n                // check if the toAddress is a contract. We are not concerned about addresses that pretend to be wallets. because worst case we just delete their payload if being malicious\n                // we can guarantee that if a size > 0, then the contract is definitely a contract address in this context\n                uint size;\n                assembly {\n                    size := extcodesize(toAddress)\n                }\n\n                if (size == 0) {\n                    // size == 0 indicates its not a contract, payload wont be delivered\n                    // secure the _payload to make sure funds can be delivered to the toAddress\n                    bytes memory newToAddressBytes = abi.encodePacked(toAddress);\n                    bytes memory securePayload = abi.encode(functionType, srcPoolId, dstPoolId, dstGasForCall, c, s, newToAddressBytes, bytes(\"\"));\n                    return securePayload;\n                }\n            }\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function secureStgTokenPayload(bytes memory _payload) external pure returns (bytes memory) {\n        return _secureStgTokenPayload(_payload);\n    }\n\n    function secureStgPayload(bytes memory _payload) external view returns (bytes memory) {\n        return _secureStgPayload(_payload);\n    }\n\n    function _getVerifiedLog(bytes32 hashRoot, uint[] memory paths, uint logIndex, bytes[] memory proof) internal pure returns (ULNLog memory) {\n        require(paths.length == proof.length, \"ProofLib: invalid proof size\");\n        require(proof.length > 0, \"ProofLib: proof size must > 0\");\n        RLPDecode.RLPItem memory item;\n        bytes memory proofBytes;\n\n        for (uint i = 0; i < proof.length; i++) {\n            proofBytes = proof[i];\n            require(hashRoot == keccak256(proofBytes), \"ProofLib: invalid hashlink\");\n            item = RLPDecode.toRlpItem(proofBytes).safeGetItemByIndex(paths[i]);\n            if (i < proof.length - 1) hashRoot = bytes32(item.toUint());\n        }\n\n        // burning status + gasUsed + logBloom\n        RLPDecode.RLPItem memory logItem = item.typeOffset().safeGetItemByIndex(3);\n        RLPDecode.Iterator memory it = logItem.safeGetItemByIndex(logIndex).iterator();\n        ULNLog memory log;\n        log.contractAddress = bytes32(it.next().toUint());\n        log.topicZeroSig = bytes32(it.next().safeGetItemByIndex(0).toUint());\n        log.data = it.next().toBytes();\n\n        return log;\n    }\n\n    function getUtilsVersion() external view override returns (uint8) {\n        return utilsVersion;\n    }\n\n    function getProofType() external view override returns (uint8) {\n        return proofType;\n    }\n\n    function getVerifyLog(bytes32 hashRoot, uint[] memory receiptSlotIndex, uint logIndex, bytes[] memory proof) external pure override returns (ULNLog memory) {\n        return _getVerifiedLog(hashRoot, receiptSlotIndex, logIndex, proof);\n    }\n\n    function getPacket(bytes memory data, uint sizeOfSrcAddress, bytes32 ulnAddress) external pure override returns (LayerZeroPacket.Packet memory) {\n        return LayerZeroPacket.getPacketV2(data, sizeOfSrcAddress, ulnAddress);\n    }\n}\n"
    },
    "contracts/proof/MPTValidatorStgV3.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./utility/LayerZeroPacket.sol\";\nimport \"./utility/Buffer.sol\";\nimport \"../interfaces/ILayerZeroValidationLibrary.sol\";\nimport \"./utility/UltraLightNodeEVMDecoder.sol\";\n\ncontract MPTValidatorStgV3 is ILayerZeroValidationLibrary {\n    using RLPDecode for RLPDecode.RLPItem;\n    using RLPDecode for RLPDecode.Iterator;\n    using Buffer for Buffer.buffer;\n    using SafeMath for uint;\n\n    bytes32 public constant PACKET_SIGNATURE = 0xe8d23d927749ec8e512eb885679c2977d57068839d8cca1a85685dbbea0648f6;\n\n    address public immutable stargateBridgeAddress;\n    address public immutable stgTokenAddress;\n    uint16 public immutable localChainId;\n\n    constructor(address _stargateBridgeAddress, address _stgTokenAddress, uint16 _localChainId) {\n        stargateBridgeAddress = _stargateBridgeAddress;\n        stgTokenAddress = _stgTokenAddress;\n        localChainId = _localChainId;\n    }\n\n    struct ULNLog {\n        bytes32 contractAddress;\n        bytes32 topicZeroSig;\n        bytes data;\n    }\n\n    // Stargate objects for abi encoding / decoding\n    struct SwapObj {\n        uint amount;\n        uint eqFee;\n        uint eqReward;\n        uint lpFee;\n        uint protocolFee;\n        uint lkbRemove;\n    }\n\n    struct CreditObj {\n        uint credits;\n        uint idealBalance;\n    }\n\n    function validateProof(bytes32 _receiptsRoot, bytes calldata _transactionProof, uint _remoteAddressSize) external view override returns (LayerZeroPacket.Packet memory) {\n        (uint16 remoteChainId, bytes[] memory proof, uint[] memory receiptSlotIndex, uint logIndex) = abi.decode(_transactionProof, (uint16, bytes[], uint[], uint));\n\n        ULNLog memory log = _getVerifiedLog(_receiptsRoot, receiptSlotIndex, logIndex, proof);\n        require(log.topicZeroSig == PACKET_SIGNATURE, \"ProofLib: packet not recognized\"); //data\n\n        LayerZeroPacket.Packet memory packet = _getPacket(log.data, remoteChainId, _remoteAddressSize, log.contractAddress);\n\n        require(packet.dstChainId == localChainId, \"ProofLib: invalid destination chain ID\");\n\n        if (packet.dstAddress == stargateBridgeAddress) packet.payload = _secureStgPayload(packet.payload);\n\n        if (packet.dstAddress == stgTokenAddress) packet.payload = _secureStgTokenPayload(packet.payload);\n\n        return packet;\n    }\n\n    function _secureStgTokenPayload(bytes memory _payload) internal pure returns (bytes memory) {\n        (bytes memory toAddressBytes, uint qty) = abi.decode(_payload, (bytes, uint));\n\n        address toAddress = address(0);\n        if (toAddressBytes.length > 0) {\n            assembly {\n                toAddress := mload(add(toAddressBytes, 20))\n            }\n        }\n\n        if (toAddress == address(0)) {\n            address deadAddress = address(0x000000000000000000000000000000000000dEaD);\n            bytes memory newToAddressBytes = abi.encodePacked(deadAddress);\n            return abi.encode(newToAddressBytes, qty);\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function _secureStgPayload(bytes memory _payload) internal view returns (bytes memory) {\n        // functionType is uint8 even though the encoding will take up the side of uint256\n        uint8 functionType;\n        assembly {\n            functionType := mload(add(_payload, 32))\n        }\n\n        // TYPE_SWAP_REMOTE == 1 && only if the payload has a payload\n        // only swapRemote inside of stargate can call sgReceive on an user supplied to address\n        // thus we do not care about the other type functions even if the toAddress is overly long.\n        if (functionType == 1) {\n            // decode the _payload with its types\n            (, uint srcPoolId, uint dstPoolId, uint dstGasForCall, CreditObj memory c, SwapObj memory s, bytes memory toAddressBytes, bytes memory contractCallPayload) = abi.decode(_payload, (uint8, uint, uint, uint, CreditObj, SwapObj, bytes, bytes));\n\n            // if contractCallPayload.length > 0 need to check if the to address is a contract or not\n            if (contractCallPayload.length > 0) {\n                // otherwise, need to check if the payload can be delivered to the toAddress\n                address toAddress = address(0);\n                if (toAddressBytes.length > 0) {\n                    assembly {\n                        toAddress := mload(add(toAddressBytes, 20))\n                    }\n                }\n\n                // check if the toAddress is a contract. We are not concerned about addresses that pretend to be wallets. because worst case we just delete their payload if being malicious\n                // we can guarantee that if a size > 0, then the contract is definitely a contract address in this context\n                uint size;\n                assembly {\n                    size := extcodesize(toAddress)\n                }\n\n                if (size == 0) {\n                    // size == 0 indicates its not a contract, payload wont be delivered\n                    // secure the _payload to make sure funds can be delivered to the toAddress\n                    bytes memory newToAddressBytes = abi.encodePacked(toAddress);\n                    bytes memory securePayload = abi.encode(functionType, srcPoolId, dstPoolId, dstGasForCall, c, s, newToAddressBytes, bytes(\"\"));\n                    return securePayload;\n                }\n            }\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function secureStgTokenPayload(bytes memory _payload) external pure returns (bytes memory) {\n        return _secureStgTokenPayload(_payload);\n    }\n\n    function secureStgPayload(bytes memory _payload) external view returns (bytes memory) {\n        return _secureStgPayload(_payload);\n    }\n\n    function _getVerifiedLog(bytes32 hashRoot, uint[] memory paths, uint logIndex, bytes[] memory proof) internal pure returns (ULNLog memory) {\n        require(paths.length == proof.length, \"ProofLib: invalid proof size\");\n\n        RLPDecode.RLPItem memory item;\n        bytes memory proofBytes;\n\n        for (uint i = 0; i < proof.length; i++) {\n            proofBytes = proof[i];\n            require(hashRoot == keccak256(proofBytes), \"ProofLib: invalid hashlink\");\n            item = RLPDecode.toRlpItem(proofBytes).safeGetItemByIndex(paths[i]);\n            if (i < proof.length - 1) hashRoot = bytes32(item.toUint());\n        }\n\n        // burning status + gasUsed + logBloom\n        RLPDecode.RLPItem memory logItem = item.typeOffset().safeGetItemByIndex(3);\n        RLPDecode.Iterator memory it = logItem.safeGetItemByIndex(logIndex).iterator();\n        ULNLog memory log;\n        log.contractAddress = bytes32(it.next().toUint());\n        log.topicZeroSig = bytes32(it.next().getItemByIndex(0).toUint());\n        log.data = it.next().toBytes();\n\n        return log;\n    }\n\n    // profiling and test\n    function getVerifyLog(bytes32 hashRoot, uint[] memory receiptSlotIndex, uint logIndex, bytes[] memory proof) external pure returns (ULNLog memory) {\n        return _getVerifiedLog(hashRoot, receiptSlotIndex, logIndex, proof);\n    }\n\n    function getPacket(bytes memory data, uint16 srcChain, uint sizeOfSrcAddress, bytes32 ulnAddress) external pure returns (LayerZeroPacket.Packet memory) {\n        return _getPacket(data, srcChain, sizeOfSrcAddress, ulnAddress);\n    }\n\n    function _getPacket(bytes memory data, uint16 srcChain, uint sizeOfSrcAddress, bytes32 ulnAddress) internal pure returns (LayerZeroPacket.Packet memory) {\n        uint16 dstChainId;\n        address dstAddress;\n        uint size;\n        uint64 nonce;\n\n        // The log consists of the destination chain id and then a bytes payload\n        //      0--------------------------------------------31\n        // 0   |  destination chain id\n        // 32  |  defines bytes array\n        // 64  |\n        // 96  |  bytes array size\n        // 128 |  payload\n        assembly {\n            dstChainId := mload(add(data, 32))\n            size := mload(add(data, 96)) /// size of the byte array\n            nonce := mload(add(data, 104)) // offset to convert to uint64  128  is index -24\n            dstAddress := mload(add(data, sub(add(128, sizeOfSrcAddress), 4))) // offset to convert to address 12 -8\n        }\n\n        Buffer.buffer memory srcAddressBuffer;\n        srcAddressBuffer.init(sizeOfSrcAddress);\n        srcAddressBuffer.writeRawBytes(0, data, 136, sizeOfSrcAddress); // 128 + 8\n\n        uint payloadSize = size.sub(20).sub(sizeOfSrcAddress);\n        Buffer.buffer memory payloadBuffer;\n        payloadBuffer.init(payloadSize);\n        payloadBuffer.writeRawBytes(0, data, sizeOfSrcAddress.add(156), payloadSize); // 148 + 8\n        return LayerZeroPacket.Packet(srcChain, dstChainId, nonce, dstAddress, srcAddressBuffer.buf, ulnAddress, payloadBuffer.buf);\n    }\n}\n"
    },
    "contracts/proof/MPTValidatorV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./utility/LayerZeroPacket.sol\";\nimport \"./utility/Buffer.sol\";\nimport \"../interfaces/ILayerZeroValidationLibrary.sol\";\nimport \"./utility/UltraLightNodeEVMDecoder.sol\";\n\ncontract MPTValidatorV2 is ILayerZeroValidationLibrary {\n    using RLPDecode for RLPDecode.RLPItem;\n    using RLPDecode for RLPDecode.Iterator;\n    using Buffer for Buffer.buffer;\n    using SafeMath for uint;\n\n    bytes32 public constant PACKET_SIGNATURE = 0xe8d23d927749ec8e512eb885679c2977d57068839d8cca1a85685dbbea0648f6;\n\n    struct ULNLog {\n        bytes32 contractAddress;\n        bytes32 topicZeroSig;\n        bytes data;\n    }\n\n    function validateProof(bytes32 _receiptsRoot, bytes calldata _transactionProof, uint _remoteAddressSize) external pure override returns (LayerZeroPacket.Packet memory packet) {\n        (uint16 remoteChainId, bytes[] memory proof, uint[] memory receiptSlotIndex, uint logIndex) = abi.decode(_transactionProof, (uint16, bytes[], uint[], uint));\n\n        ULNLog memory log = _getVerifiedLog(_receiptsRoot, receiptSlotIndex, logIndex, proof);\n        require(log.topicZeroSig == PACKET_SIGNATURE, \"ProofLib: packet not recognized\"); //data\n\n        return _getPacket(log.data, remoteChainId, _remoteAddressSize, log.contractAddress);\n    }\n\n    function _getVerifiedLog(bytes32 hashRoot, uint[] memory paths, uint logIndex, bytes[] memory proof) internal pure returns (ULNLog memory) {\n        require(paths.length == proof.length, \"ProofLib: invalid proof size\");\n\n        RLPDecode.RLPItem memory item;\n        bytes memory proofBytes;\n\n        for (uint i = 0; i < proof.length; i++) {\n            proofBytes = proof[i];\n            require(hashRoot == keccak256(proofBytes), \"ProofLib: invalid hashlink\");\n            item = RLPDecode.toRlpItem(proofBytes).safeGetItemByIndex(paths[i]);\n            if (i < proof.length - 1) hashRoot = bytes32(item.toUint());\n        }\n\n        // burning status + gasUsed + logBloom\n        RLPDecode.RLPItem memory logItem = item.typeOffset().safeGetItemByIndex(3);\n        RLPDecode.Iterator memory it = logItem.safeGetItemByIndex(logIndex).iterator();\n        ULNLog memory log;\n        log.contractAddress = bytes32(it.next().toUint());\n        log.topicZeroSig = bytes32(it.next().getItemByIndex(0).toUint());\n        log.data = it.next().toBytes();\n\n        return log;\n    }\n\n    // profiling and test\n    function getVerifyLog(bytes32 hashRoot, uint[] memory receiptSlotIndex, uint logIndex, bytes[] memory proof) external pure returns (ULNLog memory) {\n        return _getVerifiedLog(hashRoot, receiptSlotIndex, logIndex, proof);\n    }\n\n    function getPacket(bytes memory data, uint16 srcChain, uint sizeOfSrcAddress, bytes32 ulnAddress) external pure returns (LayerZeroPacket.Packet memory) {\n        return _getPacket(data, srcChain, sizeOfSrcAddress, ulnAddress);\n    }\n\n    function _getPacket(bytes memory data, uint16 srcChain, uint sizeOfSrcAddress, bytes32 ulnAddress) internal pure returns (LayerZeroPacket.Packet memory) {\n        uint16 dstChainId;\n        address dstAddress;\n        uint size;\n        uint64 nonce;\n\n        // The log consists of the destination chain id and then a bytes payload\n        //      0--------------------------------------------31\n        // 0   |  destination chain id\n        // 32  |  defines bytes array\n        // 64  |\n        // 96  |  bytes array size\n        // 128 |  payload\n        assembly {\n            dstChainId := mload(add(data, 32))\n            size := mload(add(data, 96)) /// size of the byte array\n            nonce := mload(add(data, 104)) // offset to convert to uint64  128  is index -24\n            dstAddress := mload(add(data, sub(add(128, sizeOfSrcAddress), 4))) // offset to convert to address 12 -8\n        }\n\n        Buffer.buffer memory srcAddressBuffer;\n        srcAddressBuffer.init(sizeOfSrcAddress);\n        srcAddressBuffer.writeRawBytes(0, data, 136, sizeOfSrcAddress); // 128 + 8\n\n        uint payloadSize = size.sub(20).sub(sizeOfSrcAddress);\n        Buffer.buffer memory payloadBuffer;\n        payloadBuffer.init(payloadSize);\n        payloadBuffer.writeRawBytes(0, data, sizeOfSrcAddress.add(156), payloadSize); // 148 + 8\n        return LayerZeroPacket.Packet(srcChain, dstChainId, nonce, dstAddress, srcAddressBuffer.buf, ulnAddress, payloadBuffer.buf);\n    }\n}\n"
    },
    "contracts/proof/MPTValidatorV4.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/IValidationLibraryHelper.sol\";\nimport \"./utility/LayerZeroPacket.sol\";\nimport \"./utility/UltraLightNodeEVMDecoder.sol\";\n\ninterface IUltraLightNode {\n    struct BlockData {\n        uint confirmations;\n        bytes32 data;\n    }\n\n    struct ApplicationConfiguration {\n        uint16 inboundProofLibraryVersion;\n        uint64 inboundBlockConfirmations;\n        address relayer;\n        uint16 outboundProofType;\n        uint64 outboundBlockConfirmations;\n        address oracle;\n    }\n\n    function getAppConfig(uint16 _chainId, address userApplicationAddress) external view returns (ApplicationConfiguration memory);\n\n    function getBlockHeaderData(address _oracle, uint16 _remoteChainId, bytes32 _lookupHash) external view returns (BlockData memory blockData);\n}\n\ninterface IStargate {\n    // Stargate objects for abi encoding / decoding\n    struct SwapObj {\n        uint amount;\n        uint eqFee;\n        uint eqReward;\n        uint lpFee;\n        uint protocolFee;\n        uint lkbRemove;\n    }\n\n    struct CreditObj {\n        uint credits;\n        uint idealBalance;\n    }\n}\n\ncontract MPTValidatorV4 is ILayerZeroValidationLibrary, IValidationLibraryHelper {\n    using RLPDecode for RLPDecode.RLPItem;\n    using RLPDecode for RLPDecode.Iterator;\n    using LayerZeroPacket for bytes;\n\n    uint8 public utilsVersion = 3;\n    bytes32 public constant PACKET_SIGNATURE = 0xe8d23d927749ec8e512eb885679c2977d57068839d8cca1a85685dbbea0648f6;\n\n    address public immutable stargateBridgeAddress;\n    address public immutable stgTokenAddress;\n    uint16 public immutable localChainId;\n    IUltraLightNode public immutable uln;\n\n    constructor(address _stargateBridgeAddress, address _stgTokenAddress, uint16 _localChainId, address _ulnAddress) {\n        stargateBridgeAddress = _stargateBridgeAddress;\n        stgTokenAddress = _stgTokenAddress;\n        localChainId = _localChainId;\n        uln = IUltraLightNode(_ulnAddress);\n    }\n\n    function validateProof(bytes32 _receiptsRoot, bytes calldata _transactionProof, uint _remoteAddressSize) external view override returns (LayerZeroPacket.Packet memory) {\n        require(_remoteAddressSize > 0, \"ProofLib: invalid address size\");\n\n        (uint16 remoteChainId, bytes32 blockHash, bytes[] memory proof, uint[] memory receiptSlotIndex, uint logIndex) = abi.decode(_transactionProof, (uint16, bytes32, bytes[], uint[], uint));\n\n        ULNLog memory log = _getVerifiedLog(_receiptsRoot, receiptSlotIndex, logIndex, proof);\n        require(log.topicZeroSig == PACKET_SIGNATURE, \"ProofLib: packet not recognized\"); //data\n\n        LayerZeroPacket.Packet memory packet = log.data.getPacket(remoteChainId, _remoteAddressSize, log.contractAddress);\n\n        _assertMessagePath(packet, blockHash, _receiptsRoot);\n\n        if (packet.dstAddress == stargateBridgeAddress) packet.payload = _secureStgPayload(packet.payload);\n\n        if (packet.dstAddress == stgTokenAddress) packet.payload = _secureStgTokenPayload(packet.payload);\n\n        return packet;\n    }\n\n    function _assertMessagePath(LayerZeroPacket.Packet memory packet, bytes32 blockHash, bytes32 receiptsRoot) internal view {\n        require(packet.dstChainId == localChainId, \"ProofLib: invalid destination chain ID\");\n\n        IUltraLightNode.ApplicationConfiguration memory appConfig = uln.getAppConfig(packet.srcChainId, packet.dstAddress);\n        IUltraLightNode.BlockData memory blockData = uln.getBlockHeaderData(appConfig.oracle, packet.srcChainId, blockHash);\n\n        require(blockData.data == receiptsRoot, \"ProofLib: invalid receipt root\");\n\n        require(blockData.confirmations >= appConfig.inboundBlockConfirmations, \"ProofLib: not enough block confirmations\");\n    }\n\n    function _secureStgTokenPayload(bytes memory _payload) internal pure returns (bytes memory) {\n        (bytes memory toAddressBytes, uint qty) = abi.decode(_payload, (bytes, uint));\n\n        address toAddress = address(0);\n        if (toAddressBytes.length > 0) {\n            assembly {\n                toAddress := mload(add(toAddressBytes, 20))\n            }\n        }\n\n        if (toAddress == address(0)) {\n            address deadAddress = address(0x000000000000000000000000000000000000dEaD);\n            bytes memory newToAddressBytes = abi.encodePacked(deadAddress);\n            return abi.encode(newToAddressBytes, qty);\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function _secureStgPayload(bytes memory _payload) internal view returns (bytes memory) {\n        // functionType is uint8 even though the encoding will take up the side of uint256\n        uint8 functionType;\n        assembly {\n            functionType := mload(add(_payload, 32))\n        }\n\n        // TYPE_SWAP_REMOTE == 1 && only if the payload has a payload\n        // only swapRemote inside of stargate can call sgReceive on an user supplied to address\n        // thus we do not care about the other type functions even if the toAddress is overly long.\n        if (functionType == 1) {\n            // decode the _payload with its types\n            (, uint srcPoolId, uint dstPoolId, uint dstGasForCall, IStargate.CreditObj memory c, IStargate.SwapObj memory s, bytes memory toAddressBytes, bytes memory contractCallPayload) = abi.decode(_payload, (uint8, uint, uint, uint, IStargate.CreditObj, IStargate.SwapObj, bytes, bytes));\n\n            // if contractCallPayload.length > 0 need to check if the to address is a contract or not\n            if (contractCallPayload.length > 0) {\n                // otherwise, need to check if the payload can be delivered to the toAddress\n                address toAddress = address(0);\n                if (toAddressBytes.length > 0) {\n                    assembly {\n                        toAddress := mload(add(toAddressBytes, 20))\n                    }\n                }\n\n                // check if the toAddress is a contract. We are not concerned about addresses that pretend to be wallets. because worst case we just delete their payload if being malicious\n                // we can guarantee that if a size > 0, then the contract is definitely a contract address in this context\n                uint size;\n                assembly {\n                    size := extcodesize(toAddress)\n                }\n\n                if (size == 0) {\n                    // size == 0 indicates its not a contract, payload wont be delivered\n                    // secure the _payload to make sure funds can be delivered to the toAddress\n                    bytes memory newToAddressBytes = abi.encodePacked(toAddress);\n                    bytes memory securePayload = abi.encode(functionType, srcPoolId, dstPoolId, dstGasForCall, c, s, newToAddressBytes, bytes(\"\"));\n                    return securePayload;\n                }\n            }\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function secureStgTokenPayload(bytes memory _payload) external pure returns (bytes memory) {\n        return _secureStgTokenPayload(_payload);\n    }\n\n    function secureStgPayload(bytes memory _payload) external view returns (bytes memory) {\n        return _secureStgPayload(_payload);\n    }\n\n    function _getVerifiedLog(bytes32 hashRoot, uint[] memory paths, uint logIndex, bytes[] memory proof) internal pure returns (ULNLog memory) {\n        require(paths.length == proof.length, \"ProofLib: invalid proof size\");\n        require(proof.length > 0, \"ProofLib: proof size must > 0\");\n        RLPDecode.RLPItem memory item;\n        bytes memory proofBytes;\n\n        for (uint i = 0; i < proof.length; i++) {\n            proofBytes = proof[i];\n            require(hashRoot == keccak256(proofBytes), \"ProofLib: invalid hashlink\");\n            item = RLPDecode.toRlpItem(proofBytes).safeGetItemByIndex(paths[i]);\n            if (i < proof.length - 1) hashRoot = bytes32(item.toUint());\n        }\n\n        // burning status + gasUsed + logBloom\n        RLPDecode.RLPItem memory logItem = item.typeOffset().safeGetItemByIndex(3);\n        RLPDecode.Iterator memory it = logItem.safeGetItemByIndex(logIndex).iterator();\n        ULNLog memory log;\n        log.contractAddress = bytes32(it.next().toUint());\n        log.topicZeroSig = bytes32(it.next().safeGetItemByIndex(0).toUint());\n        log.data = it.next().toBytes();\n\n        return log;\n    }\n\n    function getUtilsVersion() external view override returns (uint8) {\n        return utilsVersion;\n    }\n\n    function getVerifyLog(bytes32 hashRoot, uint[] memory receiptSlotIndex, uint logIndex, bytes[] memory proof) external pure override returns (ULNLog memory) {\n        return _getVerifiedLog(hashRoot, receiptSlotIndex, logIndex, proof);\n    }\n\n    function getPacket(bytes memory data, uint16 srcChain, uint sizeOfSrcAddress, bytes32 ulnAddress) external pure override returns (LayerZeroPacket.Packet memory) {\n        return data.getPacket(srcChain, sizeOfSrcAddress, ulnAddress);\n    }\n\n    // profiling and test\n    function assertMessagePath(LayerZeroPacket.Packet memory packet, bytes32 blockHash, bytes32 receiptsRoot) external view {\n        _assertMessagePath(packet, blockHash, receiptsRoot);\n    }\n}\n"
    },
    "contracts/proof/MPTValidatorV5.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/IValidationLibraryHelper.sol\";\nimport \"./utility/LayerZeroPacket.sol\";\nimport \"./utility/UltraLightNodeEVMDecoder.sol\";\n\ninterface IUltraLightNode {\n    struct BlockData {\n        uint confirmations;\n        bytes32 data;\n    }\n\n    struct ApplicationConfiguration {\n        uint16 inboundProofLibraryVersion;\n        uint64 inboundBlockConfirmations;\n        address relayer;\n        uint16 outboundProofType;\n        uint64 outboundBlockConfirmations;\n        address oracle;\n    }\n\n    function getAppConfig(uint16 _chainId, address userApplicationAddress) external view returns (ApplicationConfiguration memory);\n\n    function getBlockHeaderData(address _oracle, uint16 _remoteChainId, bytes32 _lookupHash) external view returns (BlockData memory blockData);\n}\n\ninterface IStargate {\n    // Stargate objects for abi encoding / decoding\n    struct SwapObj {\n        uint amount;\n        uint eqFee;\n        uint eqReward;\n        uint lpFee;\n        uint protocolFee;\n        uint lkbRemove;\n    }\n\n    struct CreditObj {\n        uint credits;\n        uint idealBalance;\n    }\n}\n\ncontract MPTValidatorV5 is ILayerZeroValidationLibrary, IValidationLibraryHelper {\n    using RLPDecode for RLPDecode.RLPItem;\n    using RLPDecode for RLPDecode.Iterator;\n    using LayerZeroPacket for bytes;\n\n    uint8 public utilsVersion = 3;\n    bytes32 public constant PACKET_SIGNATURE = 0xe8d23d927749ec8e512eb885679c2977d57068839d8cca1a85685dbbea0648f6;\n\n    address public immutable stargateBridgeAddress;\n    address public immutable stgTokenAddress;\n    address public immutable relayerAddress;\n    uint16 public immutable localChainId;\n    IUltraLightNode public immutable uln;\n\n    constructor(address _stargateBridgeAddress, address _stgTokenAddress, uint16 _localChainId, address _ulnAddress, address _relayerAddress) {\n        stargateBridgeAddress = _stargateBridgeAddress;\n        stgTokenAddress = _stgTokenAddress;\n        localChainId = _localChainId;\n        uln = IUltraLightNode(_ulnAddress);\n        relayerAddress = _relayerAddress;\n    }\n\n    function validateProof(bytes32 _receiptsRoot, bytes calldata _transactionProof, uint _remoteAddressSize) external view override returns (LayerZeroPacket.Packet memory) {\n        require(_remoteAddressSize > 0, \"ProofLib: invalid address size\");\n\n        (uint16 remoteChainId, bytes32 blockHash, bytes[] memory proof, uint[] memory receiptSlotIndex, uint logIndex) = abi.decode(_transactionProof, (uint16, bytes32, bytes[], uint[], uint));\n\n        ULNLog memory log = _getVerifiedLog(_receiptsRoot, receiptSlotIndex, logIndex, proof);\n        require(log.topicZeroSig == PACKET_SIGNATURE, \"ProofLib: packet not recognized\"); //data\n\n        LayerZeroPacket.Packet memory packet = log.data.getPacket(remoteChainId, _remoteAddressSize, log.contractAddress);\n\n        _assertMessagePath(packet, blockHash, _receiptsRoot);\n\n        if (packet.dstAddress == stargateBridgeAddress) packet.payload = _secureStgPayload(packet.payload);\n\n        if (packet.dstAddress == stgTokenAddress) packet.payload = _secureStgTokenPayload(packet.payload);\n\n        return packet;\n    }\n\n    function _assertMessagePath(LayerZeroPacket.Packet memory packet, bytes32 blockHash, bytes32 receiptsRoot) internal view {\n        require(packet.dstChainId == localChainId, \"ProofLib: invalid destination chain ID\");\n\n        IUltraLightNode.ApplicationConfiguration memory appConfig = uln.getAppConfig(packet.srcChainId, packet.dstAddress);\n        IUltraLightNode.BlockData memory blockData = uln.getBlockHeaderData(appConfig.oracle, packet.srcChainId, blockHash);\n        require(appConfig.relayer == relayerAddress, \"ProofLib: invalid relayer\");\n\n        require(blockData.data == receiptsRoot, \"ProofLib: invalid receipt root\");\n\n        require(blockData.confirmations >= appConfig.inboundBlockConfirmations, \"ProofLib: not enough block confirmations\");\n    }\n\n    function _secureStgTokenPayload(bytes memory _payload) internal pure returns (bytes memory) {\n        (bytes memory toAddressBytes, uint qty) = abi.decode(_payload, (bytes, uint));\n\n        address toAddress = address(0);\n        if (toAddressBytes.length > 0) {\n            assembly {\n                toAddress := mload(add(toAddressBytes, 20))\n            }\n        }\n\n        if (toAddress == address(0)) {\n            address deadAddress = address(0x000000000000000000000000000000000000dEaD);\n            bytes memory newToAddressBytes = abi.encodePacked(deadAddress);\n            return abi.encode(newToAddressBytes, qty);\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function _secureStgPayload(bytes memory _payload) internal view returns (bytes memory) {\n        // functionType is uint8 even though the encoding will take up the side of uint256\n        uint8 functionType;\n        assembly {\n            functionType := mload(add(_payload, 32))\n        }\n\n        // TYPE_SWAP_REMOTE == 1 && only if the payload has a payload\n        // only swapRemote inside of stargate can call sgReceive on an user supplied to address\n        // thus we do not care about the other type functions even if the toAddress is overly long.\n        if (functionType == 1) {\n            // decode the _payload with its types\n            (, uint srcPoolId, uint dstPoolId, uint dstGasForCall, IStargate.CreditObj memory c, IStargate.SwapObj memory s, bytes memory toAddressBytes, bytes memory contractCallPayload) = abi.decode(_payload, (uint8, uint, uint, uint, IStargate.CreditObj, IStargate.SwapObj, bytes, bytes));\n\n            // if contractCallPayload.length > 0 need to check if the to address is a contract or not\n            if (contractCallPayload.length > 0) {\n                // otherwise, need to check if the payload can be delivered to the toAddress\n                address toAddress = address(0);\n                if (toAddressBytes.length > 0) {\n                    assembly {\n                        toAddress := mload(add(toAddressBytes, 20))\n                    }\n                }\n\n                // check if the toAddress is a contract. We are not concerned about addresses that pretend to be wallets. because worst case we just delete their payload if being malicious\n                // we can guarantee that if a size > 0, then the contract is definitely a contract address in this context\n                uint size;\n                assembly {\n                    size := extcodesize(toAddress)\n                }\n\n                if (size == 0) {\n                    // size == 0 indicates its not a contract, payload wont be delivered\n                    // secure the _payload to make sure funds can be delivered to the toAddress\n                    bytes memory newToAddressBytes = abi.encodePacked(toAddress);\n                    bytes memory securePayload = abi.encode(functionType, srcPoolId, dstPoolId, dstGasForCall, c, s, newToAddressBytes, bytes(\"\"));\n                    return securePayload;\n                }\n            }\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function secureStgTokenPayload(bytes memory _payload) external pure returns (bytes memory) {\n        return _secureStgTokenPayload(_payload);\n    }\n\n    function secureStgPayload(bytes memory _payload) external view returns (bytes memory) {\n        return _secureStgPayload(_payload);\n    }\n\n    function _getVerifiedLog(bytes32 hashRoot, uint[] memory paths, uint logIndex, bytes[] memory proof) internal pure returns (ULNLog memory) {\n        require(paths.length == proof.length, \"ProofLib: invalid proof size\");\n        require(proof.length > 0, \"ProofLib: proof size must > 0\");\n        RLPDecode.RLPItem memory item;\n        bytes memory proofBytes;\n\n        for (uint i = 0; i < proof.length; i++) {\n            proofBytes = proof[i];\n            require(hashRoot == keccak256(proofBytes), \"ProofLib: invalid hashlink\");\n            item = RLPDecode.toRlpItem(proofBytes).safeGetItemByIndex(paths[i]);\n            if (i < proof.length - 1) hashRoot = bytes32(item.toUint());\n        }\n\n        // burning status + gasUsed + logBloom\n        RLPDecode.RLPItem memory logItem = item.typeOffset().safeGetItemByIndex(3);\n        RLPDecode.Iterator memory it = logItem.safeGetItemByIndex(logIndex).iterator();\n        ULNLog memory log;\n        log.contractAddress = bytes32(it.next().toUint());\n        log.topicZeroSig = bytes32(it.next().safeGetItemByIndex(0).toUint());\n        log.data = it.next().toBytes();\n\n        return log;\n    }\n\n    function getUtilsVersion() external view override returns (uint8) {\n        return utilsVersion;\n    }\n\n    function getVerifyLog(bytes32 hashRoot, uint[] memory receiptSlotIndex, uint logIndex, bytes[] memory proof) external pure override returns (ULNLog memory) {\n        return _getVerifiedLog(hashRoot, receiptSlotIndex, logIndex, proof);\n    }\n\n    function getPacket(bytes memory data, uint16 srcChain, uint sizeOfSrcAddress, bytes32 ulnAddress) external pure override returns (LayerZeroPacket.Packet memory) {\n        return data.getPacket(srcChain, sizeOfSrcAddress, ulnAddress);\n    }\n\n    // profiling and test\n    function assertMessagePath(LayerZeroPacket.Packet memory packet, bytes32 blockHash, bytes32 receiptsRoot) external view {\n        _assertMessagePath(packet, blockHash, receiptsRoot);\n    }\n}\n"
    },
    "contracts/proof/utility/Buffer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// https://github.com/ensdomains/buffer\n\npragma solidity ^0.7.0;\n\n/**\n * @dev A library for working with mutable byte buffers in Solidity.\n *\n * Byte buffers are mutable and expandable, and provide a variety of primitives\n * for writing to them. At any time you can fetch a bytes object containing the\n * current contents of the buffer. The bytes object should not be stored between\n * operations, as it may change due to resizing of the buffer.\n */\nlibrary Buffer {\n    /**\n     * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n     *      a capacity. The capacity may be longer than the current value, in\n     *      which case it can be extended without the need to allocate more memory.\n     */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n     * @dev Initializes a buffer with an initial capacity.a co\n     * @param buf The buffer to initialize.\n     * @param capacity The number of bytes of space to allocate the buffer.\n     * @return The buffer, for chaining.\n     */\n    function init(buffer memory buf, uint capacity) internal pure returns (buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            mstore(0x40, add(32, add(ptr, capacity)))\n        }\n        return buf;\n    }\n\n\n    /**\n     * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The start offset to write to.\n     * @param rawData The data to append.\n     * @param len The number of bytes to copy.\n     * @return The original buffer, for chaining.\n     */\n    function writeRawBytes(\n        buffer memory buf,\n        uint off,\n        bytes memory rawData,\n        uint offData,\n        uint len\n    ) internal pure returns (buffer memory) {\n        if (off + len > buf.capacity) {\n            resize(buf, max(buf.capacity, len + off) * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(add(len, off), buflen) {\n                mstore(bufptr, add(len, off))\n            }\n            src := add(rawData, offData)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint mask = 256**(32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n\n        return buf;\n    }\n\n    /**\n     * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The start offset to write to.\n     * @param data The data to append.\n     * @param len The number of bytes to copy.\n     * @return The original buffer, for chaining.\n     */\n    function write(buffer memory buf, uint off, bytes memory data, uint len) internal pure returns (buffer memory) {\n        require(len <= data.length);\n\n        if (off + len > buf.capacity) {\n            resize(buf, max(buf.capacity, len + off) * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n        // Memory address of the buffer data\n            let bufptr := mload(buf)\n        // Length of existing buffer data\n            let buflen := mload(bufptr)\n        // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n        // Update buffer length if we're extending it\n            if gt(add(len, off), buflen) {\n                mstore(bufptr, add(len, off))\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint mask = 256**(32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n\n        return buf;\n    }\n\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, data.length);\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    function max(uint a, uint b) private pure returns (uint) {\n        if (a > b) {\n            return a;\n        }\n        return b;\n    }\n}\n"
    },
    "contracts/proof/utility/LayerZeroPacket.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"./Buffer.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nlibrary LayerZeroPacket {\n    using Buffer for Buffer.buffer;\n    using SafeMath for uint;\n\n    struct Packet {\n        uint16 srcChainId;\n        uint16 dstChainId;\n        uint64 nonce;\n        address dstAddress;\n        bytes srcAddress;\n        bytes32 ulnAddress;\n        bytes payload;\n    }\n\n    function getPacket(\n        bytes memory data,\n        uint16 srcChain,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) internal pure returns (LayerZeroPacket.Packet memory) {\n        uint16 dstChainId;\n        address dstAddress;\n        uint size;\n        uint64 nonce;\n\n        // The log consists of the destination chain id and then a bytes payload\n        //      0--------------------------------------------31\n        // 0   |  total bytes size\n        // 32  |  destination chain id\n        // 64  |  bytes offset\n        // 96  |  bytes array size\n        // 128 |  payload\n        assembly {\n            dstChainId := mload(add(data, 32))\n            size := mload(add(data, 96)) /// size of the byte array\n            nonce := mload(add(data, 104)) // offset to convert to uint64  128  is index -24\n            dstAddress := mload(add(data, sub(add(128, sizeOfSrcAddress), 4))) // offset to convert to address 12 -8\n        }\n\n        Buffer.buffer memory srcAddressBuffer;\n        srcAddressBuffer.init(sizeOfSrcAddress);\n        srcAddressBuffer.writeRawBytes(0, data, 136, sizeOfSrcAddress); // 128 + 8\n\n        uint payloadSize = size.sub(28).sub(sizeOfSrcAddress);\n        Buffer.buffer memory payloadBuffer;\n        payloadBuffer.init(payloadSize);\n        payloadBuffer.writeRawBytes(0, data, sizeOfSrcAddress.add(156), payloadSize); // 148 + 8\n        return LayerZeroPacket.Packet(srcChain, dstChainId, nonce, dstAddress, srcAddressBuffer.buf, ulnAddress, payloadBuffer.buf);\n    }\n\n    function getPacketV2(\n        bytes memory data,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) internal pure returns (LayerZeroPacket.Packet memory) {\n        // packet def: abi.encodePacked(nonce, srcChain, srcAddress, dstChain, dstAddress, payload);\n        // data def: abi.encode(packet) = offset(32) + length(32) + packet\n        //              if from EVM\n        // 0 - 31       0 - 31          |  total bytes size\n        // 32 - 63      32 - 63         |  location\n        // 64 - 95      64 - 95         |  size of the packet\n        // 96 - 103     96 - 103        |  nonce\n        // 104 - 105    104 - 105       |  srcChainId\n        // 106 - P      106 - 125       |  srcAddress, where P = 106 + sizeOfSrcAddress - 1,\n        // P+1 - P+2    126 - 127       |  dstChainId\n        // P+3 - P+22   128 - 147       |  dstAddress\n        // P+23 - END   148 - END       |  payload\n\n        // decode the packet\n        uint256 realSize;\n        uint64 nonce;\n        uint16 srcChain;\n        uint16 dstChain;\n        address dstAddress;\n        assembly {\n            realSize := mload(add(data, 64))\n            nonce := mload(add(data, 72)) // 104 - 32\n            srcChain := mload(add(data, 74)) // 106 - 32\n            dstChain := mload(add(data, add(76, sizeOfSrcAddress))) // P + 3 - 32 = 105 + size + 3 - 32 = 76 + size\n            dstAddress := mload(add(data, add(96, sizeOfSrcAddress))) // P + 23 - 32 = 105 + size + 23 - 32 = 96 + size\n        }\n\n        require(srcChain != 0, \"LayerZeroPacket: invalid packet\");\n\n        Buffer.buffer memory srcAddressBuffer;\n        srcAddressBuffer.init(sizeOfSrcAddress);\n        srcAddressBuffer.writeRawBytes(0, data, 106, sizeOfSrcAddress);\n\n        uint nonPayloadSize = sizeOfSrcAddress.add(32);// 2 + 2 + 8 + 20, 32 + 20 = 52 if sizeOfSrcAddress == 20\n        uint payloadSize = realSize.sub(nonPayloadSize);\n        Buffer.buffer memory payloadBuffer;\n        payloadBuffer.init(payloadSize);\n        payloadBuffer.writeRawBytes(0, data, nonPayloadSize.add(96), payloadSize);\n\n        return LayerZeroPacket.Packet(srcChain, dstChain, nonce, dstAddress, srcAddressBuffer.buf, ulnAddress, payloadBuffer.buf);\n    }\n\n    function getPacketV3(\n        bytes memory data,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) internal pure returns (LayerZeroPacket.Packet memory) {\n        // data def: abi.encodePacked(nonce, srcChain, srcAddress, dstChain, dstAddress, payload);\n        //              if from EVM\n        // 0 - 31       0 - 31          |  total bytes size\n        // 32 - 39      32 - 39         |  nonce\n        // 40 - 41      40 - 41         |  srcChainId\n        // 42 - P       42 - 61         |  srcAddress, where P = 41 + sizeOfSrcAddress,\n        // P+1 - P+2    62 - 63         |  dstChainId\n        // P+3 - P+22   64 - 83         |  dstAddress\n        // P+23 - END   84 - END        |  payload\n\n        // decode the packet\n        uint256 realSize = data.length;\n        uint nonPayloadSize = sizeOfSrcAddress.add(32);// 2 + 2 + 8 + 20, 32 + 20 = 52 if sizeOfSrcAddress == 20\n        require(realSize >= nonPayloadSize, \"LayerZeroPacket: invalid packet\");\n        uint payloadSize = realSize - nonPayloadSize;\n\n        uint64 nonce;\n        uint16 srcChain;\n        uint16 dstChain;\n        address dstAddress;\n        assembly {\n            nonce := mload(add(data, 8)) // 40 - 32\n            srcChain := mload(add(data, 10)) // 42 - 32\n            dstChain := mload(add(data, add(12, sizeOfSrcAddress))) // P + 3 - 32 = 41 + size + 3 - 32 = 12 + size\n            dstAddress := mload(add(data, add(32, sizeOfSrcAddress))) // P + 23 - 32 = 41 + size + 23 - 32 = 32 + size\n        }\n\n        require(srcChain != 0, \"LayerZeroPacket: invalid packet\");\n\n        Buffer.buffer memory srcAddressBuffer;\n        srcAddressBuffer.init(sizeOfSrcAddress);\n        srcAddressBuffer.writeRawBytes(0, data, 42, sizeOfSrcAddress);\n\n        Buffer.buffer memory payloadBuffer;\n        if (payloadSize > 0) {\n            payloadBuffer.init(payloadSize);\n            payloadBuffer.writeRawBytes(0, data, nonPayloadSize.add(32), payloadSize);\n        }\n\n        return LayerZeroPacket.Packet(srcChain, dstChain, nonce, dstAddress, srcAddressBuffer.buf, ulnAddress, payloadBuffer.buf);\n    }\n}\n"
    },
    "contracts/proof/utility/RLPDecode.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// https://github.com/hamdiallam/solidity-rlp\n\npragma solidity ^0.7.0;\n\nlibrary RLPDecode {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START = 0xb8;\n    uint8 constant LIST_SHORT_START = 0xc0;\n    uint8 constant LIST_LONG_START = 0xf8;\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint len;\n        uint memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that's being iterated over.\n        uint nextPtr; // Position of the next item in the list.\n    }\n\n    /*\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\n     * @param self The iterator.\n     * @return The next element in the iteration.\n     */\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self), \"RLPDecoder iterator has no next\");\n\n        uint ptr = self.nextPtr;\n        uint itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    /*\n     * @dev Returns true if the iteration has more elements.\n     * @param self The iterator.\n     * @return true if the iteration has more elements.\n     */\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n        uint memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n        // offset the pointer if the first byte\n\n        uint8 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n        uint len = item.length;\n        if (len > 0 && byte0 < LIST_SHORT_START) {\n            assembly {\n                memPtr := add(memPtr, 0x01)\n            }\n            len -= 1;\n        }\n        return RLPItem(len, memPtr);\n    }\n\n    /*\n     * @dev Create an iterator. Reverts if item is not a list.\n     * @param self The RLP item.\n     * @return An 'Iterator' over the item.\n     */\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self), \"RLPDecoder iterator is not list\");\n\n        uint ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function rlpLen(RLPItem memory item) internal pure returns (uint) {\n        return item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function payloadLen(RLPItem memory item) internal pure returns (uint) {\n        uint offset = _payloadOffset(item.memPtr);\n        require(item.len >= offset, \"RLPDecoder: invalid uint RLP item offset size\");\n        return item.len - offset;\n    }\n\n    /*\n     * @param item RLP encoded list in bytes\n     */\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item), \"RLPDecoder iterator is not a list\");\n\n        uint items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint dataLen;\n        for (uint i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr);\n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    /*\n     * @param get the RLP item by index. save gas.\n     */\n    function getItemByIndex(RLPItem memory item, uint idx) internal pure returns (RLPItem memory) {\n        require(isList(item), \"RLPDecoder iterator is not a list\");\n\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint dataLen;\n        for (uint i = 0; i < idx; i++) {\n            dataLen = _itemLength(memPtr);\n            memPtr = memPtr + dataLen;\n        }\n        dataLen = _itemLength(memPtr);\n        return RLPItem(dataLen, memPtr);\n    }\n\n\n    /*\n     * @param get the RLP item by index. save gas.\n     */\n    function safeGetItemByIndex(RLPItem memory item, uint idx) internal pure returns (RLPItem memory) {\n        require(isList(item), \"RLPDecoder iterator is not a list\");\n        require(idx < numItems(item), \"RLP item out of bounds\");\n        uint endPtr = item.memPtr + item.len;\n\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint dataLen;\n        for (uint i = 0; i < idx; i++) {\n            dataLen = _itemLength(memPtr);\n            memPtr = memPtr + dataLen;\n        }\n        dataLen = _itemLength(memPtr);\n\n        require(memPtr + dataLen <= endPtr, \"RLP item overflow\");\n        return RLPItem(dataLen, memPtr);\n    }\n\n    /*\n     * @param offset the receipt bytes item\n     */\n    function typeOffset(RLPItem memory item) internal pure returns (RLPItem memory) {\n        uint offset = _payloadOffset(item.memPtr);\n        uint8 byte0;\n        uint memPtr = item.memPtr;\n        uint len = item.len;\n        assembly {\n            memPtr := add(memPtr, offset)\n            byte0 := byte(0, mload(memPtr))\n        }\n        if (len >0 && byte0 < LIST_SHORT_START) {\n            assembly {\n                memPtr := add(memPtr, 0x01)\n            }\n            len -= 1;\n        }\n        return RLPItem(len, memPtr);\n    }\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START) return false;\n        return true;\n    }\n\n    /** RLPItem conversions into data types **/\n\n    // @returns raw rlp encoding in bytes\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n\n        uint ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    // any non-zero byte except \"0x80\" is considered true\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1, \"RLPDecoder toBoolean invalid length\");\n        uint result;\n        uint memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        // SEE Github Issue #5.\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\n        // \"0\" as \"0x80\" instead of as \"0\". We handle this edge case explicitly\n        // here.\n        if (result == 0 || result == STRING_SHORT_START) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21, \"RLPDecoder toAddress invalid length\");\n\n        return address(toUint(item));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint) {\n        require(item.len > 0 && item.len <= 33, \"RLPDecoder toUint invalid length\");\n\n        uint offset = _payloadOffset(item.memPtr);\n        require(item.len >= offset, \"RLPDecoder: invalid RLP item offset size\");\n        uint len = item.len - offset;\n\n        uint result;\n        uint memPtr = item.memPtr + offset;\n        assembly {\n            result := mload(memPtr)\n\n            // shift to the correct location if necessary\n            if lt(len, 32) {\n                result := div(result, exp(256, sub(32, len)))\n            }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint) {\n        // one byte prefix\n        require(item.len == 33, \"RLPDecoder toUintStrict invalid length\");\n\n        uint result;\n        uint memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0, \"RLPDecoder toBytes invalid length\");\n\n        uint offset = _payloadOffset(item.memPtr);\n        require(item.len >= offset, \"RLPDecoder: invalid RLP item offset size\");\n        uint len = item.len - offset; // data length\n        bytes memory result = new bytes(len);\n\n        uint destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(item.memPtr + offset, destPtr, len);\n        return result;\n    }\n\n    /*\n     * Private Helpers\n     */\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) internal pure returns (uint) {\n        if (item.len == 0) return 0;\n\n        uint count = 0;\n        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\n            count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint memPtr) private pure returns (uint) {\n        uint itemLen;\n        uint byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) itemLen = 1;\n        else if (byte0 < STRING_LONG_START) itemLen = byte0 - STRING_SHORT_START + 1;\n        else if (byte0 < LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        } else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint memPtr) private pure returns (uint) {\n        uint byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) return 0;\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) return 1;\n        else if (byte0 < LIST_SHORT_START)\n            // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        else return byte0 - (LIST_LONG_START - 1) + 1;\n    }\n\n    /*\n     * @param src Pointer to source\n     * @param dest Pointer to destination\n     * @param len Amount of memory to copy from the source\n     */\n    function copy(\n        uint src,\n        uint dest,\n        uint len\n    ) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n        uint mask = 256**(WORD_SIZE - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask)) // zero out src\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}\n"
    },
    "contracts/proof/utility/UltraLightNodeEVMDecoder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"./RLPDecode.sol\";\n\nlibrary UltraLightNodeEVMDecoder {\n    using RLPDecode for RLPDecode.RLPItem;\n    using RLPDecode for RLPDecode.Iterator;\n\n    struct Log {\n        address contractAddress;\n        bytes32 topicZero;\n        bytes data;\n    }\n\n    function getReceiptLog(bytes memory data, uint logIndex) internal pure returns (Log memory) {\n        RLPDecode.Iterator memory it = RLPDecode.toRlpItem(data).iterator();\n        uint idx;\n        while (it.hasNext()) {\n            if (idx == 3) {\n                return toReceiptLog(it.next().getItemByIndex(logIndex).toRlpBytes());\n            } else it.next();\n            idx++;\n        }\n        revert(\"no log index in receipt\");\n    }\n\n    function toReceiptLog(bytes memory data) internal pure returns (Log memory) {\n        RLPDecode.Iterator memory it = RLPDecode.toRlpItem(data).iterator();\n        Log memory log;\n\n        uint idx;\n        while (it.hasNext()) {\n            if (idx == 0) {\n                log.contractAddress = it.next().toAddress();\n            } else if (idx == 1) {\n                RLPDecode.RLPItem memory item = it.next().getItemByIndex(0);\n                log.topicZero = bytes32(item.toUint());\n            } else if (idx == 2) log.data = it.next().toBytes();\n            else it.next();\n            idx++;\n        }\n        return log;\n    }\n}\n"
    },
    "contracts/Relayer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"hardhat-deploy/solc_0.7/proxy/Proxied.sol\";\n\nimport \"./interfaces/ILayerZeroRelayer.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV1.sol\";\n\ncontract Relayer is ILayerZeroRelayer, ReentrancyGuard, OwnableUpgradeable, Proxied {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n    using SafeMath for uint128;\n    using SafeMath for uint64;\n\n    ILayerZeroUltraLightNodeV1 public uln;\n\n    struct DstPrice {\n        uint128 dstPriceRatio; // 10^10\n        uint128 dstGasPriceInWei;\n    }\n\n    struct DstConfig {\n        uint128 dstNativeAmtCap;\n        uint64 baseGas;\n        uint64 gasPerByte;\n    }\n\n    // [_chainId] => DstPriceData. change often\n    mapping(uint16 => DstPrice) public dstPriceLookup;\n    // [_chainId][_outboundProofType] => DstConfig. change much less often\n    mapping(uint16 => mapping(uint16 => DstConfig)) public dstConfigLookup;\n    mapping(address => bool) public approvedAddresses;\n\n    event WithdrawTokens(address token, address to, uint amount);\n    event Withdraw(address to, uint amount);\n    event ApproveAddress(address addr, bool approved);\n\n    address public stargateBridgeAddress;\n\n    event InvalidPayloadSize(uint indexed payloadSize);\n    event ValueTransferFailed(address indexed to, uint indexed quantity);\n\n    //----------------------------------------------------------------------------------\n    // Relayer Interface V2 Change\n\n    event AssignJob(uint16 dstChainId, uint16 outboundProofType, address userApplication, uint totalFee);\n    event Ulnv2Set(address ulnv2);\n\n    // new pauseable relayer\n    bool public paused;\n\n    // owner is always approved\n    modifier onlyApproved() {\n        if (owner() != msg.sender) {\n            require(isApproved(msg.sender), \"Relayer: not approved \");\n        }\n        _;\n    }\n\n    function initialize(address _uln) public proxied initializer {\n        __Ownable_init();\n        uln = ILayerZeroUltraLightNodeV1(_uln);\n        setApprovedAddress(address(this), true);\n    }\n\n    //----------------------------------------------------------------------------------\n    // onlyApproved\n    function validateTransactionProofV2(uint16 _srcChainId, address _dstAddress, uint _gasLimit, bytes32 _blockHash, bytes calldata _transactionProof, address payable _to) external payable onlyApproved nonReentrant {\n        (bool sent, ) = _to.call{value: msg.value}(\"\");\n        //require(sent, \"Relayer: failed to send ether\");\n        if (!sent) {\n            emit ValueTransferFailed(_to, msg.value);\n        }\n        uln.validateTransactionProof(_srcChainId, _dstAddress, _gasLimit, _blockHash, _transactionProof);\n    }\n\n    function validateTransactionProofV1(uint16 _srcChainId, address _dstAddress, uint _gasLimit, bytes32 _blockHash, bytes calldata _transactionProof) external onlyApproved nonReentrant {\n        uln.validateTransactionProof(_srcChainId, _dstAddress, _gasLimit, _blockHash, _transactionProof);\n    }\n\n    function setDstPrice(uint16 _chainId, uint128 _dstPriceRatio, uint128 _dstGasPriceInWei) external onlyApproved {\n        dstPriceLookup[_chainId] = DstPrice(_dstPriceRatio, _dstGasPriceInWei);\n    }\n\n    function setDstConfig(uint16 _chainId, uint16 _outboundProofType, uint128 _dstNativeAmtCap, uint64 _baseGas, uint64 _gasPerByte) external onlyApproved {\n        dstConfigLookup[_chainId][_outboundProofType] = DstConfig(_dstNativeAmtCap, _baseGas, _gasPerByte);\n    }\n\n    // other relayer fees are withdrawn through the RelayerFee interface\n    // uint8 public constant WITHDRAW_TYPE_RELAYER_QUOTED_FEES = 2;\n    function withdrawQuotedFromULN(address payable _to, uint _amount) external onlyApproved {\n        uln.withdrawNative(2, address(0x0), _to, _amount);\n    }\n\n    //----------------------------------------------------------------------------------\n    // onlyOwner\n\n    function setApprovedAddress(address _relayerAddress, bool _approve) public onlyOwner {\n        approvedAddresses[_relayerAddress] = _approve;\n        emit ApproveAddress(_relayerAddress, _approve);\n    }\n\n    function setPause(bool _paused) public onlyOwner {\n        paused = _paused;\n    }\n\n    //----------------------------------------------------------------------------------\n    // view functions\n\n    // txType 1\n    // bytes  [2       32      ]\n    // fields [txType  extraGas]\n    // txType 2\n    // bytes  [2       32        32            bytes[]         ]\n    // fields [txType  extraGas  dstNativeAmt  dstNativeAddress]\n    // User App Address is not used in this version\n    function _getPrices(uint16 _dstChainId, uint16 _outboundProofType, address, bytes memory _adapterParameters) internal view returns (uint basePrice, uint pricePerByte) {\n        require(!paused, \"Admin: paused\");\n        // decoding the _adapterParameters - reverts if type 2 and there is no dstNativeAddress\n        require(_adapterParameters.length == 34 || _adapterParameters.length > 66, \"Relayer: wrong _adapterParameters size\");\n        uint16 txType;\n        uint extraGas;\n        assembly {\n            txType := mload(add(_adapterParameters, 2))\n            extraGas := mload(add(_adapterParameters, 34))\n        }\n        require(extraGas > 0, \"Relayer: gas too low\");\n        require(txType == 1 || txType == 2, \"Relayer: unsupported txType\");\n\n        DstPrice storage dstPrice = dstPriceLookup[_dstChainId];\n        DstConfig storage dstConfig = dstConfigLookup[_dstChainId][_outboundProofType];\n\n        uint totalRemoteToken; // = baseGas + extraGas + requiredNativeAmount\n        if (txType == 2) {\n            uint dstNativeAmt;\n            assembly {\n                dstNativeAmt := mload(add(_adapterParameters, 66))\n            }\n            require(dstConfig.dstNativeAmtCap >= dstNativeAmt, \"Relayer: dstNativeAmt too large \");\n            totalRemoteToken = totalRemoteToken.add(dstNativeAmt);\n        }\n        // remoteGasTotal = dstGasPriceInWei * (baseGas + extraGas)\n        uint remoteGasTotal = dstPrice.dstGasPriceInWei.mul(dstConfig.baseGas.add(extraGas));\n\n        totalRemoteToken = totalRemoteToken.add(remoteGasTotal);\n\n        // tokenConversionRate = dstPrice / localPrice\n        // basePrice = totalRemoteToken * tokenConversionRate\n        basePrice = totalRemoteToken.mul(dstPrice.dstPriceRatio).div(10**10);\n\n        // pricePerByte = (dstGasPriceInWei * gasPerBytes) * tokenConversionRate\n        pricePerByte = dstPrice.dstGasPriceInWei.mul(dstConfig.gasPerByte).mul(dstPrice.dstPriceRatio).div(10**10);\n    }\n\n    function notifyRelayer(uint16 _dstChainId, uint16 _outboundProofType, bytes calldata _adapterParams) external override {\n        //do nothing\n    }\n\n    function getPrice(uint16 _dstChainId, uint16 _outboundProofType, address _userApplication, uint payloadSize, bytes calldata _adapterParams) external view override returns (uint) {\n        (uint basePrice, uint pricePerByte) = _getPrices(_dstChainId, _outboundProofType, _userApplication, _adapterParams);\n        return basePrice.add(payloadSize.mul(pricePerByte));\n    }\n\n    function isApproved(address _relayerAddress) public view override returns (bool) {\n        return approvedAddresses[_relayerAddress];\n    }\n}\n"
    },
    "contracts/RelayerV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"hardhat-deploy/solc_0.7/proxy/Proxied.sol\";\n\nimport \"./interfaces/ILayerZeroRelayerV2.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV2.sol\";\nimport \"./interfaces/ILayerZeroPriceFeed.sol\";\n\ncontract RelayerV2 is ReentrancyGuard, OwnableUpgradeable, Proxied, ILayerZeroRelayerV2 {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n    using SafeMath for uint128;\n    using SafeMath for uint64;\n\n    ILayerZeroUltraLightNodeV2 public uln;\n    address public stargateBridgeAddress;\n\n    struct DstPrice {\n        uint128 dstPriceRatio; // 10^10\n        uint128 dstGasPriceInWei;\n    }\n\n    struct DstConfig {\n        uint128 dstNativeAmtCap;\n        uint64 baseGas;\n        uint64 gasPerByte;\n    }\n\n    // [_chainId] => DstPriceData. change often\n    mapping(uint16 => DstPrice) public dstPriceLookupOld;\n    // [_chainId][_outboundProofType] => DstConfig. change much less often\n    mapping(uint16 => mapping(uint16 => DstConfig)) public dstConfigLookup;\n    mapping(address => bool) public approvedAddresses;\n\n    event Withdraw(address to, uint amount);\n    event ApproveAddress(address addr, bool approved);\n    event AssignJob(uint totalFee);\n    event ValueTransferFailed(address indexed to, uint indexed quantity);\n    event SetDstPrice(uint16 chainId, uint128 dstPriceRatio, uint128 dstGasPriceInWei);\n    event SetDstConfig(uint16 chainId, uint16 outboundProofType, uint128 dstNativeAmtCap, uint64 baseGas, uint64 gasPerByte);\n\n    // new pauseable relayer\n    bool public paused;\n\n    // Update for Price Feed\n    ILayerZeroPriceFeed public priceFeed;\n    // multipler\n    uint128 public multiplierBps;\n\n    // PriceFeedContract Upgrade\n    // all encoded param bytes except for proof for validateTransactionProofV1\n    uint16 public validateProofBytes;\n    uint16 public fpBytes;\n    uint16 public mptOverhead;\n\n    // owner is always approved\n    modifier onlyApproved() {\n        if (owner() != msg.sender) {\n            require(isApproved(msg.sender), \"Relayer: not approved\");\n        }\n        _;\n    }\n\n    function initialize(address _uln, address _priceFeed) public proxied initializer {\n        __Ownable_init();\n        uln = ILayerZeroUltraLightNodeV2(_uln);\n        setApprovedAddress(address(this), true);\n        multiplierBps = 12000;\n        priceFeed = ILayerZeroPriceFeed(_priceFeed);\n        validateProofBytes = 164;\n        fpBytes = 160;\n        mptOverhead = 500;\n    }\n\n    function onUpgrade(address _priceFeed) public proxied {\n        multiplierBps = 12000;\n        priceFeed = ILayerZeroPriceFeed(_priceFeed);\n        validateProofBytes = 164;\n        fpBytes = 160;\n        mptOverhead = 500;\n    }\n\n    //----------------------------------------------------------------------------------\n    // onlyApproved\n\n    function setDstPrice(uint16 _chainId, uint128 _dstPriceRatio, uint128 _dstGasPriceInWei) external onlyApproved {\n        // No longer used: Write prices in PriceFeed.\n    }\n\n    function setPriceFeed(address _priceFeed) external onlyApproved {\n        priceFeed = ILayerZeroPriceFeed(_priceFeed);\n    }\n\n    function setPriceMultiplierBps(uint128 _multiplierBps) external onlyApproved {\n        multiplierBps = _multiplierBps;\n    }\n\n    function setDstConfig(uint16 _chainId, uint16 _outboundProofType, uint128 _dstNativeAmtCap, uint64 _baseGas, uint64 _gasPerByte) external onlyApproved {\n        dstConfigLookup[_chainId][_outboundProofType] = DstConfig(_dstNativeAmtCap, _baseGas, _gasPerByte);\n        emit SetDstConfig(_chainId, _outboundProofType, _dstNativeAmtCap, _baseGas, _gasPerByte);\n    }\n\n    function setStargateAddress(address _stargateAddress) external onlyApproved {\n        stargateBridgeAddress = _stargateAddress;\n    }\n\n    //----------------------------------------------------------------------------------\n    // onlyOwner\n\n    function setApprovedAddress(address _relayerAddress, bool _approve) public onlyOwner {\n        approvedAddresses[_relayerAddress] = _approve;\n        emit ApproveAddress(_relayerAddress, _approve);\n    }\n\n    function setPause(bool _paused) public onlyOwner {\n        paused = _paused;\n    }\n\n    // txType 1\n    // bytes  [2       32      ]\n    // fields [txType  extraGas]\n    // txType 2\n    // bytes  [2       32        32            bytes[]         ]\n    // fields [txType  extraGas  dstNativeAmt  dstNativeAddress]\n    // User App Address is not used in this version\n    function _getPrices(uint16 _dstChainId, uint16 _outboundProofType, address, uint _payloadSize, bytes memory _adapterParameters) internal view returns (uint) {\n        require(!paused, \"Admin: paused\");\n        // decoding the _adapterParameters - reverts if type 2 and there is no dstNativeAddress\n        require(_adapterParameters.length == 34 || _adapterParameters.length > 66, \"Relayer: wrong _adapterParameters size\");\n        uint16 txType;\n        uint extraGas;\n        assembly {\n            txType := mload(add(_adapterParameters, 2))\n            extraGas := mload(add(_adapterParameters, 34))\n        }\n        require(extraGas > 0, \"Relayer: gas too low\");\n        require(txType == 1 || txType == 2, \"Relayer: unsupported txType\");\n\n        DstConfig storage dstConfig = dstConfigLookup[_dstChainId][_outboundProofType];\n\n        uint dstNativeAmt = 0;\n        if (txType == 2) {\n            assembly {\n                dstNativeAmt := mload(add(_adapterParameters, 66))\n            }\n            require(dstConfig.dstNativeAmtCap >= dstNativeAmt, \"Relayer: dstNativeAmt too large\");\n        }\n\n        // validateTransactionProof bytes = fixedBytes + proofBytes\n        // V2 has an extra 32 bytes for payable address\n        uint totalFixedBytes = txType == 2 ? uint(validateProofBytes).add(32) : validateProofBytes;\n        uint proofBytes = _outboundProofType == 2 ? _payloadSize.add(fpBytes) : _payloadSize.add(mptOverhead);\n        uint totalCallDataBytes = totalFixedBytes.add(proofBytes);\n\n        uint16 dstChainId = _dstChainId; // stack too deep\n        (uint fee, uint128 priceRatio) = priceFeed.estimateFeeByChain(dstChainId, totalCallDataBytes, dstConfig.baseGas.add(extraGas));\n        uint airdropAmount = dstNativeAmt.mul(priceRatio).div(10**10);\n        return fee.add(airdropAmount).mul(multiplierBps).div(10000);\n    }\n\n    function getFee(uint16 _dstChainId, uint16 _outboundProofType, address _userApplication, uint _payloadSize, bytes calldata _adapterParams) external view override returns (uint) {\n        require(_payloadSize <= 10000, \"Relayer: _payloadSize tooooo big\");\n        return _getPrices(_dstChainId, _outboundProofType, _userApplication, _payloadSize, _adapterParams);\n    }\n\n    // view function to convert pricefeed price to current price (for backwards compatibility)\n    function dstPriceLookup(uint16 _dstChainId) public view returns (DstPrice memory) {\n        ILayerZeroPriceFeed.Price memory price = priceFeed.getPrice(_dstChainId);\n        return DstPrice(price.priceRatio, price.gasPriceInUnit);\n    }\n\n    function isApproved(address _relayerAddress) public view returns (bool) {\n        return approvedAddresses[_relayerAddress];\n    }\n\n    function assignJob(uint16 _dstChainId, uint16 _outboundProofType, address _userApplication, uint _payloadSize, bytes calldata _adapterParams) external override returns (uint) {\n        require(msg.sender == address(uln), \"Relayer: invalid uln\");\n        require(_payloadSize <= 10000, \"Relayer: _payloadSize tooooo big\");\n        uint fee = _getPrices(_dstChainId, _outboundProofType, _userApplication, _payloadSize, _adapterParams);\n        emit AssignJob(fee);\n        return fee;\n    }\n\n    function withdrawFee(address payable _to, uint _amount) external override onlyApproved {\n        uint totalFee = uln.accruedNativeFee(address(this));\n        require(_amount <= totalFee, \"Relayer: not enough fee for withdrawal\");\n        uln.withdrawNative(_to, _amount);\n    }\n\n    function withdrawToken(address _token, address _to, uint _amount) external onlyApproved {\n        uint total = IERC20(_token).balanceOf(address(this));\n        require(_amount <= total, \"Relayer: not enough fee for withdrawal\");\n        IERC20(_token).transfer(_to, _amount);\n    }\n\n    function validateTransactionProofV2(uint16 _srcChainId, address _dstAddress, uint _gasLimit, bytes32 _blockHash, bytes32 _data, bytes calldata _transactionProof, address payable _to) external payable onlyApproved nonReentrant {\n        (bool sent, ) = _to.call{value: msg.value}(\"\");\n        //require(sent, \"Relayer: failed to send ether\");\n        if (!sent) {\n            emit ValueTransferFailed(_to, msg.value);\n        }\n        uln.validateTransactionProof(_srcChainId, _dstAddress, _gasLimit, _blockHash, _data, _transactionProof);\n    }\n\n    function validateTransactionProofV1(uint16 _srcChainId, address _dstAddress, uint _gasLimit, bytes32 _blockHash, bytes32 _data, bytes calldata _transactionProof) external onlyApproved nonReentrant {\n        uln.validateTransactionProof(_srcChainId, _dstAddress, _gasLimit, _blockHash, _data, _transactionProof);\n    }\n}\n"
    },
    "contracts/RelayerV2Radar.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\n\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"hardhat-deploy/solc_0.7/proxy/Proxied.sol\";\n\nimport \"./interfaces/ILayerZeroRelayerV2.sol\";\nimport \"./interfaces/ILayerZeroRelayerV2PriceData.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV2.sol\";\nimport \"./interfaces/ILayerZeroPriceFeed.sol\";\n\n// RelayerV2Radar has an instance of RelayerV2.\n// It does not need to set prices.\n// it has view functions that use the internal RelayerV2 price data.\ncontract RelayerV2Radar is ReentrancyGuard, OwnableUpgradeable, Proxied, ILayerZeroRelayerV2, ILayerZeroRelayerV2PriceData {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n    using SafeMath for uint128;\n    using SafeMath for uint64;\n\n    ILayerZeroUltraLightNodeV2 public uln; // UltraLightNodeV2Radar\n    ILayerZeroRelayerV2PriceData public relayerV2;\n\n    address public stargateBridgeAddress;\n\n    //    struct DstPrice {\n    //        uint128 dstPriceRatio; // 10^10\n    //        uint128 dstGasPriceInWei;\n    //    }\n    //\n    //    struct DstConfig {\n    //        uint128 dstNativeAmtCap;\n    //        uint64 baseGas;\n    //        uint64 gasPerByte;\n    //    }\n\n    //    // [_chainId] => DstPriceData. change often\n    //    mapping(uint16 => RelayerV2.DstPrice) public dstPriceLookup;\n    //    // [_chainId][_outboundProofType] => DstConfig. change much less often\n    //    mapping(uint16 => mapping(uint16 => RelayerV2.DstConfig)) public dstConfigLookup;\n    mapping(address => bool) public approvedAddresses;\n\n    event Withdraw(address to, uint amount);\n    event ApproveAddress(address addr, bool approved);\n    event AssignJob(uint totalFee);\n    event ValueTransferFailed(address indexed to, uint indexed quantity);\n    event SetDstPrice(uint16 chainId, uint128 dstPriceRatio, uint128 dstGasPriceInWei);\n    event SetDstConfig(uint16 chainId, uint16 outboundProofType, uint128 dstNativeAmtCap, uint64 baseGas, uint64 gasPerByte);\n\n    // new pauseable relayer\n    bool public paused;\n\n    // map of legacyChainid => v2 chainId. allows lookup thru to RelayerV2 contract (which is updated frequently)\n    mapping(uint16 => uint16) public legacyToV2ChainId; // legacy ChainId => v2 chainId\n\n    // Upgrade\n    ILayerZeroPriceFeed public priceFeed;\n    // all encoded param bytes except for proof for validateTransactionProofV1\n    uint128 public multiplierBps;\n    uint16 public validateProofBytes;\n    uint16 public fpBytes;\n    uint16 public mptOverhead; // average overhead for mpt\n\n    // owner is always approved\n    modifier onlyApproved() {\n        if (owner() != msg.sender) {\n            require(isApproved(msg.sender), \"Relayer: not approved\");\n        }\n        _;\n    }\n\n    function initialize(address _ulnRadar, address _relayerV2, address _priceFeed) public proxied initializer {\n        __Ownable_init();\n        uln = ILayerZeroUltraLightNodeV2(_ulnRadar);\n        setApprovedAddress(address(this), true);\n\n        relayerV2 = ILayerZeroRelayerV2PriceData(_relayerV2);\n\n        legacyToV2ChainId[1] = 101;    // ethereum\n        legacyToV2ChainId[2] = 102;    // bsc\n        legacyToV2ChainId[12] = 112;   // fantom\n\n        priceFeed = ILayerZeroPriceFeed(_priceFeed);\n        validateProofBytes = 164;\n        fpBytes = 160;\n        mptOverhead = 500;\n    }\n\n    function onUpgrade(address _priceFeed) public proxied {\n        multiplierBps = 12000;\n        priceFeed = ILayerZeroPriceFeed(_priceFeed);\n        validateProofBytes = 164;\n        fpBytes = 160;\n        mptOverhead = 500;\n    }\n\n    function getV2ChainId(uint16 _legacyChainId) public view returns (uint16){\n        require(legacyToV2ChainId[_legacyChainId] != 0, \"getLegacyChainId(): lookup not found\");\n        return legacyToV2ChainId[_legacyChainId];\n    }\n\n    //----------------------------------------------------------------------------------\n    // onlyApproved\n\n    function setDstPrice(uint16 _chainId, uint128 _dstPriceRatio, uint128 _dstGasPriceInWei) external onlyApproved {\n        //        dstPriceLookup[_chainId] = DstPrice(_dstPriceRatio, _dstGasPriceInWei);\n        //        emit SetDstPrice(_chainId, _dstPriceRatio, _dstGasPriceInWei);\n    }\n\n    function setPriceFeed(address _priceFeed) external onlyApproved {\n        priceFeed = ILayerZeroPriceFeed(_priceFeed);\n    }\n\n    function setPriceMultiplierBps(uint128 _multiplierBps) external onlyApproved {\n        multiplierBps = _multiplierBps;\n    }\n\n    function setDstConfig(uint16 _chainId, uint16 _outboundProofType, uint128 _dstNativeAmtCap, uint64 _baseGas, uint64 _gasPerByte) external onlyApproved {\n        //        dstConfigLookup[_chainId][_outboundProofType] = DstConfig(_dstNativeAmtCap, _baseGas, _gasPerByte);\n        //        emit SetDstConfig(_chainId, _outboundProofType, _dstNativeAmtCap, _baseGas, _gasPerByte);\n    }\n\n    function dstPriceLookup(uint16 _legacyChainId) public view override returns (ILayerZeroRelayerV2PriceData.DstPrice memory) {\n        return relayerV2.dstPriceLookup(getV2ChainId(_legacyChainId));\n    }\n\n    function dstConfigLookup(uint16 _legacyChainId, uint16 _outboundProofType) public view override returns (ILayerZeroRelayerV2PriceData.DstConfig memory) {\n        return relayerV2.dstConfigLookup(getV2ChainId(_legacyChainId), _outboundProofType);\n    }\n\n    function setStargateAddress(address _stargateAddress) external onlyApproved {\n        stargateBridgeAddress = _stargateAddress;\n    }\n\n    //----------------------------------------------------------------------------------\n    // onlyOwner\n\n    function setApprovedAddress(address _relayerAddress, bool _approve) public onlyOwner {\n        approvedAddresses[_relayerAddress] = _approve;\n        emit ApproveAddress(_relayerAddress, _approve);\n    }\n\n    function setPause(bool _paused) public onlyOwner {\n        paused = _paused;\n    }\n\n    // txType 1\n    // bytes  [2       32      ]\n    // fields [txType  extraGas]\n    // txType 2\n    // bytes  [2       32        32            bytes[]         ]\n    // fields [txType  extraGas  dstNativeAmt  dstNativeAddress]\n    // User App Address is not used in this version\n    function _getPrices(uint16 _dstChainId, uint16 _outboundProofType, address, uint _payloadSize, bytes memory _adapterParameters) internal view returns (uint) {\n        require(!paused, \"Admin: paused\");\n        // decoding the _adapterParameters - reverts if type 2 and there is no dstNativeAddress\n        require(_adapterParameters.length == 34 || _adapterParameters.length > 66, \"Relayer: wrong _adapterParameters size\");\n        uint16 txType;\n        uint extraGas;\n        assembly {\n            txType := mload(add(_adapterParameters, 2))\n            extraGas := mload(add(_adapterParameters, 34))\n        }\n        require(extraGas > 0, \"Relayer: gas too low\");\n        require(txType == 1 || txType == 2, \"Relayer: unsupported txType\");\n\n        DstConfig memory dstConfig = dstConfigLookup(_dstChainId, _outboundProofType);\n\n        uint dstNativeAmt = 0;\n        if (txType == 2) {\n            assembly {\n                dstNativeAmt := mload(add(_adapterParameters, 66))\n            }\n            require(dstConfig.dstNativeAmtCap >= dstNativeAmt, \"Relayer: dstNativeAmt too large\");\n        }\n\n        // validateTransactionProof bytes = fixedBytes + proofBytes\n        // V2 has an extra 32 bytes for payable address\n        uint totalFixedBytes = txType == 2 ? uint(validateProofBytes).add(32) : validateProofBytes;\n        uint proofBytes = _outboundProofType == 2 ? _payloadSize.add(fpBytes) : _payloadSize.add(mptOverhead);\n        uint totalCallDataBytes = totalFixedBytes.add(proofBytes);\n\n        uint16 dstChainId = _dstChainId; // stack too deep\n        (uint fee, uint128 priceRatio) = priceFeed.estimateFeeByChain(getV2ChainId(dstChainId), totalCallDataBytes, dstConfig.baseGas.add(extraGas));\n        uint airdropAmount = dstNativeAmt.mul(priceRatio).div(10**10);\n        return fee.add(airdropAmount).mul(multiplierBps).div(10000);\n    }\n\n    function getFee(uint16 _dstChainId, uint16 _outboundProofType, address _userApplication, uint _payloadSize, bytes calldata _adapterParams) external view override returns (uint) {\n        require(_payloadSize <= 10000, \"Relayer: _payloadSize tooooo big\");\n        return _getPrices(_dstChainId, _outboundProofType, _userApplication, _payloadSize, _adapterParams);\n    }\n\n    function isApproved(address _relayerAddress) public view returns (bool) {\n        return approvedAddresses[_relayerAddress];\n    }\n\n    function assignJob(uint16 _dstChainId, uint16 _outboundProofType, address _userApplication, uint _payloadSize, bytes calldata _adapterParams) external override returns (uint) {\n        require(msg.sender == address(uln), \"Relayer: invalid uln\");\n        require(_payloadSize <= 10000, \"Relayer: _payloadSize tooooo big\");\n        uint fee = _getPrices(_dstChainId, _outboundProofType, _userApplication, _payloadSize, _adapterParams);\n        emit AssignJob(fee);\n        return fee;\n    }\n\n    function withdrawFee(address payable _to, uint _amount) external override onlyApproved {\n        uint totalFee = uln.accruedNativeFee(address(this));\n        require(_amount <= totalFee, \"Relayer: not enough fee for withdrawal\");\n        uln.withdrawNative(_to, _amount);\n    }\n\n    function validateTransactionProofV2(uint16 _srcChainId, address _dstAddress, uint _gasLimit, bytes32 _blockHash, bytes32 _data, bytes calldata _transactionProof, address payable _to) external payable onlyApproved nonReentrant {\n        (bool sent, ) = _to.call{value: msg.value}(\"\");\n        //require(sent, \"Relayer: failed to send ether\");\n        if (!sent) {\n            emit ValueTransferFailed(_to, msg.value);\n        }\n        uln.validateTransactionProof(_srcChainId, _dstAddress, _gasLimit, _blockHash, _data, _transactionProof);\n    }\n\n    function validateTransactionProofV1(uint16 _srcChainId, address _dstAddress, uint _gasLimit, bytes32 _blockHash, bytes32 _data, bytes calldata _transactionProof) external onlyApproved nonReentrant {\n        uln.validateTransactionProof(_srcChainId, _dstAddress, _gasLimit, _blockHash, _data, _transactionProof);\n    }\n}"
    },
    "contracts/Treasury.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"./interfaces/ILayerZeroTreasury.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV1.sol\";\n\ncontract Treasury is ILayerZeroTreasury, Ownable {\n    using SafeMath for uint;\n\n    uint public nativeBP;\n    uint public zroFee;\n    bool public feeEnabled;\n    bool public zroEnabled;\n\n    ILayerZeroUltraLightNodeV1 public immutable uln;\n\n    event NativeBP(uint bp);\n    event ZroFee(uint zroFee);\n    event FeeEnabled(bool feeEnabled);\n    event ZroEnabled(bool zroEnabled);\n\n    constructor(address _uln) {\n        uln = ILayerZeroUltraLightNodeV1(_uln);\n    }\n\n    function getFees(bool payInZro, uint relayerFee, uint oracleFee) external view override returns (uint) {\n        if (feeEnabled) {\n            if (payInZro) {\n                require(zroEnabled, \"LayerZero: ZRO is not enabled\");\n                return zroFee;\n            } else {\n                return relayerFee.add(oracleFee).mul(nativeBP).div(10000);\n            }\n        }\n        return 0;\n    }\n\n    function setFeeEnabled(bool _feeEnabled) external onlyOwner {\n        feeEnabled = _feeEnabled;\n        emit FeeEnabled(_feeEnabled);\n    }\n\n    function setZroEnabled(bool _zroEnabled) external onlyOwner {\n        zroEnabled = _zroEnabled;\n        emit ZroEnabled(_zroEnabled);\n    }\n\n    function setNativeBP(uint _nativeBP) external onlyOwner {\n        nativeBP = _nativeBP;\n        emit NativeBP(_nativeBP);\n    }\n\n    function setZroFee(uint _zroFee) external onlyOwner {\n        zroFee = _zroFee;\n        emit ZroFee(_zroFee);\n    }\n\n    //    uint8 public constant WITHDRAW_TYPE_TREASURY_PROTOCOL_FEES = 0;\n    function withdrawZROFromULN(address _to, uint _amount) external onlyOwner {\n        uln.withdrawZRO(_to, _amount);\n    }\n\n    //    uint8 public constant WITHDRAW_TYPE_TREASURY_PROTOCOL_FEES = 0;\n    function withdrawNativeFromULN(address payable _to, uint _amount) external onlyOwner {\n        uln.withdrawNative(0, address(0x0), _to, _amount);\n    }\n}\n"
    },
    "contracts/TreasuryV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/ILayerZeroTreasury.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV2.sol\";\n\ncontract TreasuryV2 is ILayerZeroTreasury, Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    uint public nativeBP;\n    uint public zroFee;\n    bool public feeEnabled;\n    bool public zroEnabled;\n\n    ILayerZeroUltraLightNodeV2 public uln;\n\n    event NativeBP(uint bp);\n    event ZroFee(uint zroFee);\n    event FeeEnabled(bool feeEnabled);\n    event ZroEnabled(bool zroEnabled);\n\n    constructor(address _ulnv2) {\n        uln = ILayerZeroUltraLightNodeV2(_ulnv2);\n    }\n\n    function getFees(bool payInZro, uint relayerFee, uint oracleFee) external view override returns (uint) {\n        if (feeEnabled) {\n            if (payInZro) {\n                require(zroEnabled, \"LayerZero: ZRO is not enabled\");\n                return zroFee;\n            } else {\n                return relayerFee.add(oracleFee).mul(nativeBP).div(10000);\n            }\n        }\n        return 0;\n    }\n\n    function setFeeEnabled(bool _feeEnabled) external onlyOwner {\n        feeEnabled = _feeEnabled;\n        emit FeeEnabled(_feeEnabled);\n    }\n\n    function setZroEnabled(bool _zroEnabled) external onlyOwner {\n        zroEnabled = _zroEnabled;\n        emit ZroEnabled(_zroEnabled);\n    }\n\n    function setNativeBP(uint _nativeBP) external onlyOwner {\n        nativeBP = _nativeBP;\n        emit NativeBP(_nativeBP);\n    }\n\n    function setZroFee(uint _zroFee) external onlyOwner {\n        zroFee = _zroFee;\n        emit ZroFee(_zroFee);\n    }\n\n    function withdrawZROFromULN(address _to, uint _amount) external onlyOwner {\n        uln.withdrawZRO(_to, _amount);\n    }\n\n    function withdrawNativeFromULN(address payable _to, uint _amount) external onlyOwner {\n        uln.withdrawNative(_to, _amount);\n    }\n\n    function withdrawToken(address _token, address _to, uint _amount) external onlyOwner {\n        IERC20(_token).safeTransfer(_to, _amount);\n    }\n}\n"
    },
    "contracts/TreasuryV2Radar.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"./interfaces/ILayerZeroTreasury.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV2.sol\";\n\ncontract TreasuryV2Radar is ILayerZeroTreasury, Ownable {\n    using SafeMath for uint;\n\n    uint public nativeBP;\n    uint public zroFee;\n    bool public feeEnabled;\n    bool public zroEnabled;\n\n    ILayerZeroUltraLightNodeV2 public uln;\n\n    event NativeBP(uint bp);\n    event ZroFee(uint zroFee);\n    event FeeEnabled(bool feeEnabled);\n    event ZroEnabled(bool zroEnabled);\n\n    constructor(address _ulnv2) {\n        uln = ILayerZeroUltraLightNodeV2(_ulnv2);\n    }\n\n    function getFees(bool payInZro, uint relayerFee, uint oracleFee) external view override returns (uint) {\n        if (feeEnabled) {\n            if (payInZro) {\n                require(zroEnabled, \"LayerZero: ZRO is not enabled\");\n                return zroFee;\n            } else {\n                return relayerFee.add(oracleFee).mul(nativeBP).div(10000);\n            }\n        }\n        return 0;\n    }\n\n    function setFeeEnabled(bool _feeEnabled) external onlyOwner {\n        feeEnabled = _feeEnabled;\n        emit FeeEnabled(_feeEnabled);\n    }\n\n    function setZroEnabled(bool _zroEnabled) external onlyOwner {\n        zroEnabled = _zroEnabled;\n        emit ZroEnabled(_zroEnabled);\n    }\n\n    function setNativeBP(uint _nativeBP) external onlyOwner {\n        nativeBP = _nativeBP;\n        emit NativeBP(_nativeBP);\n    }\n\n    function setZroFee(uint _zroFee) external onlyOwner {\n        zroFee = _zroFee;\n        emit ZroFee(_zroFee);\n    }\n\n    function withdrawZROFromULN(address _to, uint _amount) external onlyOwner {\n        uln.withdrawZRO(_to, _amount);\n    }\n\n    function withdrawNativeFromULN(address payable _to, uint _amount) external onlyOwner {\n        uln.withdrawNative(_to, _amount);\n    }\n}"
    },
    "contracts/UltraLightNode.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./interfaces/ILayerZeroValidationLibrary.sol\";\nimport \"./interfaces/ILayerZeroMessagingLibrary.sol\";\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroRelayer.sol\";\nimport \"./interfaces/ILayerZeroTreasury.sol\";\nimport \"./interfaces/ILayerZeroOracle.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV1.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\n\ncontract UltraLightNode is ILayerZeroMessagingLibrary, ILayerZeroUltraLightNodeV1, ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    struct BlockData {\n        uint confirmations;\n        bytes32 data;\n    }\n\n    // Application config\n    uint public constant CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION = 1;\n    uint public constant CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS = 2;\n    uint public constant CONFIG_TYPE_RELAYER = 3;\n    uint public constant CONFIG_TYPE_OUTBOUND_PROOF_TYPE = 4;\n    uint public constant CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS = 5;\n    uint public constant CONFIG_TYPE_ORACLE = 6;\n\n    struct ApplicationConfiguration {\n        uint16 inboundProofLibraryVersion;\n        uint64 inboundBlockConfirmations;\n        address relayer;\n        uint16 outboundProofType;\n        uint64 outboundBlockConfirmations;\n        address oracle;\n    }\n\n    // Token and Contracts\n    IERC20 public layerZeroToken;\n    ILayerZeroTreasury public treasuryContract;\n\n    // Fee management\n    uint public constant BP_DENOMINATOR = 10000;\n    // treasury and relayer share the protocol fee, either in native token or ZRO\n    uint8 public constant WITHDRAW_TYPE_TREASURY_PROTOCOL_FEES = 0;\n    uint8 public constant WITHDRAW_TYPE_ORACLE_QUOTED_FEES = 1; // quoted fee refers to the fee in block relaying\n    uint8 public constant WITHDRAW_TYPE_RELAYER_QUOTED_FEES = 2; //quoted fee refers the fee in msg relaying\n\n    mapping(address => uint) public oracleQuotedFees;\n    mapping(address => uint) public relayerQuotedFees;\n    uint public treasuryNativeFees;\n    uint public treasuryZROFees;\n\n    // User Application\n    mapping(address => mapping(uint16 => ApplicationConfiguration)) public appConfig; // app address => chainId => config\n    mapping(uint16 => ApplicationConfiguration) public defaultAppConfig; // default UA settings if no version specified\n    mapping(uint16 => mapping(uint16 => bytes)) public defaultAdapterParams;\n\n    // Validation\n    mapping(uint16 => mapping(uint16 => address)) public inboundProofLibrary; // chainId => library Id => inboundProofLibrary contract\n    mapping(uint16 => uint16) public maxInboundProofLibrary; // chainId => inboundProofLibrary\n    mapping(uint16 => mapping(uint16 => bool)) public supportedOutboundProof; // chainId => outboundProofType => enabled\n    mapping(uint16 => uint) public chainAddressSizeMap;\n    mapping(address => mapping(uint16 => mapping(bytes32 => BlockData))) public hashLookup;\n    mapping(uint16 => bytes32) public ulnLookup; // remote ulns\n\n    ILayerZeroEndpoint public immutable endpoint;\n\n    // Events\n    event AppConfigUpdated(address userApplication, uint configType, bytes newConfig);\n    event AddInboundProofLibraryForChain(uint16 chainId, address lib);\n    event EnableSupportedOutboundProof(uint16 chainId, uint16 proofType);\n    event HashReceived(uint16 srcChainId, address oracle, uint confirmations, bytes32 blockhash);\n    event Packet(uint16 chainId, bytes payload);\n    event RelayerParams(uint16 chainId, uint64 nonce, uint16 outboundProofType, bytes adapterParams);\n    event SetChainAddressSize(uint16 chainId, uint size);\n    event SetDefaultConfigForChainId(uint16 chainId, uint16 inboundProofLib, uint64 inboundBlockConfirm, address relayer, uint16 outboundProofType, uint16 outboundBlockConfirm, address oracle);\n    event SetDefaultAdapterParamsForChainId(uint16 chainId, uint16 proofType, bytes adapterParams);\n    event SetLayerZeroToken(address tokenAddress);\n    event SetRelayerFeeContract(address relayerFeeContract);\n    event SetRemoteUln(uint16 chainId, bytes32 uln);\n    event SetTreasury(address treasuryAddress);\n    event WithdrawZRO(address _msgSender, address _to, uint _amount);\n    event WithdrawNative(uint8 _type, address _owner, address _msgSender, address _to, uint _amount);\n\n    constructor(address _endpoint) {\n        require(_endpoint != address(0x0), \"LayerZero: endpoint cannot be zero address\");\n        endpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    // only the endpoint can call SEND() and setConfig()\n    modifier onlyEndpoint() {\n        require(address(endpoint) == msg.sender, \"LayerZero: only endpoint\");\n        _;\n    }\n\n    //----------------------------------------------------------------------------------\n    // PROTOCOL\n\n    // This function completes delivery of a LayerZero message.\n    //\n    // In order to deliver the message, this function:\n    // (a) takes the _transactionProof submitted by UA's relayer, and\n    // (b) retrieve UA's validation library\n    // (c) takes the _blockData submitted by the UA's oracle given the their configuration (and blockConfirmations),\n    // (d) decodes using UA's validation library using (a) and (c)\n    //  then, this functions asserts that\n    // (e) the payload originated from the known Ultra Light Node from source chain, and\n    // (f) the _dstAddress the specified destination contract\n    function validateTransactionProof(uint16 _srcChainId, address _dstAddress, uint _gasLimit, bytes32 _lookupHash, bytes calldata _transactionProof) external override {\n        // retrieve UA's configuration using the _dstAddress from arguments.\n        ApplicationConfiguration memory uaConfig = getAppConfig(_srcChainId, _dstAddress);\n\n        // (a) assert that the caller == UA's relayer\n        require(uaConfig.relayer == msg.sender, \"LayerZero: invalid relayer\");\n\n        LayerZeroPacket.Packet memory _packet;\n        {\n            // (b) retrieve UA's validation library\n            address inboundProofLib = inboundProofLibrary[_srcChainId][uaConfig.inboundProofLibraryVersion];\n\n            // (c) assert that the data submitted by UA's oracle have no fewer confirmations than UA's configuration\n            BlockData storage blockData = hashLookup[uaConfig.oracle][_srcChainId][_lookupHash];\n            require(blockData.confirmations >= uaConfig.inboundBlockConfirmations, \"LayerZero: not enough block confirmations\");\n\n            // (d) decode\n            uint remoteAddressSize = chainAddressSizeMap[_srcChainId];\n            _packet = ILayerZeroValidationLibrary(inboundProofLib).validateProof(blockData.data, _transactionProof, remoteAddressSize);\n        }\n\n        // (e) assert that the packet was emitted by the source ultra light node\n        require(ulnLookup[_srcChainId] == _packet.ulnAddress, \"LayerZero: _packet.ulnAddress is invalid\");\n\n        // (f) assert that the _packet._dstAddress == the _dstAddress specified by the UAs message\n        require(_packet.dstAddress == _dstAddress, \"LayerZero: invalid dst address\");\n\n        // publish the payload and _gasLimit to the endpoint for calling lzReceive at _dstAddress\n        endpoint.receivePayload(_packet.srcChainId, _packet.srcAddress, _packet.dstAddress, _packet.nonce, _gasLimit, _packet.payload);\n    }\n\n    // Called (by the Endpoint) with the information required to send a LayerZero message for a User Application.\n    // This function:\n    // (a) pays the protocol (native token or ZRO), oracle (native token) and relayer (native token) for their roles in sending the message.\n    // (b) generates the message payload and emits events of the message and adapterParams\n    // (c) notifies the oracle\n    function send(address _ua, uint64 _nonce, uint16 _chainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable override onlyEndpoint {\n        ApplicationConfiguration memory uaConfig = getAppConfig(_chainId, _ua);\n        address ua = _ua;\n        uint64 nonce = _nonce;\n        uint16 chainId = _chainId;\n        require(ulnLookup[chainId] != bytes32(0), \"LayerZero: chainId does not exist\");\n\n        uint totalNativeFee;\n        {\n            uint oracleFee;\n            // (a - 1), pay the oracle\n            {\n                oracleFee = ILayerZeroOracle(uaConfig.oracle).getPrice(chainId, uaConfig.outboundProofType);\n                oracleQuotedFees[uaConfig.oracle] = oracleQuotedFees[uaConfig.oracle].add(oracleFee);\n            }\n\n            // (a - 2), pay the relayer\n            {\n                uint payloadSize = _payload.length;\n                ILayerZeroRelayer relayer = ILayerZeroRelayer(uaConfig.relayer);\n                if (_adapterParams.length == 0) {\n                    bytes memory defaultAdaptorParam = defaultAdapterParams[chainId][uaConfig.outboundProofType];\n                    totalNativeFee = relayer.getPrice(chainId, uaConfig.outboundProofType, ua, payloadSize, defaultAdaptorParam);\n                    relayer.notifyRelayer(chainId, uaConfig.outboundProofType, defaultAdaptorParam);\n                } else {\n                    totalNativeFee = relayer.getPrice(chainId, uaConfig.outboundProofType, ua, payloadSize, _adapterParams);\n                    relayer.notifyRelayer(chainId, uaConfig.outboundProofType, _adapterParams);\n                }\n                relayerQuotedFees[uaConfig.relayer] = relayerQuotedFees[uaConfig.relayer].add(totalNativeFee); // totalNativeFee == relayerFee here\n\n                // emit the param events\n                emit RelayerParams(chainId, nonce, uaConfig.outboundProofType, _adapterParams);\n            }\n\n            // (a - 3), pay the protocol\n            {\n                // if no ZRO token or not specifying a payment address, pay in native token\n                bool payInNative = _zroPaymentAddress == address(0x0) || address(layerZeroToken) == address(0x0);\n                uint protocolFee = treasuryContract.getFees(!payInNative, totalNativeFee, oracleFee); // totalNativeFee == relayerFee here\n\n                if (protocolFee > 0) {\n                    if (payInNative) {\n                        treasuryNativeFees = treasuryNativeFees.add(protocolFee);\n                        totalNativeFee = totalNativeFee.add(protocolFee);\n                    } else {\n                        // zro payment address must equal the _ua or the tx.origin otherwise the transaction reverts\n                        require(_zroPaymentAddress == ua || _zroPaymentAddress == tx.origin, \"LayerZero: must be paid by sender or origin\");\n\n                        // transfer the LayerZero token to this contract from the payee\n                        layerZeroToken.safeTransferFrom(_zroPaymentAddress, address(this), protocolFee);\n\n                        treasuryZROFees = treasuryZROFees.add(protocolFee);\n                    }\n                }\n            }\n\n            totalNativeFee = totalNativeFee.add(oracleFee);\n        }\n\n        // (b) emit payload and the adapterParams if any\n        {\n            bytes memory encodedPayload = abi.encodePacked(nonce, ua, _destination, _payload);\n            emit Packet(chainId, encodedPayload);\n            // (c) notify the oracle\n            ILayerZeroOracle(uaConfig.oracle).notifyOracle(chainId, uaConfig.outboundProofType, uaConfig.outboundBlockConfirmations);\n        }\n\n        require(totalNativeFee <= msg.value, \"LayerZero: not enough native for fees\");\n        // refund if they send too much\n        uint amount = msg.value.sub(totalNativeFee);\n        if (amount > 0) {\n            (bool success, ) = _refundAddress.call{value: amount}(\"\");\n            require(success, \"LayerZero: failed to refund\");\n        }\n    }\n\n    // Can be called by any address to update a block header\n    // can only upload new block data or the same block data with more confirmations\n    function updateHash(uint16 _srcChainId, bytes32 _lookupHash, uint _confirmations, bytes32 _data) external override {\n        // this function may revert with a default message if the oracle address is not an ILayerZeroOracle\n        BlockData storage bd = hashLookup[msg.sender][_srcChainId][_lookupHash];\n        // if it has a record, requires a larger confirmation.\n        require(bd.confirmations < _confirmations, \"LayerZero: oracle data can only update if it has more confirmations\");\n\n        // set the new information into storage\n        bd.confirmations = _confirmations;\n        bd.data = _data;\n\n        emit HashReceived(_srcChainId, msg.sender, _confirmations, _lookupHash);\n    }\n\n    //----------------------------------------------------------------------------------\n    // Other Library Interfaces\n\n    // default to DEFAULT setting if ZERO value\n    function getAppConfig(uint16 _chainId, address userApplicationAddress) public view returns (ApplicationConfiguration memory) {\n        ApplicationConfiguration memory config = appConfig[userApplicationAddress][_chainId];\n        ApplicationConfiguration storage defaultConfig = defaultAppConfig[_chainId];\n\n        if (config.inboundProofLibraryVersion == 0) {\n            config.inboundProofLibraryVersion = defaultConfig.inboundProofLibraryVersion;\n        }\n\n        if (config.inboundBlockConfirmations == 0) {\n            config.inboundBlockConfirmations = defaultConfig.inboundBlockConfirmations;\n        }\n\n        if (config.relayer == address(0x0)) {\n            config.relayer = defaultConfig.relayer;\n        }\n\n        if (config.outboundProofType == 0) {\n            config.outboundProofType = defaultConfig.outboundProofType;\n        }\n\n        if (config.outboundBlockConfirmations == 0) {\n            config.outboundBlockConfirmations = defaultConfig.outboundBlockConfirmations;\n        }\n\n        if (config.oracle == address(0x0)) {\n            config.oracle = defaultConfig.oracle;\n        }\n\n        return config;\n    }\n\n    function setConfig(uint16 chainId, address _ua, uint _configType, bytes calldata _config) external override onlyEndpoint {\n        ApplicationConfiguration storage uaConfig = appConfig[_ua][chainId];\n        if (_configType == CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION) {\n            uint16 inboundProofLibraryVersion = abi.decode(_config, (uint16));\n            require(inboundProofLibraryVersion <= maxInboundProofLibrary[chainId], \"LayerZero: invalid inbound proof library version\");\n            uaConfig.inboundProofLibraryVersion = inboundProofLibraryVersion;\n        } else if (_configType == CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS) {\n            uint64 blockConfirmations = abi.decode(_config, (uint64));\n            uaConfig.inboundBlockConfirmations = blockConfirmations;\n        } else if (_configType == CONFIG_TYPE_RELAYER) {\n            address relayer = abi.decode(_config, (address));\n            uaConfig.relayer = relayer;\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_PROOF_TYPE) {\n            uint16 outboundProofType = abi.decode(_config, (uint16));\n            require(supportedOutboundProof[chainId][outboundProofType] || outboundProofType == 0, \"LayerZero: invalid outbound proof type\");\n            uaConfig.outboundProofType = outboundProofType;\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS) {\n            uint64 blockConfirmations = abi.decode(_config, (uint64));\n            uaConfig.outboundBlockConfirmations = blockConfirmations;\n        } else if (_configType == CONFIG_TYPE_ORACLE) {\n            address oracle = abi.decode(_config, (address));\n            uaConfig.oracle = oracle;\n        } else {\n            revert(\"LayerZero: Invalid config type\");\n        }\n\n        emit AppConfigUpdated(_ua, _configType, _config);\n    }\n\n    function getConfig(uint16 _chainId, address userApplicationAddress, uint _configType) external view override returns (bytes memory) {\n        ApplicationConfiguration storage uaConfig = appConfig[userApplicationAddress][_chainId];\n\n        if (_configType == CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION) {\n            if (uaConfig.inboundProofLibraryVersion == 0) {\n                return abi.encode(defaultAppConfig[_chainId].inboundProofLibraryVersion);\n            }\n            return abi.encode(uaConfig.inboundProofLibraryVersion);\n        } else if (_configType == CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS) {\n            if (uaConfig.inboundBlockConfirmations == 0) {\n                return abi.encode(defaultAppConfig[_chainId].inboundBlockConfirmations);\n            }\n            return abi.encode(uaConfig.inboundBlockConfirmations);\n        } else if (_configType == CONFIG_TYPE_RELAYER) {\n            if (uaConfig.relayer == address(0x0)) {\n                return abi.encode(defaultAppConfig[_chainId].relayer);\n            }\n            return abi.encode(uaConfig.relayer);\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_PROOF_TYPE) {\n            if (uaConfig.outboundProofType == 0) {\n                return abi.encode(defaultAppConfig[_chainId].outboundProofType);\n            }\n            return abi.encode(uaConfig.outboundProofType);\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS) {\n            if (uaConfig.outboundBlockConfirmations == 0) {\n                return abi.encode(defaultAppConfig[_chainId].outboundBlockConfirmations);\n            }\n            return abi.encode(uaConfig.outboundBlockConfirmations);\n        } else if (_configType == CONFIG_TYPE_ORACLE) {\n            if (uaConfig.oracle == address(0x0)) {\n                return abi.encode(defaultAppConfig[_chainId].oracle);\n            }\n            return abi.encode(uaConfig.oracle);\n        } else {\n            revert(\"LayerZero: Invalid config type\");\n        }\n    }\n\n    // returns the native fee the UA pays to cover fees\n    function estimateFees(uint16 _chainId, address _ua, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParams) external view override returns (uint nativeFee, uint zroFee) {\n        uint16 chainId = _chainId;\n        address ua = _ua;\n        uint payloadSize = _payload.length;\n        bytes memory adapterParam = _adapterParams;\n\n        ApplicationConfiguration memory uaConfig = getAppConfig(chainId, ua);\n\n        // Relayer Fee\n        uint relayerFee;\n        {\n            if (adapterParam.length == 0) {\n                bytes memory defaultAdaptorParam = defaultAdapterParams[chainId][uaConfig.outboundProofType];\n                relayerFee = ILayerZeroRelayer(uaConfig.relayer).getPrice(chainId, uaConfig.outboundProofType, ua, payloadSize, defaultAdaptorParam);\n            } else {\n                relayerFee = ILayerZeroRelayer(uaConfig.relayer).getPrice(chainId, uaConfig.outboundProofType, ua, payloadSize, adapterParam);\n            }\n        }\n\n        // Oracle Fee\n        uint oracleFee = ILayerZeroOracle(uaConfig.oracle).getPrice(chainId, uaConfig.outboundProofType);\n\n        // LayerZero Fee\n        {\n            uint protocolFee = treasuryContract.getFees(_payInZRO, relayerFee, oracleFee);\n            _payInZRO ? zroFee = protocolFee : nativeFee = protocolFee;\n        }\n\n        // return the sum of fees\n        nativeFee = nativeFee.add(relayerFee).add(oracleFee);\n    }\n\n    //---------------------------------------------------------------------------\n    // Claim Fees\n\n    // universal withdraw ZRO token function\n    function withdrawZRO(address _to, uint _amount) external override nonReentrant {\n        require(msg.sender == address(treasuryContract), \"LayerZero: only treasury\");\n        treasuryZROFees = treasuryZROFees.sub(_amount);\n        layerZeroToken.safeTransfer(_to, _amount);\n        emit WithdrawZRO(msg.sender, _to, _amount);\n    }\n\n    // universal withdraw native token function.\n    // the source contract should perform all the authentication control\n    // safemath overflow if the amount is not enough\n    function withdrawNative(uint8 _type, address _owner, address payable _to, uint _amount) external override nonReentrant {\n        if (_type == WITHDRAW_TYPE_TREASURY_PROTOCOL_FEES) {\n            require(msg.sender == address(treasuryContract), \"LayerZero:only treasury\");\n            treasuryNativeFees = treasuryNativeFees.sub(_amount);\n        } else if (_type == WITHDRAW_TYPE_ORACLE_QUOTED_FEES) {\n            oracleQuotedFees[msg.sender] = oracleQuotedFees[msg.sender].sub(_amount);\n        } else if (_type == WITHDRAW_TYPE_RELAYER_QUOTED_FEES) {\n            relayerQuotedFees[msg.sender] = relayerQuotedFees[msg.sender].sub(_amount);\n        } else {\n            revert(\"LayerZero: unsupported withdraw type\");\n        }\n\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"LayerZero: withdraw failed\");\n        emit WithdrawNative(_type, _owner, msg.sender, _to, _amount);\n    }\n\n    //---------------------------------------------------------------------------\n    // Owner calls, configuration only.\n    function setLayerZeroToken(address _layerZeroToken) external onlyOwner {\n        require(_layerZeroToken != address(0x0), \"LayerZero: _layerZeroToken cannot be zero address\");\n        layerZeroToken = IERC20(_layerZeroToken);\n        emit SetLayerZeroToken(_layerZeroToken);\n    }\n\n    function setTreasury(address _treasury) external onlyOwner {\n        require(_treasury != address(0x0), \"LayerZero: treasury cannot be zero address\");\n        treasuryContract = ILayerZeroTreasury(_treasury);\n        emit SetTreasury(_treasury);\n    }\n\n    function addInboundProofLibraryForChain(uint16 _chainId, address _library) external onlyOwner {\n        require(_library != address(0x0), \"LayerZero: library cannot be zero address\");\n        require(maxInboundProofLibrary[_chainId] < 65535, \"LayerZero: can not add new library\");\n        maxInboundProofLibrary[_chainId]++;\n        inboundProofLibrary[_chainId][maxInboundProofLibrary[_chainId]] = _library;\n        emit AddInboundProofLibraryForChain(_chainId, _library);\n    }\n\n    function enableSupportedOutboundProof(uint16 _chainId, uint16 _proofType) external onlyOwner {\n        supportedOutboundProof[_chainId][_proofType] = true;\n        emit EnableSupportedOutboundProof(_chainId, _proofType);\n    }\n\n    function setDefaultConfigForChainId(uint16 _chainId, uint16 _inboundProofLibraryVersion, uint64 _inboundBlockConfirmations, address _relayer, uint16 _outboundProofType, uint16 _outboundBlockConfirmations, address _oracle) external onlyOwner {\n        require(_inboundProofLibraryVersion <= maxInboundProofLibrary[_chainId] && _inboundProofLibraryVersion > 0, \"LayerZero: invalid inbound proof library version\");\n        require(_inboundBlockConfirmations > 0, \"LayerZero: invalid inbound block confirmation\");\n        require(_relayer != address(0x0), \"LayerZero: invalid relayer address\");\n        require(supportedOutboundProof[_chainId][_outboundProofType], \"LayerZero: invalid outbound proof type\");\n        require(_outboundBlockConfirmations > 0, \"LayerZero: invalid outbound block confirmation\");\n        require(_oracle != address(0x0), \"LayerZero: invalid oracle address\");\n        defaultAppConfig[_chainId] = ApplicationConfiguration(_inboundProofLibraryVersion, _inboundBlockConfirmations, _relayer, _outboundProofType, _outboundBlockConfirmations, _oracle);\n        emit SetDefaultConfigForChainId(_chainId, _inboundProofLibraryVersion, _inboundBlockConfirmations, _relayer, _outboundProofType, _outboundBlockConfirmations, _oracle);\n    }\n\n    function setDefaultAdapterParamsForChainId(uint16 _chainId, uint16 _proofType, bytes calldata _adapterParams) external onlyOwner {\n        defaultAdapterParams[_chainId][_proofType] = _adapterParams;\n        emit SetDefaultAdapterParamsForChainId(_chainId, _proofType, _adapterParams);\n    }\n\n    function setRemoteUln(uint16 _remoteChainId, bytes32 _remoteUln) external onlyOwner {\n        require(ulnLookup[_remoteChainId] == bytes32(0), \"LayerZero: remote uln already set\");\n        ulnLookup[_remoteChainId] = _remoteUln;\n        emit SetRemoteUln(_remoteChainId, _remoteUln);\n    }\n\n    function setChainAddressSize(uint16 _chainId, uint _size) external onlyOwner {\n        require(chainAddressSizeMap[_chainId] == 0, \"LayerZero: remote chain address size already set\");\n        chainAddressSizeMap[_chainId] = _size;\n        emit SetChainAddressSize(_chainId, _size);\n    }\n\n    //----------------------------------------------------------------------------------\n    // view functions\n    function getBlockHeaderData(address _oracle, uint16 _remoteChainId, bytes32 _lookupHash) external view returns (BlockData memory blockData) {\n        return hashLookup[_oracle][_remoteChainId][_lookupHash];\n    }\n\n    function oracleQuotedAmount(address _oracle) external view override returns (uint) {\n        return oracleQuotedFees[_oracle];\n    }\n\n    function relayerQuotedAmount(address _relayer) external view override returns (uint) {\n        return relayerQuotedFees[_relayer];\n    }\n}\n"
    },
    "contracts/UltraLightNodeV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./interfaces/ILayerZeroValidationLibrary.sol\";\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroTreasury.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\n// v2\nimport \"./interfaces/ILayerZeroMessagingLibraryV2.sol\";\nimport \"./interfaces/ILayerZeroOracleV2.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV2.sol\";\nimport \"./interfaces/ILayerZeroRelayerV2.sol\";\nimport \"./NonceContract.sol\";\n\ncontract UltraLightNodeV2 is ILayerZeroMessagingLibraryV2, ILayerZeroUltraLightNodeV2, ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    // Application config\n    uint public constant CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION = 1;\n    uint public constant CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS = 2;\n    uint public constant CONFIG_TYPE_RELAYER = 3;\n    uint public constant CONFIG_TYPE_OUTBOUND_PROOF_TYPE = 4;\n    uint public constant CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS = 5;\n    uint public constant CONFIG_TYPE_ORACLE = 6;\n\n    // Token and Contracts\n    IERC20 public layerZeroToken;\n    ILayerZeroTreasury public treasuryContract;\n\n    mapping(address => uint) public nativeFees;\n    uint public treasuryZROFees;\n\n    // User Application\n    mapping(address => mapping(uint16 => ApplicationConfiguration)) public appConfig; // app address => chainId => config\n    mapping(uint16 => ApplicationConfiguration) public defaultAppConfig; // default UA settings if no version specified\n    mapping(uint16 => mapping(uint16 => bytes)) public defaultAdapterParams;\n\n    // Validation\n    mapping(uint16 => mapping(uint16 => address)) public inboundProofLibrary; // chainId => library Id => inboundProofLibrary contract\n    mapping(uint16 => uint16) public maxInboundProofLibrary; // chainId => inboundProofLibrary\n    mapping(uint16 => mapping(uint16 => bool)) public supportedOutboundProof; // chainId => outboundProofType => enabled\n    mapping(uint16 => uint) public chainAddressSizeMap;\n    mapping(address => mapping(uint16 => mapping(bytes32 => mapping(bytes32 => uint)))) public hashLookup; //[oracle][srcChainId][blockhash][datahash] -> confirmation\n    mapping(uint16 => bytes32) public ulnLookup; // remote ulns\n\n    ILayerZeroEndpoint public immutable endpoint;\n    uint16 public immutable localChainId;\n    NonceContract public immutable nonceContract;\n\n    constructor(address _endpoint, address _nonceContract, uint16 _localChainId) {\n        require(_endpoint != address(0x0), \"LayerZero: endpoint cannot be zero address\");\n        require(_nonceContract != address(0x0), \"LayerZero: nonceContract cannot be zero address\");\n        ILayerZeroEndpoint lzEndpoint = ILayerZeroEndpoint(_endpoint);\n        localChainId = _localChainId;\n        endpoint = lzEndpoint;\n        nonceContract = NonceContract(_nonceContract);\n    }\n\n    // only the endpoint can call SEND() and setConfig()\n    modifier onlyEndpoint() {\n        require(address(endpoint) == msg.sender, \"LayerZero: only endpoint\");\n        _;\n    }\n\n    //----------------------------------------------------------------------------------\n    // PROTOCOL\n    function validateTransactionProof(uint16 _srcChainId, address _dstAddress, uint _gasLimit, bytes32 _lookupHash, bytes32 _blockData, bytes calldata _transactionProof) external override {\n        // retrieve UA's configuration using the _dstAddress from arguments.\n        ApplicationConfiguration memory uaConfig = _getAppConfig(_srcChainId, _dstAddress);\n\n        // assert that the caller == UA's relayer\n        require(uaConfig.relayer == msg.sender, \"LayerZero: invalid relayer\");\n\n        LayerZeroPacket.Packet memory _packet;\n        uint remoteAddressSize = chainAddressSizeMap[_srcChainId];\n        require(remoteAddressSize != 0, \"LayerZero: incorrect remote address size\");\n        {\n            // assert that the data submitted by UA's oracle have no fewer confirmations than UA's configuration\n            uint storedConfirmations = hashLookup[uaConfig.oracle][_srcChainId][_lookupHash][_blockData];\n            require(storedConfirmations > 0 && storedConfirmations >= uaConfig.inboundBlockConfirmations, \"LayerZero: not enough block confirmations\");\n\n            // decode\n            address inboundProofLib = inboundProofLibrary[_srcChainId][uaConfig.inboundProofLibraryVersion];\n            _packet = ILayerZeroValidationLibrary(inboundProofLib).validateProof(_blockData, _transactionProof, remoteAddressSize);\n        }\n\n        // packet content assertion\n        require(ulnLookup[_srcChainId] == _packet.ulnAddress && _packet.ulnAddress != bytes32(0), \"LayerZero: invalid _packet.ulnAddress\");\n        require(_packet.srcChainId == _srcChainId, \"LayerZero: invalid srcChain Id\");\n        // failsafe because the remoteAddress size being passed into validateProof trims the address this should not hit\n        require(_packet.srcAddress.length == remoteAddressSize, \"LayerZero: invalid srcAddress size\");\n        require(_packet.dstChainId == localChainId, \"LayerZero: invalid dstChain Id\");\n        require(_packet.dstAddress == _dstAddress, \"LayerZero: invalid dstAddress\");\n\n        // if the dst is not a contract, then emit and return early. This will break inbound nonces, but this particular\n        // path is already broken and wont ever be able to deliver anyways\n        if (!_isContract(_dstAddress)) {\n            emit InvalidDst(_packet.srcChainId, _packet.srcAddress, _packet.dstAddress, _packet.nonce, keccak256(_packet.payload));\n            return;\n        }\n\n        bytes memory pathData = abi.encodePacked(_packet.srcAddress, _packet.dstAddress);\n        emit PacketReceived(_packet.srcChainId, _packet.srcAddress, _packet.dstAddress, _packet.nonce, keccak256(_packet.payload));\n        endpoint.receivePayload(_srcChainId, pathData, _dstAddress, _packet.nonce, _gasLimit, _packet.payload);\n    }\n\n    function send(address _ua, uint64, uint16 _dstChainId, bytes calldata _path, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable override onlyEndpoint {\n        address ua = _ua;\n        uint16 dstChainId = _dstChainId;\n        require(ulnLookup[dstChainId] != bytes32(0), \"LayerZero: dstChainId does not exist\");\n\n        bytes memory dstAddress;\n        uint64 nonce;\n        // code block for solving 'Stack Too Deep'\n        {\n            uint chainAddressSize = chainAddressSizeMap[dstChainId];\n            // path = remoteAddress + localAddress\n            require(chainAddressSize != 0 && _path.length == 20 + chainAddressSize, \"LayerZero: incorrect remote address size\");\n            address srcInPath;\n            bytes memory path = _path; // copy to memory\n            assembly {\n                srcInPath := mload(add(add(path, 20), chainAddressSize)) // chainAddressSize + 20\n            }\n            require(ua == srcInPath, \"LayerZero: wrong path data\");\n            dstAddress = _path[0:chainAddressSize];\n            nonce = nonceContract.increment(dstChainId, ua, path);\n        }\n\n        bytes memory payload = _payload;\n        ApplicationConfiguration memory uaConfig = _getAppConfig(dstChainId, ua);\n\n        // compute all the fees\n        uint relayerFee = _handleRelayer(dstChainId, uaConfig, ua, payload.length, _adapterParams);\n        uint oracleFee = _handleOracle(dstChainId, uaConfig, ua);\n        uint nativeProtocolFee = _handleProtocolFee(relayerFee, oracleFee, ua, _zroPaymentAddress);\n\n        // total native fee, does not include ZRO protocol fee\n        uint totalNativeFee = relayerFee.add(oracleFee).add(nativeProtocolFee);\n\n        // assert the user has attached enough native token for this address\n        require(totalNativeFee <= msg.value, \"LayerZero: not enough native for fees\");\n        // refund if they send too much\n        uint amount = msg.value.sub(totalNativeFee);\n        if (amount > 0) {\n            (bool success, ) = _refundAddress.call{value: amount}(\"\");\n            require(success, \"LayerZero: failed to refund\");\n        }\n\n        // emit the data packet\n        bytes memory encodedPayload = abi.encodePacked(nonce, localChainId, ua, dstChainId, dstAddress, payload);\n        emit Packet(encodedPayload);\n    }\n\n    function _handleRelayer(uint16 _dstChainId, ApplicationConfiguration memory _uaConfig, address _ua, uint _payloadSize, bytes memory _adapterParams) internal returns (uint relayerFee) {\n        if (_adapterParams.length == 0) {\n            _adapterParams = defaultAdapterParams[_dstChainId][_uaConfig.outboundProofType];\n        }\n        address relayerAddress = _uaConfig.relayer;\n        ILayerZeroRelayerV2 relayer = ILayerZeroRelayerV2(relayerAddress);\n        relayerFee = relayer.assignJob(_dstChainId, _uaConfig.outboundProofType, _ua, _payloadSize, _adapterParams);\n\n        _creditNativeFee(relayerAddress, relayerFee);\n\n        // emit the param events\n        emit RelayerParams(_adapterParams, _uaConfig.outboundProofType);\n    }\n\n    function _handleOracle(uint16 _dstChainId, ApplicationConfiguration memory _uaConfig, address _ua) internal returns (uint oracleFee) {\n        address oracleAddress = _uaConfig.oracle;\n        oracleFee = ILayerZeroOracleV2(oracleAddress).assignJob(_dstChainId, _uaConfig.outboundProofType, _uaConfig.outboundBlockConfirmations, _ua);\n\n        _creditNativeFee(oracleAddress, oracleFee);\n    }\n\n    function _handleProtocolFee(uint _relayerFee, uint _oracleFee, address _ua, address _zroPaymentAddress) internal returns (uint protocolNativeFee) {\n        // if no ZRO token or not specifying a payment address, pay in native token\n        bool payInNative = _zroPaymentAddress == address(0x0) || address(layerZeroToken) == address(0x0);\n        uint protocolFee = treasuryContract.getFees(!payInNative, _relayerFee, _oracleFee);\n\n        if (protocolFee > 0) {\n            if (payInNative) {\n                address treasuryAddress = address(treasuryContract);\n                _creditNativeFee(treasuryAddress, protocolFee);\n                protocolNativeFee = protocolFee;\n            } else {\n                // zro payment address must equal the ua or the tx.origin otherwise the transaction reverts\n                require(_zroPaymentAddress == _ua || _zroPaymentAddress == tx.origin, \"LayerZero: must be paid by sender or origin\");\n\n                // transfer the LayerZero token to this contract from the payee\n                layerZeroToken.safeTransferFrom(_zroPaymentAddress, address(this), protocolFee);\n\n                treasuryZROFees = treasuryZROFees.add(protocolFee);\n            }\n        }\n    }\n\n    function _creditNativeFee(address _receiver, uint _amount) internal {\n        nativeFees[_receiver] = nativeFees[_receiver].add(_amount);\n    }\n\n    // Can be called by any address to update a block header\n    // can only upload new block data or the same block data with more confirmations\n    function updateHash(uint16 _srcChainId, bytes32 _lookupHash, uint _confirmations, bytes32 _blockData) external override {\n        uint storedConfirmations = hashLookup[msg.sender][_srcChainId][_lookupHash][_blockData];\n\n        // if it has a record, requires a larger confirmation.\n        require(storedConfirmations < _confirmations, \"LayerZero: oracle data can only update if it has more confirmations\");\n\n        // set the new information into storage\n        hashLookup[msg.sender][_srcChainId][_lookupHash][_blockData] = _confirmations;\n\n        emit HashReceived(_srcChainId, msg.sender, _lookupHash, _blockData, _confirmations);\n    }\n\n    //----------------------------------------------------------------------------------\n    // Other Library Interfaces\n\n    // default to DEFAULT setting if ZERO value\n    function getAppConfig(uint16 _remoteChainId, address _ua) external view override returns (ApplicationConfiguration memory) {\n        return _getAppConfig(_remoteChainId, _ua);\n    }\n\n    function _getAppConfig(uint16 _remoteChainId, address _ua) internal view returns (ApplicationConfiguration memory) {\n        ApplicationConfiguration memory config = appConfig[_ua][_remoteChainId];\n        ApplicationConfiguration storage defaultConfig = defaultAppConfig[_remoteChainId];\n\n        if (config.inboundProofLibraryVersion == 0) {\n            config.inboundProofLibraryVersion = defaultConfig.inboundProofLibraryVersion;\n        }\n\n        if (config.inboundBlockConfirmations == 0) {\n            config.inboundBlockConfirmations = defaultConfig.inboundBlockConfirmations;\n        }\n\n        if (config.relayer == address(0x0)) {\n            config.relayer = defaultConfig.relayer;\n        }\n\n        if (config.outboundProofType == 0) {\n            config.outboundProofType = defaultConfig.outboundProofType;\n        }\n\n        if (config.outboundBlockConfirmations == 0) {\n            config.outboundBlockConfirmations = defaultConfig.outboundBlockConfirmations;\n        }\n\n        if (config.oracle == address(0x0)) {\n            config.oracle = defaultConfig.oracle;\n        }\n\n        return config;\n    }\n\n    function setConfig(uint16 _remoteChainId, address _ua, uint _configType, bytes calldata _config) external override onlyEndpoint {\n        ApplicationConfiguration storage uaConfig = appConfig[_ua][_remoteChainId];\n        if (_configType == CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION) {\n            uint16 inboundProofLibraryVersion = abi.decode(_config, (uint16));\n            require(inboundProofLibraryVersion <= maxInboundProofLibrary[_remoteChainId], \"LayerZero: invalid inbound proof library version\");\n            uaConfig.inboundProofLibraryVersion = inboundProofLibraryVersion;\n        } else if (_configType == CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS) {\n            uint64 blockConfirmations = abi.decode(_config, (uint64));\n            uaConfig.inboundBlockConfirmations = blockConfirmations;\n        } else if (_configType == CONFIG_TYPE_RELAYER) {\n            address relayer = abi.decode(_config, (address));\n            uaConfig.relayer = relayer;\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_PROOF_TYPE) {\n            uint16 outboundProofType = abi.decode(_config, (uint16));\n            require(supportedOutboundProof[_remoteChainId][outboundProofType] || outboundProofType == 0, \"LayerZero: invalid outbound proof type\");\n            uaConfig.outboundProofType = outboundProofType;\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS) {\n            uint64 blockConfirmations = abi.decode(_config, (uint64));\n            uaConfig.outboundBlockConfirmations = blockConfirmations;\n        } else if (_configType == CONFIG_TYPE_ORACLE) {\n            address oracle = abi.decode(_config, (address));\n            uaConfig.oracle = oracle;\n        } else {\n            revert(\"LayerZero: Invalid config type\");\n        }\n\n        emit AppConfigUpdated(_ua, _configType, _config);\n    }\n\n    function getConfig(uint16 _remoteChainId, address _ua, uint _configType) external view override returns (bytes memory) {\n        ApplicationConfiguration storage uaConfig = appConfig[_ua][_remoteChainId];\n\n        if (_configType == CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION) {\n            if (uaConfig.inboundProofLibraryVersion == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].inboundProofLibraryVersion);\n            }\n            return abi.encode(uaConfig.inboundProofLibraryVersion);\n        } else if (_configType == CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS) {\n            if (uaConfig.inboundBlockConfirmations == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].inboundBlockConfirmations);\n            }\n            return abi.encode(uaConfig.inboundBlockConfirmations);\n        } else if (_configType == CONFIG_TYPE_RELAYER) {\n            if (uaConfig.relayer == address(0x0)) {\n                return abi.encode(defaultAppConfig[_remoteChainId].relayer);\n            }\n            return abi.encode(uaConfig.relayer);\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_PROOF_TYPE) {\n            if (uaConfig.outboundProofType == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].outboundProofType);\n            }\n            return abi.encode(uaConfig.outboundProofType);\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS) {\n            if (uaConfig.outboundBlockConfirmations == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].outboundBlockConfirmations);\n            }\n            return abi.encode(uaConfig.outboundBlockConfirmations);\n        } else if (_configType == CONFIG_TYPE_ORACLE) {\n            if (uaConfig.oracle == address(0x0)) {\n                return abi.encode(defaultAppConfig[_remoteChainId].oracle);\n            }\n            return abi.encode(uaConfig.oracle);\n        } else {\n            revert(\"LayerZero: Invalid config type\");\n        }\n    }\n\n    // returns the native fee the UA pays to cover fees\n    function estimateFees(uint16 _dstChainId, address _ua, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParams) external view override returns (uint nativeFee, uint zroFee) {\n        ApplicationConfiguration memory uaConfig = _getAppConfig(_dstChainId, _ua);\n\n        // Relayer Fee\n        bytes memory adapterParams;\n        if (_adapterParams.length > 0) {\n            adapterParams = _adapterParams;\n        } else {\n            adapterParams = defaultAdapterParams[_dstChainId][uaConfig.outboundProofType];\n        }\n        uint relayerFee = ILayerZeroRelayerV2(uaConfig.relayer).getFee(_dstChainId, uaConfig.outboundProofType, _ua, _payload.length, adapterParams);\n\n        // Oracle Fee\n        address ua = _ua; // stack too deep\n        uint oracleFee = ILayerZeroOracleV2(uaConfig.oracle).getFee(_dstChainId, uaConfig.outboundProofType, uaConfig.outboundBlockConfirmations, ua);\n\n        // LayerZero Fee\n        uint protocolFee = treasuryContract.getFees(_payInZRO, relayerFee, oracleFee);\n        _payInZRO ? zroFee = protocolFee : nativeFee = protocolFee;\n\n        // return the sum of fees\n        nativeFee = nativeFee.add(relayerFee).add(oracleFee);\n    }\n\n    //---------------------------------------------------------------------------\n    // Claim Fees\n\n    // universal withdraw ZRO token function\n    function withdrawZRO(address _to, uint _amount) external override nonReentrant {\n        require(msg.sender == address(treasuryContract), \"LayerZero: only treasury\");\n        treasuryZROFees = treasuryZROFees.sub(_amount);\n        layerZeroToken.safeTransfer(_to, _amount);\n        emit WithdrawZRO(msg.sender, _to, _amount);\n    }\n\n    // universal withdraw native token function.\n    // the source contract should perform all the authentication control\n    function withdrawNative(address payable _to, uint _amount) external override nonReentrant {\n        require(_to != address(0x0), \"LayerZero: _to cannot be zero address\");\n        nativeFees[msg.sender] = nativeFees[msg.sender].sub(_amount);\n\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"LayerZero: withdraw failed\");\n        emit WithdrawNative(msg.sender, _to, _amount);\n    }\n\n    //---------------------------------------------------------------------------\n    // Owner calls, configuration only.\n    function setLayerZeroToken(address _layerZeroToken) external onlyOwner {\n        require(_layerZeroToken != address(0x0), \"LayerZero: _layerZeroToken cannot be zero address\");\n        layerZeroToken = IERC20(_layerZeroToken);\n        emit SetLayerZeroToken(_layerZeroToken);\n    }\n\n    function setTreasury(address _treasury) external onlyOwner {\n        require(_treasury != address(0x0), \"LayerZero: treasury cannot be zero address\");\n        treasuryContract = ILayerZeroTreasury(_treasury);\n        emit SetTreasury(_treasury);\n    }\n\n    function addInboundProofLibraryForChain(uint16 _chainId, address _library) external onlyOwner {\n        require(_library != address(0x0), \"LayerZero: library cannot be zero address\");\n        uint16 libId = maxInboundProofLibrary[_chainId];\n        require(libId < 65535, \"LayerZero: can not add new library\");\n        maxInboundProofLibrary[_chainId] = ++libId;\n        inboundProofLibrary[_chainId][libId] = _library;\n        emit AddInboundProofLibraryForChain(_chainId, _library);\n    }\n\n    function enableSupportedOutboundProof(uint16 _chainId, uint16 _proofType) external onlyOwner {\n        supportedOutboundProof[_chainId][_proofType] = true;\n        emit EnableSupportedOutboundProof(_chainId, _proofType);\n    }\n\n    function setDefaultConfigForChainId(uint16 _chainId, uint16 _inboundProofLibraryVersion, uint64 _inboundBlockConfirmations, address _relayer, uint16 _outboundProofType, uint64 _outboundBlockConfirmations, address _oracle) external onlyOwner {\n        require(_inboundProofLibraryVersion <= maxInboundProofLibrary[_chainId] && _inboundProofLibraryVersion > 0, \"LayerZero: invalid inbound proof library version\");\n        require(_inboundBlockConfirmations > 0, \"LayerZero: invalid inbound block confirmation\");\n        require(_relayer != address(0x0), \"LayerZero: invalid relayer address\");\n        require(supportedOutboundProof[_chainId][_outboundProofType], \"LayerZero: invalid outbound proof type\");\n        require(_outboundBlockConfirmations > 0, \"LayerZero: invalid outbound block confirmation\");\n        require(_oracle != address(0x0), \"LayerZero: invalid oracle address\");\n        defaultAppConfig[_chainId] = ApplicationConfiguration(_inboundProofLibraryVersion, _inboundBlockConfirmations, _relayer, _outboundProofType, _outboundBlockConfirmations, _oracle);\n        emit SetDefaultConfigForChainId(_chainId, _inboundProofLibraryVersion, _inboundBlockConfirmations, _relayer, _outboundProofType, _outboundBlockConfirmations, _oracle);\n    }\n\n    function setDefaultAdapterParamsForChainId(uint16 _chainId, uint16 _proofType, bytes calldata _adapterParams) external onlyOwner {\n        defaultAdapterParams[_chainId][_proofType] = _adapterParams;\n        emit SetDefaultAdapterParamsForChainId(_chainId, _proofType, _adapterParams);\n    }\n\n    function setRemoteUln(uint16 _remoteChainId, bytes32 _remoteUln) external onlyOwner {\n        require(ulnLookup[_remoteChainId] == bytes32(0), \"LayerZero: remote uln already set\");\n        ulnLookup[_remoteChainId] = _remoteUln;\n        emit SetRemoteUln(_remoteChainId, _remoteUln);\n    }\n\n    function setChainAddressSize(uint16 _chainId, uint _size) external onlyOwner {\n        require(chainAddressSizeMap[_chainId] == 0, \"LayerZero: remote chain address size already set\");\n        chainAddressSizeMap[_chainId] = _size;\n        emit SetChainAddressSize(_chainId, _size);\n    }\n\n    //----------------------------------------------------------------------------------\n    // view functions\n\n    function accruedNativeFee(address _address) external view override returns (uint) {\n        return nativeFees[_address];\n    }\n\n    function getOutboundNonce(uint16 _chainId, bytes calldata _path) external view override returns (uint64) {\n        return nonceContract.outboundNonce(_chainId, _path);\n    }\n\n    function _isContract(address addr) internal view returns (bool) {\n        uint size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size != 0;\n    }\n}\n"
    },
    "contracts/UltraLightNodeV2AltToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./interfaces/ILayerZeroValidationLibrary.sol\";\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroTreasury.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\n// v2\nimport \"./interfaces/ILayerZeroMessagingLibraryV2.sol\";\nimport \"./interfaces/ILayerZeroOracleV2.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV2.sol\";\nimport \"./interfaces/ILayerZeroRelayerV2.sol\";\nimport \"./FeeHandler.sol\";\nimport \"./NonceContract.sol\";\n\ncontract UltraLightNodeV2AltToken is ILayerZeroMessagingLibraryV2, ILayerZeroUltraLightNodeV2, ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    // Application config\n    uint public constant CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION = 1;\n    uint public constant CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS = 2;\n    uint public constant CONFIG_TYPE_RELAYER = 3;\n    uint public constant CONFIG_TYPE_OUTBOUND_PROOF_TYPE = 4;\n    uint public constant CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS = 5;\n    uint public constant CONFIG_TYPE_ORACLE = 6;\n\n    // Token and Contracts\n    IERC20 public layerZeroToken;\n    ILayerZeroTreasury public treasuryContract;\n\n    mapping(address => uint) public nativeFees;\n    uint public treasuryZROFees;\n\n    // User Application\n    mapping(address => mapping(uint16 => ApplicationConfiguration)) public appConfig; // app address => chainId => config\n    mapping(uint16 => ApplicationConfiguration) public defaultAppConfig; // default UA settings if no version specified\n    mapping(uint16 => mapping(uint16 => bytes)) public defaultAdapterParams;\n\n    // Validation\n    mapping(uint16 => mapping(uint16 => address)) public inboundProofLibrary; // chainId => library Id => inboundProofLibrary contract\n    mapping(uint16 => uint16) public maxInboundProofLibrary; // chainId => inboundProofLibrary\n    mapping(uint16 => mapping(uint16 => bool)) public supportedOutboundProof; // chainId => outboundProofType => enabled\n    mapping(uint16 => uint) public chainAddressSizeMap;\n    mapping(address => mapping(uint16 => mapping(bytes32 => mapping(bytes32 => uint)))) public hashLookup; //[oracle][srcChainId][blockhash][datahash] -> confirmation\n    mapping(uint16 => bytes32) public ulnLookup; // remote ulns\n\n    ILayerZeroEndpoint public immutable endpoint;\n    uint16 public immutable localChainId;\n    NonceContract public immutable nonceContract;\n    FeeHandler public immutable feeHandler;\n\n    constructor(address _endpoint, address _nonceContract, uint16 _localChainId, address _feeHandler) {\n        require(_endpoint != address(0x0), \"LayerZero: endpoint cannot be zero address\");\n        require(_nonceContract != address(0x0), \"LayerZero: nonceContract cannot be zero address\");\n        ILayerZeroEndpoint lzEndpoint = ILayerZeroEndpoint(_endpoint);\n        localChainId = _localChainId;\n        endpoint = lzEndpoint;\n        nonceContract = NonceContract(_nonceContract);\n        feeHandler = FeeHandler(_feeHandler);\n    }\n\n    // only the endpoint can call SEND() and setConfig()\n    modifier onlyEndpoint() {\n        require(address(endpoint) == msg.sender, \"LayerZero: only endpoint\");\n        _;\n    }\n\n    //----------------------------------------------------------------------------------\n    // PROTOCOL\n    function validateTransactionProof(uint16 _srcChainId, address _dstAddress, uint _gasLimit, bytes32 _lookupHash, bytes32 _blockData, bytes calldata _transactionProof) external override {\n        // retrieve UA's configuration using the _dstAddress from arguments.\n        ApplicationConfiguration memory uaConfig = _getAppConfig(_srcChainId, _dstAddress);\n\n        // assert that the caller == UA's relayer\n        require(uaConfig.relayer == msg.sender, \"LayerZero: invalid relayer\");\n\n        LayerZeroPacket.Packet memory _packet;\n        uint remoteAddressSize = chainAddressSizeMap[_srcChainId];\n        require(remoteAddressSize != 0, \"LayerZero: incorrect remote address size\");\n        {\n            // assert that the data submitted by UA's oracle have no fewer confirmations than UA's configuration\n            uint storedConfirmations = hashLookup[uaConfig.oracle][_srcChainId][_lookupHash][_blockData];\n            require(storedConfirmations > 0 && storedConfirmations >= uaConfig.inboundBlockConfirmations, \"LayerZero: not enough block confirmations\");\n\n            // decode\n            address inboundProofLib = inboundProofLibrary[_srcChainId][uaConfig.inboundProofLibraryVersion];\n            _packet = ILayerZeroValidationLibrary(inboundProofLib).validateProof(_blockData, _transactionProof, remoteAddressSize);\n        }\n\n        // packet content assertion\n        require(ulnLookup[_srcChainId] == _packet.ulnAddress && _packet.ulnAddress != bytes32(0), \"LayerZero: invalid _packet.ulnAddress\");\n        require(_packet.srcChainId == _srcChainId, \"LayerZero: invalid srcChain Id\");\n        // failsafe because the remoteAddress size being passed into validateProof trims the address this should not hit\n        require(_packet.srcAddress.length == remoteAddressSize, \"LayerZero: invalid srcAddress size\");\n        require(_packet.dstChainId == localChainId, \"LayerZero: invalid dstChain Id\");\n        require(_packet.dstAddress == _dstAddress, \"LayerZero: invalid dstAddress\");\n\n        // if the dst is not a contract, then emit and return early. This will break inbound nonces, but this particular\n        // path is already broken and wont ever be able to deliver anyways\n        if (!_isContract(_dstAddress)) {\n            emit InvalidDst(_packet.srcChainId, _packet.srcAddress, _packet.dstAddress, _packet.nonce, keccak256(_packet.payload));\n            return;\n        }\n\n        bytes memory pathData = abi.encodePacked(_packet.srcAddress, _packet.dstAddress);\n        emit PacketReceived(_packet.srcChainId, _packet.srcAddress, _packet.dstAddress, _packet.nonce, keccak256(_packet.payload));\n        endpoint.receivePayload(_srcChainId, pathData, _dstAddress, _packet.nonce, _gasLimit, _packet.payload);\n    }\n\n    function send(address _ua, uint64, uint16 _dstChainId, bytes calldata _path, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable override onlyEndpoint {\n        address ua = _ua;\n        uint16 dstChainId = _dstChainId;\n        require(ulnLookup[dstChainId] != bytes32(0), \"LayerZero: dstChainId does not exist\");\n\n        bytes memory dstAddress;\n        uint64 nonce;\n        // code block for solving 'Stack Too Deep'\n        {\n            uint chainAddressSize = chainAddressSizeMap[dstChainId];\n            // path = remoteAddress + localAddress\n            require(chainAddressSize != 0 && _path.length == 20 + chainAddressSize, \"LayerZero: incorrect remote address size\");\n            address srcInPath;\n            bytes memory path = _path; // copy to memory\n            assembly {\n                srcInPath := mload(add(add(path, 20), chainAddressSize)) // chainAddressSize + 20\n            }\n            require(ua == srcInPath, \"LayerZero: wrong path data\");\n            dstAddress = _path[0:chainAddressSize];\n            nonce = nonceContract.increment(dstChainId, ua, path);\n        }\n\n        bytes memory payload = _payload;\n        ApplicationConfiguration memory uaConfig = _getAppConfig(dstChainId, ua);\n\n        // compute all the fees\n        uint[] memory fees = new uint[](3);\n        fees[0] = _handleRelayer(dstChainId, uaConfig, ua, payload.length, _adapterParams);\n        fees[1] = _handleOracle(dstChainId, uaConfig, ua);\n        fees[2] = _handleProtocolFee(fees[0], fees[1], ua, _zroPaymentAddress);\n\n        address[] memory receivers = new address[](3);\n        receivers[0] = uaConfig.relayer;\n        receivers[1] = uaConfig.oracle;\n        receivers[2] = address(treasuryContract);\n\n        feeHandler.creditFee(receivers, fees, _refundAddress);\n\n        // emit the data packet\n        bytes memory encodedPayload = abi.encodePacked(nonce, localChainId, ua, dstChainId, dstAddress, payload);\n        emit Packet(encodedPayload);\n    }\n\n    function _handleRelayer(uint16 _dstChainId, ApplicationConfiguration memory _uaConfig, address _ua, uint _payloadSize, bytes memory _adapterParams) internal returns (uint relayerFee) {\n        if (_adapterParams.length == 0) {\n            _adapterParams = defaultAdapterParams[_dstChainId][_uaConfig.outboundProofType];\n        }\n        address relayerAddress = _uaConfig.relayer;\n        ILayerZeroRelayerV2 relayer = ILayerZeroRelayerV2(relayerAddress);\n        relayerFee = relayer.assignJob(_dstChainId, _uaConfig.outboundProofType, _ua, _payloadSize, _adapterParams);\n\n        // emit the param events\n        emit RelayerParams(_adapterParams, _uaConfig.outboundProofType);\n    }\n\n    function _handleOracle(uint16 _dstChainId, ApplicationConfiguration memory _uaConfig, address _ua) internal returns (uint oracleFee) {\n        address oracleAddress = _uaConfig.oracle;\n        oracleFee = ILayerZeroOracleV2(oracleAddress).assignJob(_dstChainId, _uaConfig.outboundProofType, _uaConfig.outboundBlockConfirmations, _ua);\n    }\n\n    function _handleProtocolFee(uint _relayerFee, uint _oracleFee, address _ua, address _zroPaymentAddress) internal returns (uint protocolNativeFee) {\n        // if no ZRO token or not specifying a payment address, pay in native token\n        bool payInNative = _zroPaymentAddress == address(0x0) || address(layerZeroToken) == address(0x0);\n        uint protocolFee = treasuryContract.getFees(!payInNative, _relayerFee, _oracleFee);\n\n        if (protocolFee > 0) {\n            if (payInNative) {\n                address treasuryAddress = address(treasuryContract);\n                protocolNativeFee = protocolFee;\n            } else {\n                // zro payment address must equal the ua or the tx.origin otherwise the transaction reverts\n                require(_zroPaymentAddress == _ua || _zroPaymentAddress == tx.origin, \"LayerZero: must be paid by sender or origin\");\n\n                // transfer the LayerZero token to this contract from the payee\n                layerZeroToken.safeTransferFrom(_zroPaymentAddress, address(this), protocolFee);\n\n                treasuryZROFees = treasuryZROFees.add(protocolFee);\n            }\n        }\n    }\n\n    // Can be called by any address to update a block header\n    // can only upload new block data or the same block data with more confirmations\n    function updateHash(uint16 _srcChainId, bytes32 _lookupHash, uint _confirmations, bytes32 _blockData) external override {\n        uint storedConfirmations = hashLookup[msg.sender][_srcChainId][_lookupHash][_blockData];\n\n        // if it has a record, requires a larger confirmation.\n        require(storedConfirmations < _confirmations, \"LayerZero: oracle data can only update if it has more confirmations\");\n\n        // set the new information into storage\n        hashLookup[msg.sender][_srcChainId][_lookupHash][_blockData] = _confirmations;\n\n        emit HashReceived(_srcChainId, msg.sender, _lookupHash, _blockData, _confirmations);\n    }\n\n    //----------------------------------------------------------------------------------\n    // Other Library Interfaces\n\n    // default to DEFAULT setting if ZERO value\n    function getAppConfig(uint16 _remoteChainId, address _ua) external view override returns (ApplicationConfiguration memory) {\n        return _getAppConfig(_remoteChainId, _ua);\n    }\n\n    function _getAppConfig(uint16 _remoteChainId, address _ua) internal view returns (ApplicationConfiguration memory) {\n        ApplicationConfiguration memory config = appConfig[_ua][_remoteChainId];\n        ApplicationConfiguration storage defaultConfig = defaultAppConfig[_remoteChainId];\n\n        if (config.inboundProofLibraryVersion == 0) {\n            config.inboundProofLibraryVersion = defaultConfig.inboundProofLibraryVersion;\n        }\n\n        if (config.inboundBlockConfirmations == 0) {\n            config.inboundBlockConfirmations = defaultConfig.inboundBlockConfirmations;\n        }\n\n        if (config.relayer == address(0x0)) {\n            config.relayer = defaultConfig.relayer;\n        }\n\n        if (config.outboundProofType == 0) {\n            config.outboundProofType = defaultConfig.outboundProofType;\n        }\n\n        if (config.outboundBlockConfirmations == 0) {\n            config.outboundBlockConfirmations = defaultConfig.outboundBlockConfirmations;\n        }\n\n        if (config.oracle == address(0x0)) {\n            config.oracle = defaultConfig.oracle;\n        }\n\n        return config;\n    }\n\n    function setConfig(uint16 _remoteChainId, address _ua, uint _configType, bytes calldata _config) external override onlyEndpoint {\n        ApplicationConfiguration storage uaConfig = appConfig[_ua][_remoteChainId];\n        if (_configType == CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION) {\n            uint16 inboundProofLibraryVersion = abi.decode(_config, (uint16));\n            require(inboundProofLibraryVersion <= maxInboundProofLibrary[_remoteChainId], \"LayerZero: invalid inbound proof library version\");\n            uaConfig.inboundProofLibraryVersion = inboundProofLibraryVersion;\n        } else if (_configType == CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS) {\n            uint64 blockConfirmations = abi.decode(_config, (uint64));\n            uaConfig.inboundBlockConfirmations = blockConfirmations;\n        } else if (_configType == CONFIG_TYPE_RELAYER) {\n            address relayer = abi.decode(_config, (address));\n            uaConfig.relayer = relayer;\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_PROOF_TYPE) {\n            uint16 outboundProofType = abi.decode(_config, (uint16));\n            require(supportedOutboundProof[_remoteChainId][outboundProofType] || outboundProofType == 0, \"LayerZero: invalid outbound proof type\");\n            uaConfig.outboundProofType = outboundProofType;\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS) {\n            uint64 blockConfirmations = abi.decode(_config, (uint64));\n            uaConfig.outboundBlockConfirmations = blockConfirmations;\n        } else if (_configType == CONFIG_TYPE_ORACLE) {\n            address oracle = abi.decode(_config, (address));\n            uaConfig.oracle = oracle;\n        } else {\n            revert(\"LayerZero: Invalid config type\");\n        }\n\n        emit AppConfigUpdated(_ua, _configType, _config);\n    }\n\n    function getConfig(uint16 _remoteChainId, address _ua, uint _configType) external view override returns (bytes memory) {\n        ApplicationConfiguration storage uaConfig = appConfig[_ua][_remoteChainId];\n\n        if (_configType == CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION) {\n            if (uaConfig.inboundProofLibraryVersion == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].inboundProofLibraryVersion);\n            }\n            return abi.encode(uaConfig.inboundProofLibraryVersion);\n        } else if (_configType == CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS) {\n            if (uaConfig.inboundBlockConfirmations == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].inboundBlockConfirmations);\n            }\n            return abi.encode(uaConfig.inboundBlockConfirmations);\n        } else if (_configType == CONFIG_TYPE_RELAYER) {\n            if (uaConfig.relayer == address(0x0)) {\n                return abi.encode(defaultAppConfig[_remoteChainId].relayer);\n            }\n            return abi.encode(uaConfig.relayer);\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_PROOF_TYPE) {\n            if (uaConfig.outboundProofType == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].outboundProofType);\n            }\n            return abi.encode(uaConfig.outboundProofType);\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS) {\n            if (uaConfig.outboundBlockConfirmations == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].outboundBlockConfirmations);\n            }\n            return abi.encode(uaConfig.outboundBlockConfirmations);\n        } else if (_configType == CONFIG_TYPE_ORACLE) {\n            if (uaConfig.oracle == address(0x0)) {\n                return abi.encode(defaultAppConfig[_remoteChainId].oracle);\n            }\n            return abi.encode(uaConfig.oracle);\n        } else {\n            revert(\"LayerZero: Invalid config type\");\n        }\n    }\n\n    // returns the native fee the UA pays to cover fees\n    function estimateFees(uint16 _dstChainId, address _ua, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParams) external view override returns (uint nativeFee, uint zroFee) {\n        ApplicationConfiguration memory uaConfig = _getAppConfig(_dstChainId, _ua);\n\n        // Relayer Fee\n        bytes memory adapterParams;\n        if (_adapterParams.length > 0) {\n            adapterParams = _adapterParams;\n        } else {\n            adapterParams = defaultAdapterParams[_dstChainId][uaConfig.outboundProofType];\n        }\n        uint relayerFee = ILayerZeroRelayerV2(uaConfig.relayer).getFee(_dstChainId, uaConfig.outboundProofType, _ua, _payload.length, adapterParams);\n\n        // Oracle Fee\n        address ua = _ua; // stack too deep\n        uint oracleFee = ILayerZeroOracleV2(uaConfig.oracle).getFee(_dstChainId, uaConfig.outboundProofType, uaConfig.outboundBlockConfirmations, ua);\n\n        // LayerZero Fee\n        uint protocolFee = treasuryContract.getFees(_payInZRO, relayerFee, oracleFee);\n        _payInZRO ? zroFee = protocolFee : nativeFee = protocolFee;\n\n        // return the sum of fees\n        nativeFee = nativeFee.add(relayerFee).add(oracleFee);\n    }\n\n    //---------------------------------------------------------------------------\n    // Claim Fees\n\n    // universal withdraw ZRO token function\n    function withdrawZRO(address _to, uint _amount) external override nonReentrant {\n        require(msg.sender == address(treasuryContract), \"LayerZero: only treasury\");\n        treasuryZROFees = treasuryZROFees.sub(_amount);\n        layerZeroToken.safeTransfer(_to, _amount);\n        emit WithdrawZRO(msg.sender, _to, _amount);\n    }\n\n    // universal withdraw native token function.\n    // the source contract should perform all the authentication control\n    function withdrawNative(address payable _to, uint _amount) external override nonReentrant {\n        require(_to != address(0x0), \"LayerZero: _to cannot be zero address\");\n        nativeFees[msg.sender] = nativeFees[msg.sender].sub(_amount);\n\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"LayerZero: withdraw failed\");\n        emit WithdrawNative(msg.sender, _to, _amount);\n    }\n\n    //---------------------------------------------------------------------------\n    // Owner calls, configuration only.\n    function setLayerZeroToken(address _layerZeroToken) external onlyOwner {\n        require(_layerZeroToken != address(0x0), \"LayerZero: _layerZeroToken cannot be zero address\");\n        layerZeroToken = IERC20(_layerZeroToken);\n        emit SetLayerZeroToken(_layerZeroToken);\n    }\n\n    function setTreasury(address _treasury) external onlyOwner {\n        require(_treasury != address(0x0), \"LayerZero: treasury cannot be zero address\");\n        treasuryContract = ILayerZeroTreasury(_treasury);\n        emit SetTreasury(_treasury);\n    }\n\n    function addInboundProofLibraryForChain(uint16 _chainId, address _library) external onlyOwner {\n        require(_library != address(0x0), \"LayerZero: library cannot be zero address\");\n        uint16 libId = maxInboundProofLibrary[_chainId];\n        require(libId < 65535, \"LayerZero: can not add new library\");\n        maxInboundProofLibrary[_chainId] = ++libId;\n        inboundProofLibrary[_chainId][libId] = _library;\n        emit AddInboundProofLibraryForChain(_chainId, _library);\n    }\n\n    function enableSupportedOutboundProof(uint16 _chainId, uint16 _proofType) external onlyOwner {\n        supportedOutboundProof[_chainId][_proofType] = true;\n        emit EnableSupportedOutboundProof(_chainId, _proofType);\n    }\n\n    function setDefaultConfigForChainId(uint16 _chainId, uint16 _inboundProofLibraryVersion, uint64 _inboundBlockConfirmations, address _relayer, uint16 _outboundProofType, uint64 _outboundBlockConfirmations, address _oracle) external onlyOwner {\n        require(_inboundProofLibraryVersion <= maxInboundProofLibrary[_chainId] && _inboundProofLibraryVersion > 0, \"LayerZero: invalid inbound proof library version\");\n        require(_inboundBlockConfirmations > 0, \"LayerZero: invalid inbound block confirmation\");\n        require(_relayer != address(0x0), \"LayerZero: invalid relayer address\");\n        require(supportedOutboundProof[_chainId][_outboundProofType], \"LayerZero: invalid outbound proof type\");\n        require(_outboundBlockConfirmations > 0, \"LayerZero: invalid outbound block confirmation\");\n        require(_oracle != address(0x0), \"LayerZero: invalid oracle address\");\n        defaultAppConfig[_chainId] = ApplicationConfiguration(_inboundProofLibraryVersion, _inboundBlockConfirmations, _relayer, _outboundProofType, _outboundBlockConfirmations, _oracle);\n        emit SetDefaultConfigForChainId(_chainId, _inboundProofLibraryVersion, _inboundBlockConfirmations, _relayer, _outboundProofType, _outboundBlockConfirmations, _oracle);\n    }\n\n    function setDefaultAdapterParamsForChainId(uint16 _chainId, uint16 _proofType, bytes calldata _adapterParams) external onlyOwner {\n        defaultAdapterParams[_chainId][_proofType] = _adapterParams;\n        emit SetDefaultAdapterParamsForChainId(_chainId, _proofType, _adapterParams);\n    }\n\n    function setRemoteUln(uint16 _remoteChainId, bytes32 _remoteUln) external onlyOwner {\n        require(ulnLookup[_remoteChainId] == bytes32(0), \"LayerZero: remote uln already set\");\n        ulnLookup[_remoteChainId] = _remoteUln;\n        emit SetRemoteUln(_remoteChainId, _remoteUln);\n    }\n\n    function setChainAddressSize(uint16 _chainId, uint _size) external onlyOwner {\n        require(chainAddressSizeMap[_chainId] == 0, \"LayerZero: remote chain address size already set\");\n        chainAddressSizeMap[_chainId] = _size;\n        emit SetChainAddressSize(_chainId, _size);\n    }\n\n    //----------------------------------------------------------------------------------\n    // view functions\n\n    function accruedNativeFee(address _address) external view override returns (uint) {\n        return nativeFees[_address];\n    }\n\n    function getOutboundNonce(uint16 _chainId, bytes calldata _path) external view override returns (uint64) {\n        return nonceContract.outboundNonce(_chainId, _path);\n    }\n\n    function _isContract(address addr) internal view returns (bool) {\n        uint size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size != 0;\n    }\n}\n"
    },
    "contracts/UltraLightNodeV2Radar.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./interfaces/ILayerZeroValidationLibrary.sol\";\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroTreasury.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\n// v2\nimport \"./interfaces/ILayerZeroMessagingLibraryV2.sol\";\nimport \"./interfaces/ILayerZeroOracleV2.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV2.sol\";\nimport \"./interfaces/ILayerZeroRelayerV2.sol\";\nimport \"./NonceContractRadar.sol\";\n\ncontract UltraLightNodeV2Radar is ILayerZeroMessagingLibraryV2, ILayerZeroUltraLightNodeV2, ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    // Application config\n    uint public constant CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION = 1;\n    uint public constant CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS = 2;\n    uint public constant CONFIG_TYPE_RELAYER = 3;\n    uint public constant CONFIG_TYPE_OUTBOUND_PROOF_TYPE = 4;\n    uint public constant CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS = 5;\n    uint public constant CONFIG_TYPE_ORACLE = 6;\n\n    // Token and Contracts\n    IERC20 public layerZeroToken;\n    ILayerZeroTreasury public treasuryContract;\n\n    mapping(address => uint) public nativeFees;\n    uint public treasuryZROFees;\n\n    // User Application\n    mapping(address => mapping(uint16 => ApplicationConfiguration)) public appConfig; // app address => chainId => config\n    mapping(uint16 => ApplicationConfiguration) public defaultAppConfig; // default UA settings if no version specified\n    mapping(uint16 => mapping(uint16 => bytes)) public defaultAdapterParams;\n\n    // Validation\n    mapping(uint16 => mapping(uint16 => address)) public inboundProofLibrary; // chainId => library Id => inboundProofLibrary contract\n    mapping(uint16 => uint16) public maxInboundProofLibrary; // chainId => inboundProofLibrary\n    mapping(uint16 => mapping(uint16 => bool)) public supportedOutboundProof; // chainId => outboundProofType => enabled\n    mapping(uint16 => uint) public chainAddressSizeMap;\n    mapping(address => mapping(uint16 => mapping(bytes32 => mapping(bytes32 => uint)))) public hashLookup; //[oracle][srcChainId][blockhash][datahash] -> confirmation\n    mapping(uint16 => bytes32) public ulnLookup; // remote ulns\n\n    ILayerZeroEndpoint public immutable endpoint;\n    uint16 public immutable localChainId;\n    NonceContractRadar public immutable nonceContract;\n\n    constructor(address _endpoint, address _nonceContract, uint16 _localChainId, address _dappRadar) {\n        require(_endpoint != address(0x0), \"LayerZero: endpoint cannot be zero address\");\n        require(_nonceContract != address(0x0), \"LayerZero: nonceContract cannot be zero address\");\n        ILayerZeroEndpoint lzEndpoint = ILayerZeroEndpoint(_endpoint);\n        localChainId = _localChainId;\n        endpoint = lzEndpoint;\n        nonceContract = NonceContractRadar(_nonceContract);\n\n        // dappRadar\n        dappRadar = _dappRadar;\n    }\n\n    // only the endpoint can call SEND() and setConfig()\n    modifier onlyEndpoint() {\n        require(address(endpoint) == msg.sender, \"LayerZero: only endpoint\");\n        _;\n    }\n\n    // Manual for DappRadar handling. This contract is dappRadar-only (send/receive)\n    // 1. Layerzero deploys UltraLightNodeV2Radar and NonceContractRadar using old chain ID with the local dappRadar address in constructor\n    // 2. Dapp Radar sets the messaging library to UltraLightNodeV2Radar\n    // 3. Dapp Radar sets the trustedRemote to the full path\n    // 4. Layerzero initializes the outboundNonce (1 call) and inboundNonce (batch call)\n    // 5. Test message flows\n    //\n    // 6. after an agree-upon period of time, decommission this contract (one-way trip).\n\n    //\n    // DappRadar constructs\n    //\n    address immutable public dappRadar;\n    bool public decommissioned;\n    mapping(uint16 => bool) public outboundNonceSet;\n    mapping(address => uint64) public inboundNonceCap;\n\n    // only dappRadar\n    function initRadarOutboundNonce(uint16 _dstChainId, address _dstRadarAddress) external onlyOwner {\n        // can only inherit the outbound nonce from previous path once\n        // assuming dappRadar has only 1 remote peer at a destination chain.\n        require(!outboundNonceSet[_dstChainId], \"LayerZero: dappRadar nonce already set\");\n        uint64 inheritedNonce = endpoint.getOutboundNonce(_dstChainId, dappRadar);\n        outboundNonceSet[_dstChainId] = true;\n\n        // can only set the path owned by the dappRadar\n        // dappRadar is only deployed on EVM chains so the address is 20 bytes for all\n        bytes memory radarPath = abi.encodePacked(_dstRadarAddress, dappRadar); //// remote + local\n\n        // insert into the nonce contract\n        nonceContract.initRadarOutboundNonce(_dstChainId, radarPath, inheritedNonce);\n    }\n\n    // generate a message from the new dappRadar-owned path with now payload\n    // dappRadar needs to first change the trustedRemote\n    // messages will fail locally in the nonBlockingLzApp from the nonce checking\n    // can only increment the nonce till we hit the legacy nonce\n    function incrementRadarInboundNonce(uint16 _srcChainId, address _srcRadarAddress, uint _gasLimitPerCall, uint _steps) external onlyOwner {\n        // initialize the inboundNonceCap, only once\n        if (inboundNonceCap[_srcRadarAddress] == 0) {\n            // check if the _srcRadarAddress is a legacy address by checking the nonce\n            uint64 inheritNonce = endpoint.getInboundNonce(_srcChainId, abi.encodePacked(_srcRadarAddress));\n            require(inheritNonce > 0, \"LayerZero: not legacy radar address\");\n\n            inboundNonceCap[_srcRadarAddress] = inheritNonce;\n        }\n\n        // can only set the path owned by the dappRadar\n        // dappRadar is only deployed on EVM chains so the address is 20 bytes for all\n        bytes memory radarPath = abi.encodePacked(_srcRadarAddress, dappRadar); // remote + local\n        uint64 radarPathNonce = endpoint.getInboundNonce(_srcChainId, radarPath);\n        uint64 nonceCap = inboundNonceCap[_srcRadarAddress];\n\n        for (uint i = 0; i < _steps; i++) {\n            // ensure that the nonce of the new path is not already at the cap\n            radarPathNonce++;\n            if (radarPathNonce > nonceCap) {\n                break;\n            }\n            // receive the message with null Payload\n            endpoint.receivePayload(_srcChainId, radarPath, dappRadar, radarPathNonce, _gasLimitPerCall, bytes(\"\"));\n        }\n    }\n\n    // this contract will only serve for a period of time\n    function decommission() external onlyOwner {\n        decommissioned = true;\n    }\n\n    //----------------------------------------------------------------------------------\n    // PROTOCOL\n    function validateTransactionProof(uint16 _srcChainId, address _dstAddress, uint _gasLimit, bytes32 _lookupHash, bytes32 _blockData, bytes calldata _transactionProof) external override {\n        require(_dstAddress == dappRadar, \"LayerZero: only dappRadar\");\n        require(!decommissioned, \"LayerZero: decommissioned\");\n\n        // retrieve UA's configuration using the _dstAddress from arguments.\n        ApplicationConfiguration memory uaConfig = _getAppConfig(_srcChainId, _dstAddress);\n\n        // assert that the caller == UA's relayer\n        require(uaConfig.relayer == msg.sender, \"LayerZero: invalid relayer\");\n\n        LayerZeroPacket.Packet memory _packet;\n        uint remoteAddressSize = chainAddressSizeMap[_srcChainId];\n        require(remoteAddressSize != 0, \"LayerZero: incorrect remote address size\");\n        {\n            // assert that the data submitted by UA's oracle have no fewer confirmations than UA's configuration\n            uint storedConfirmations = hashLookup[uaConfig.oracle][_srcChainId][_lookupHash][_blockData];\n            require(storedConfirmations > 0 && storedConfirmations >= uaConfig.inboundBlockConfirmations, \"LayerZero: not enough block confirmations\");\n\n            // decode\n            address inboundProofLib = inboundProofLibrary[_srcChainId][uaConfig.inboundProofLibraryVersion];\n            _packet = ILayerZeroValidationLibrary(inboundProofLib).validateProof(_blockData, _transactionProof, remoteAddressSize);\n        }\n\n        // packet content assertion\n        require(ulnLookup[_srcChainId] == _packet.ulnAddress && _packet.ulnAddress != bytes32(0), \"LayerZero: invalid _packet.ulnAddress\");\n        require(_packet.srcChainId == _srcChainId, \"LayerZero: invalid srcChain Id\");\n        // failsafe because the remoteAddress size being passed into validateProof trims the address this should not hit\n        require(_packet.srcAddress.length == remoteAddressSize, \"LayerZero: invalid srcAddress size\");\n        require(_packet.dstChainId == localChainId, \"LayerZero: invalid dstChain Id\");\n        require(_packet.dstAddress == _dstAddress, \"LayerZero: invalid dstAddress\");\n\n        // if the dst is not a contract, then emit and return early. This will break inbound nonces, but this particular\n        // path is already broken and wont ever be able to deliver anyways\n        if (!_isContract(_dstAddress)) {\n            emit InvalidDst(_packet.srcChainId, _packet.srcAddress, _packet.dstAddress, _packet.nonce, keccak256(_packet.payload));\n            return;\n        }\n\n        bytes memory pathData = abi.encodePacked(_packet.srcAddress, _packet.dstAddress);\n        emit PacketReceived(_packet.srcChainId, _packet.srcAddress, _packet.dstAddress, _packet.nonce, keccak256(_packet.payload));\n        endpoint.receivePayload(_srcChainId, pathData, _dstAddress, _packet.nonce, _gasLimit, _packet.payload);\n    }\n\n    function send(address _ua, uint64, uint16 _dstChainId, bytes calldata _path, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable override onlyEndpoint {\n        require(_ua == dappRadar, \"LayerZero: only dappRadar\");\n        require(!decommissioned, \"LayerZero: decommissioned\");\n\n        address ua = _ua;\n        uint16 dstChainId = _dstChainId;\n        require(ulnLookup[dstChainId] != bytes32(0), \"LayerZero: dstChainId does not exist\");\n\n        bytes memory dstAddress;\n        uint64 nonce;\n        // code block for solving 'Stack Too Deep'\n        {\n            uint chainAddressSize = chainAddressSizeMap[dstChainId];\n            // path = remoteAddress + localAddress\n            require(chainAddressSize != 0 && _path.length == 20 + chainAddressSize, \"LayerZero: incorrect remote address size\");\n            address srcInPath;\n            bytes memory path = _path; // copy to memory\n            assembly {\n                srcInPath := mload(add(add(path, 20), chainAddressSize)) // chainAddressSize + 20\n            }\n            require(ua == srcInPath, \"LayerZero: wrong path data\");\n            dstAddress = _path[0:chainAddressSize];\n            nonce = nonceContract.increment(dstChainId, ua, path);\n        }\n\n        bytes memory payload = _payload;\n        ApplicationConfiguration memory uaConfig = _getAppConfig(dstChainId, ua);\n\n        // compute all the fees\n        uint relayerFee = _handleRelayer(dstChainId, uaConfig, ua, payload.length, _adapterParams);\n        uint oracleFee = _handleOracle(dstChainId, uaConfig, ua);\n        uint nativeProtocolFee = _handleProtocolFee(relayerFee, oracleFee, ua, _zroPaymentAddress);\n\n        // total native fee, does not include ZRO protocol fee\n        uint totalNativeFee = relayerFee.add(oracleFee).add(nativeProtocolFee);\n\n        // assert the user has attached enough native token for this address\n        require(totalNativeFee <= msg.value, \"LayerZero: not enough native for fees\");\n        // refund if they send too much\n        uint amount = msg.value.sub(totalNativeFee);\n        if (amount > 0) {\n            (bool success, ) = _refundAddress.call{value: amount}(\"\");\n            require(success, \"LayerZero: failed to refund\");\n        }\n\n        // emit the data packet\n        bytes memory encodedPayload = abi.encodePacked(nonce, localChainId, ua, dstChainId, dstAddress, payload);\n        emit Packet(encodedPayload);\n    }\n\n    function _handleRelayer(uint16 _dstChainId, ApplicationConfiguration memory _uaConfig, address _ua, uint _payloadSize, bytes memory _adapterParams) internal returns (uint relayerFee) {\n        if (_adapterParams.length == 0) {\n            _adapterParams = defaultAdapterParams[_dstChainId][_uaConfig.outboundProofType];\n        }\n        address relayerAddress = _uaConfig.relayer;\n        ILayerZeroRelayerV2 relayer = ILayerZeroRelayerV2(relayerAddress);\n        relayerFee = relayer.assignJob(_dstChainId, _uaConfig.outboundProofType, _ua, _payloadSize, _adapterParams);\n\n        _creditNativeFee(relayerAddress, relayerFee);\n\n        // emit the param events\n        emit RelayerParams(_adapterParams, _uaConfig.outboundProofType);\n    }\n\n    function _handleOracle(uint16 _dstChainId, ApplicationConfiguration memory _uaConfig, address _ua) internal returns (uint oracleFee) {\n        address oracleAddress = _uaConfig.oracle;\n        oracleFee = ILayerZeroOracleV2(oracleAddress).assignJob(_dstChainId, _uaConfig.outboundProofType, _uaConfig.outboundBlockConfirmations, _ua);\n\n        _creditNativeFee(oracleAddress, oracleFee);\n    }\n\n    function _handleProtocolFee(uint _relayerFee, uint _oracleFee, address _ua, address _zroPaymentAddress) internal returns (uint protocolNativeFee) {\n        // if no ZRO token or not specifying a payment address, pay in native token\n        bool payInNative = _zroPaymentAddress == address(0x0) || address(layerZeroToken) == address(0x0);\n        uint protocolFee = treasuryContract.getFees(!payInNative, _relayerFee, _oracleFee);\n\n        if (protocolFee > 0) {\n            if (payInNative) {\n                address treasuryAddress = address(treasuryContract);\n                _creditNativeFee(treasuryAddress, protocolFee);\n                protocolNativeFee = protocolFee;\n            } else {\n                // zro payment address must equal the ua or the tx.origin otherwise the transaction reverts\n                require(_zroPaymentAddress == _ua || _zroPaymentAddress == tx.origin, \"LayerZero: must be paid by sender or origin\");\n\n                // transfer the LayerZero token to this contract from the payee\n                layerZeroToken.safeTransferFrom(_zroPaymentAddress, address(this), protocolFee);\n\n                treasuryZROFees = treasuryZROFees.add(protocolFee);\n            }\n        }\n    }\n\n    function _creditNativeFee(address _receiver, uint _amount) internal {\n        nativeFees[_receiver] = nativeFees[_receiver].add(_amount);\n    }\n\n    // Can be called by any address to update a block header\n    // can only upload new block data or the same block data with more confirmations\n    function updateHash(uint16 _srcChainId, bytes32 _lookupHash, uint _confirmations, bytes32 _blockData) external override {\n        uint storedConfirmations = hashLookup[msg.sender][_srcChainId][_lookupHash][_blockData];\n\n        // if it has a record, requires a larger confirmation.\n        require(storedConfirmations < _confirmations, \"LayerZero: oracle data can only update if it has more confirmations\");\n\n        // set the new information into storage\n        hashLookup[msg.sender][_srcChainId][_lookupHash][_blockData] = _confirmations;\n\n        emit HashReceived(_srcChainId, msg.sender, _lookupHash, _blockData, _confirmations);\n    }\n\n    //----------------------------------------------------------------------------------\n    // Other Library Interfaces\n\n    // default to DEFAULT setting if ZERO value\n    function getAppConfig(uint16 _remoteChainId, address _ua) external view override returns (ApplicationConfiguration memory) {\n        return _getAppConfig(_remoteChainId, _ua);\n    }\n\n    function _getAppConfig(uint16 _remoteChainId, address _ua) internal view returns (ApplicationConfiguration memory) {\n        ApplicationConfiguration memory config = appConfig[_ua][_remoteChainId];\n        ApplicationConfiguration storage defaultConfig = defaultAppConfig[_remoteChainId];\n\n        if (config.inboundProofLibraryVersion == 0) {\n            config.inboundProofLibraryVersion = defaultConfig.inboundProofLibraryVersion;\n        }\n\n        if (config.inboundBlockConfirmations == 0) {\n            config.inboundBlockConfirmations = defaultConfig.inboundBlockConfirmations;\n        }\n\n        if (config.relayer == address(0x0)) {\n            config.relayer = defaultConfig.relayer;\n        }\n\n        if (config.outboundProofType == 0) {\n            config.outboundProofType = defaultConfig.outboundProofType;\n        }\n\n        if (config.outboundBlockConfirmations == 0) {\n            config.outboundBlockConfirmations = defaultConfig.outboundBlockConfirmations;\n        }\n\n        if (config.oracle == address(0x0)) {\n            config.oracle = defaultConfig.oracle;\n        }\n\n        return config;\n    }\n\n    function setConfig(uint16 _remoteChainId, address _ua, uint _configType, bytes calldata _config) external override onlyEndpoint {\n        ApplicationConfiguration storage uaConfig = appConfig[_ua][_remoteChainId];\n        if (_configType == CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION) {\n            uint16 inboundProofLibraryVersion = abi.decode(_config, (uint16));\n            require(inboundProofLibraryVersion <= maxInboundProofLibrary[_remoteChainId], \"LayerZero: invalid inbound proof library version\");\n            uaConfig.inboundProofLibraryVersion = inboundProofLibraryVersion;\n        } else if (_configType == CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS) {\n            uint64 blockConfirmations = abi.decode(_config, (uint64));\n            uaConfig.inboundBlockConfirmations = blockConfirmations;\n        } else if (_configType == CONFIG_TYPE_RELAYER) {\n            address relayer = abi.decode(_config, (address));\n            uaConfig.relayer = relayer;\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_PROOF_TYPE) {\n            uint16 outboundProofType = abi.decode(_config, (uint16));\n            require(supportedOutboundProof[_remoteChainId][outboundProofType] || outboundProofType == 0, \"LayerZero: invalid outbound proof type\");\n            uaConfig.outboundProofType = outboundProofType;\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS) {\n            uint64 blockConfirmations = abi.decode(_config, (uint64));\n            uaConfig.outboundBlockConfirmations = blockConfirmations;\n        } else if (_configType == CONFIG_TYPE_ORACLE) {\n            address oracle = abi.decode(_config, (address));\n            uaConfig.oracle = oracle;\n        } else {\n            revert(\"LayerZero: Invalid config type\");\n        }\n\n        emit AppConfigUpdated(_ua, _configType, _config);\n    }\n\n    function getConfig(uint16 _remoteChainId, address _ua, uint _configType) external view override returns (bytes memory) {\n        ApplicationConfiguration storage uaConfig = appConfig[_ua][_remoteChainId];\n\n        if (_configType == CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION) {\n            if (uaConfig.inboundProofLibraryVersion == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].inboundProofLibraryVersion);\n            }\n            return abi.encode(uaConfig.inboundProofLibraryVersion);\n        } else if (_configType == CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS) {\n            if (uaConfig.inboundBlockConfirmations == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].inboundBlockConfirmations);\n            }\n            return abi.encode(uaConfig.inboundBlockConfirmations);\n        } else if (_configType == CONFIG_TYPE_RELAYER) {\n            if (uaConfig.relayer == address(0x0)) {\n                return abi.encode(defaultAppConfig[_remoteChainId].relayer);\n            }\n            return abi.encode(uaConfig.relayer);\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_PROOF_TYPE) {\n            if (uaConfig.outboundProofType == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].outboundProofType);\n            }\n            return abi.encode(uaConfig.outboundProofType);\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS) {\n            if (uaConfig.outboundBlockConfirmations == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].outboundBlockConfirmations);\n            }\n            return abi.encode(uaConfig.outboundBlockConfirmations);\n        } else if (_configType == CONFIG_TYPE_ORACLE) {\n            if (uaConfig.oracle == address(0x0)) {\n                return abi.encode(defaultAppConfig[_remoteChainId].oracle);\n            }\n            return abi.encode(uaConfig.oracle);\n        } else {\n            revert(\"LayerZero: Invalid config type\");\n        }\n    }\n\n    // returns the native fee the UA pays to cover fees\n    function estimateFees(uint16 _dstChainId, address _ua, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParams) external view override returns (uint nativeFee, uint zroFee) {\n        ApplicationConfiguration memory uaConfig = _getAppConfig(_dstChainId, _ua);\n\n        // Relayer Fee\n        bytes memory adapterParams;\n        if (_adapterParams.length > 0) {\n            adapterParams = _adapterParams;\n        } else {\n            adapterParams = defaultAdapterParams[_dstChainId][uaConfig.outboundProofType];\n        }\n        uint relayerFee = ILayerZeroRelayerV2(uaConfig.relayer).getFee(_dstChainId, uaConfig.outboundProofType, _ua, _payload.length, adapterParams);\n\n        // Oracle Fee\n        address ua = _ua; // stack too deep\n        uint oracleFee = ILayerZeroOracleV2(uaConfig.oracle).getFee(_dstChainId, uaConfig.outboundProofType, uaConfig.outboundBlockConfirmations, ua);\n\n        // LayerZero Fee\n        uint protocolFee = treasuryContract.getFees(_payInZRO, relayerFee, oracleFee);\n        _payInZRO ? zroFee = protocolFee : nativeFee = protocolFee;\n\n        // return the sum of fees\n        nativeFee = nativeFee.add(relayerFee).add(oracleFee);\n    }\n\n    //---------------------------------------------------------------------------\n    // Claim Fees\n\n    // universal withdraw ZRO token function\n    function withdrawZRO(address _to, uint _amount) external override nonReentrant {\n        require(msg.sender == address(treasuryContract), \"LayerZero: only treasury\");\n        treasuryZROFees = treasuryZROFees.sub(_amount);\n        layerZeroToken.safeTransfer(_to, _amount);\n        emit WithdrawZRO(msg.sender, _to, _amount);\n    }\n\n    // universal withdraw native token function.\n    // the source contract should perform all the authentication control\n    function withdrawNative(address payable _to, uint _amount) external override nonReentrant {\n        require(_to != address(0x0), \"LayerZero: _to cannot be zero address\");\n        nativeFees[msg.sender] = nativeFees[msg.sender].sub(_amount);\n\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"LayerZero: withdraw failed\");\n        emit WithdrawNative(msg.sender, _to, _amount);\n    }\n\n    //---------------------------------------------------------------------------\n    // Owner calls, configuration only.\n    function setLayerZeroToken(address _layerZeroToken) external onlyOwner {\n        require(_layerZeroToken != address(0x0), \"LayerZero: _layerZeroToken cannot be zero address\");\n        layerZeroToken = IERC20(_layerZeroToken);\n        emit SetLayerZeroToken(_layerZeroToken);\n    }\n\n    function setTreasury(address _treasury) external onlyOwner {\n        require(_treasury != address(0x0), \"LayerZero: treasury cannot be zero address\");\n        treasuryContract = ILayerZeroTreasury(_treasury);\n        emit SetTreasury(_treasury);\n    }\n\n    function addInboundProofLibraryForChain(uint16 _chainId, address _library) external onlyOwner {\n        require(_library != address(0x0), \"LayerZero: library cannot be zero address\");\n        uint16 libId = maxInboundProofLibrary[_chainId];\n        require(libId < 65535, \"LayerZero: can not add new library\");\n        maxInboundProofLibrary[_chainId] = ++libId;\n        inboundProofLibrary[_chainId][libId] = _library;\n        emit AddInboundProofLibraryForChain(_chainId, _library);\n    }\n\n    function enableSupportedOutboundProof(uint16 _chainId, uint16 _proofType) external onlyOwner {\n        supportedOutboundProof[_chainId][_proofType] = true;\n        emit EnableSupportedOutboundProof(_chainId, _proofType);\n    }\n\n    function setDefaultConfigForChainId(uint16 _chainId, uint16 _inboundProofLibraryVersion, uint64 _inboundBlockConfirmations, address _relayer, uint16 _outboundProofType, uint64 _outboundBlockConfirmations, address _oracle) external onlyOwner {\n        require(_inboundProofLibraryVersion <= maxInboundProofLibrary[_chainId] && _inboundProofLibraryVersion > 0, \"LayerZero: invalid inbound proof library version\");\n        require(_inboundBlockConfirmations > 0, \"LayerZero: invalid inbound block confirmation\");\n        require(_relayer != address(0x0), \"LayerZero: invalid relayer address\");\n        require(supportedOutboundProof[_chainId][_outboundProofType], \"LayerZero: invalid outbound proof type\");\n        require(_outboundBlockConfirmations > 0, \"LayerZero: invalid outbound block confirmation\");\n        require(_oracle != address(0x0), \"LayerZero: invalid oracle address\");\n        defaultAppConfig[_chainId] = ApplicationConfiguration(_inboundProofLibraryVersion, _inboundBlockConfirmations, _relayer, _outboundProofType, _outboundBlockConfirmations, _oracle);\n        emit SetDefaultConfigForChainId(_chainId, _inboundProofLibraryVersion, _inboundBlockConfirmations, _relayer, _outboundProofType, _outboundBlockConfirmations, _oracle);\n    }\n\n    function setDefaultAdapterParamsForChainId(uint16 _chainId, uint16 _proofType, bytes calldata _adapterParams) external onlyOwner {\n        defaultAdapterParams[_chainId][_proofType] = _adapterParams;\n        emit SetDefaultAdapterParamsForChainId(_chainId, _proofType, _adapterParams);\n    }\n\n    function setRemoteUln(uint16 _remoteChainId, bytes32 _remoteUln) external onlyOwner {\n        require(ulnLookup[_remoteChainId] == bytes32(0), \"LayerZero: remote uln already set\");\n        ulnLookup[_remoteChainId] = _remoteUln;\n        emit SetRemoteUln(_remoteChainId, _remoteUln);\n    }\n\n    function setChainAddressSize(uint16 _chainId, uint _size) external onlyOwner {\n        require(chainAddressSizeMap[_chainId] == 0, \"LayerZero: remote chain address size already set\");\n        chainAddressSizeMap[_chainId] = _size;\n        emit SetChainAddressSize(_chainId, _size);\n    }\n\n    //----------------------------------------------------------------------------------\n    // view functions\n\n    function accruedNativeFee(address _address) external view override returns (uint) {\n        return nativeFees[_address];\n    }\n\n    function getOutboundNonce(uint16 _chainId, bytes calldata _path) external view override returns (uint64) {\n        return nonceContract.outboundNonce(_chainId, _path);\n    }\n\n    function _isContract(address addr) internal view returns (bool) {\n        uint size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size != 0;\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.7/proxy/Proxied.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nabstract contract Proxied {\n    /// @notice to be used by initialisation / postUpgrade function so that only the proxy's admin can execute them\n    /// It also allows these functions to be called inside a contructor\n    /// even if the contract is meant to be used without proxy\n    modifier proxied() {\n        address proxyAdminAddress = _proxyAdmin();\n        // With hardhat-deploy proxies\n        // the proxyAdminAddress is zero only for the implementation contract\n        // if the implementation contract want to be used as a standalone/immutable contract\n        // it simply has to execute the `proxied` function\n        // This ensure the proxyAdminAddress is never zero post deployment\n        // And allow you to keep the same code for both proxied contract and immutable contract\n        if (proxyAdminAddress == address(0)) {\n            // ensure can not be called twice when used outside of proxy : no admin\n            // solhint-disable-next-line security/no-inline-assembly\n            assembly {\n                sstore(\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n                )\n            }\n        } else {\n            require(msg.sender == proxyAdminAddress);\n        }\n        _;\n    }\n\n    modifier onlyProxyAdmin() {\n        require(msg.sender == _proxyAdmin(), \"NOT_AUTHORIZED\");\n        _;\n    }\n\n    function _proxyAdmin() internal view returns (address ownerAddress) {\n        // solhint-disable-next-line security/no-inline-assembly\n        assembly {\n            ownerAddress := sload(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103)\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 30000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}