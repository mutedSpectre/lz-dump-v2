{"version":3,"sources":["../src/utils/utils.ts","../src/utils/hex.ts","../src/utils/precrime.ts","../src/options/options.ts","../src/codec/packet-v1-codec.ts","../src/model/packet.ts","../src/oapp/endpoint-configurator.ts"],"names":["ethers","WorkerId","ExecutorOptionType","VerifierOptionType"],"mappings":"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","sourcesContent":["import { ethers } from 'ethers'\n\nexport async function sleep(timeout: number) {\n    await new Promise((resolve) => setTimeout(resolve, timeout))\n}\n\nexport const parseError = (\n    errorData: string,\n    intf?: ethers.utils.Interface\n): ReturnType<ethers.utils.Interface['parseError']> | string | undefined => {\n    const buildInError = parseBuildInError(errorData)\n    if (buildInError !== undefined) {\n        return buildInError\n    }\n\n    if (intf) {\n        try {\n            return intf.parseError(errorData)\n        } catch (e) {\n            console.error(e)\n        }\n    }\n}\n\nfunction parseBuildInError(errorData: string): string | undefined {\n    if (errorData.startsWith('0x08c379a0')) {\n        // decode Error(string)\n\n        const content = `0x${errorData.substring(10)}`\n        const reason = ethers.utils.defaultAbiCoder.decode(['string'], content)\n\n        return reason[0] // reason: string; for standard revert error string\n    }\n\n    if (errorData.startsWith('0x4e487b71')) {\n        // decode Panic(uint)\n        const content = `0x${errorData.substring(10)}`\n        const code = ethers.utils.defaultAbiCoder.decode(['uint'], content)\n\n        return code[0]\n    }\n\n    if (errorData === '0x') {\n        return ''\n    }\n}\n","import { PublicKey } from '@solana/web3.js'\nimport { ethers } from 'ethers'\nimport { arrayify } from 'ethers/lib/utils'\n\nexport function hexZeroPadTo32(addr: string): string {\n    return ethers.utils.hexZeroPad(addr, 32)\n}\n\nexport function bytes32ToEthAddress(bytes32: string | Uint8Array): string {\n    if (bytes32 instanceof Uint8Array) {\n        bytes32 = ethers.utils.hexlify(bytes32)\n    }\n    return ethers.utils.getAddress(bytes32.slice(-40))\n}\n\nexport function trim0x(str: string): string {\n    return str.replace(/^0x/, '')\n}\n\n/**\n * Convert address to bytes32\n * @param address 0x prefixed address(20bytes or 32bytes) or solana address\n */\nexport function addressToBytes32(address: string): Uint8Array {\n    if (isSolanaAddress(address)) {\n        return new PublicKey(address).toBytes()\n    } else if (address.startsWith('0x') && address.length <= 66) {\n        return arrayify(hexZeroPadTo32(address))\n    }\n    throw new Error('Invalid address')\n}\n\nconst solanaAddressRegex = /^([1-9A-HJ-NP-Za-km-z]{32,44})$/\n\nexport function isSolanaAddress(address: string): boolean {\n    return solanaAddressRegex.test(address)\n}\n","import { PrecrimeConfig } from '../model'\n\nimport { trim0x } from './hex'\n\nexport function parsePrecrimeConfig(precrimeConfig: string): PrecrimeConfig {\n    const data = trim0x(precrimeConfig)\n    const version = parseInt(data.slice(0, 4), 16)\n    const maxBatchSize = parseInt(data.slice(4, 20), 16)\n    const remoteChainsLength = parseInt(data.slice(20, 84), 16)\n    const remoteChainsBytes = data.slice(84, 84 + remoteChainsLength * 64)\n    const remoteAddressesBytes = data.slice(\n        84 + remoteChainsLength * 64,\n        84 + remoteChainsLength * 64 + remoteChainsLength * 64\n    )\n\n    const remoteChainsBytesArray: number[] = []\n    const remoteAddressesBytesArray: string[] = []\n    let start = 0\n    let end = 64\n    for (let i = 0; i < remoteChainsLength; i++) {\n        remoteChainsBytesArray.push(parseInt(remoteChainsBytes.slice(start, end), 16))\n        remoteAddressesBytesArray.push(`0x${remoteAddressesBytes.slice(start, end)}`)\n        start += 64\n        end += 64\n    }\n    return { version, maxBatchSize, remoteEids: remoteChainsBytesArray, remoteAddresses: remoteAddressesBytesArray }\n}\n","import { ethers } from 'ethers'\nimport invariant from 'tiny-invariant'\n\nimport { hexZeroPadTo32, trim0x } from '../utils'\n\n/**\n *  txType 1,\n *  bytes  [2       32      ]\n *  fields [txType  extraGas]\n */\nconst TYPE_1 = 1\n/**\n *  txType 2,\n *  bytes  [2       32        32            bytes[]         ]\n *  fields [txType  extraGas  dstNativeAmt  dstNativeAddress]\n */\nconst TYPE_2 = 2\n/**\n * only available for V2\n */\nconst TYPE_3 = 3\n\nconst MaxUint128 = ethers.BigNumber.from('0xffffffffffffffffffffffffffffffff')\n\nexport function optionsType1(_extraGas: number | string): string {\n    const extraGas = ethers.BigNumber.from(_extraGas)\n    invariant(extraGas.lte(MaxUint128), 'extraGas should be less than MaxUint128')\n    return ethers.utils.solidityPack(['uint16', 'uint256'], [TYPE_1, extraGas])\n}\n\nexport function optionsType2(\n    _extraGas: number | string,\n    _dstNativeAmt: number | string,\n    _dstNativeAddress: string\n): string {\n    const extraGas = ethers.BigNumber.from(_extraGas)\n    invariant(extraGas.lte(MaxUint128), 'extraGas should be less than MaxUint128')\n    const dstNativeAmt = ethers.BigNumber.from(_dstNativeAmt)\n    invariant(dstNativeAmt.lte(MaxUint128), 'dstNativeAmt should be less than MaxUint128')\n    return ethers.utils.solidityPack(\n        ['uint16', 'uint256', 'uint256', 'bytes'],\n        [TYPE_2, ethers.BigNumber.from(extraGas), ethers.BigNumber.from(dstNativeAmt), _dstNativeAddress]\n    )\n}\n\nexport enum WorkerId {\n    Executor = 1,\n    Verifier = 2,\n    Treasury = 255,\n}\n\nexport type WorkerOptions = {\n    workerId: number // uint8\n    options: Option[] // toBytes: num(uint8),[type(uint8),size(uint16),data],[type(uint8),size(uint16),data],[type(uint8),size(uint16),data]...\n}\n\nexport type Option = {\n    type: number // uint8\n    params: string // bytes\n}\n\nexport type VerifierOption = Option & {\n    index: number // uint8\n}\n\nexport enum ExecutorOptionType {\n    lzReceive = 1,\n    airdrop = 2,\n    compose = 3,\n    ordered = 4,\n}\n\nexport enum VerifierOptionType {\n    precrime = 1,\n}\n\n/**\n * only available for V2\n * options builder\n */\nexport class Options {\n    workerOptions: WorkerOptions[] = []\n\n    static newOptions(): Options {\n        return new Options()\n    }\n\n    static fromOptions(optionsHex: string): Options {\n        const options = new Options()\n        const optionsBytes = ethers.utils.arrayify(optionsHex)\n        // 0-2 bytes is options type\n        const optionsType = ethers.BigNumber.from(optionsBytes.slice(0, 2)).toNumber()\n        if (optionsType === TYPE_3) {\n            let cursor = 2\n            while (cursor < optionsBytes.byteLength) {\n                const workerId = ethers.BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber()\n                cursor += 1\n\n                const size = ethers.BigNumber.from(optionsBytes.slice(cursor, cursor + 2)).toNumber()\n                cursor += 2\n\n                if (workerId === WorkerId.Executor) {\n                    const optionType = ethers.BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber()\n                    cursor += 1\n                    const params = optionsBytes.slice(cursor, cursor + size - 1)\n                    cursor += size - 1\n                    options.addOption(workerId, { type: optionType, params: ethers.utils.hexlify(params) })\n                } else if (workerId === WorkerId.Verifier) {\n                    const verifierIdx = ethers.BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber()\n                    cursor += 1\n                    const optionType = ethers.BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber()\n                    cursor += 1\n                    const params = optionsBytes.slice(cursor, cursor + size - 2)\n                    cursor += size - 2\n                    options.addOption(workerId, <VerifierOption>{\n                        type: optionType,\n                        index: verifierIdx,\n                        params: ethers.utils.hexlify(params),\n                    })\n                }\n                // TODO - other workerId\n            }\n        } else if (optionsType === TYPE_2) {\n            const extraGas = ethers.BigNumber.from(optionsBytes.slice(2, 34)).toNumber()\n            const dstNativeAmt = ethers.BigNumber.from(optionsBytes.slice(34, 66)).toNumber()\n            const dstNativeAddress = ethers.utils.hexlify(optionsBytes.slice(66, optionsBytes.byteLength))\n            options.addExecutorLzReceiveOption(extraGas).addExecutorAirdropOption(dstNativeAmt, dstNativeAddress)\n        } else if (optionsType === TYPE_1) {\n            const extraGas = ethers.BigNumber.from(optionsBytes.slice(2, 34)).toNumber()\n            options.addExecutorLzReceiveOption(extraGas)\n        }\n\n        return options\n    }\n\n    addExecutorLzReceiveOption(gas: string | number, value: string | number = 0): Options {\n        const gasBN = ethers.BigNumber.from(gas)\n        invariant(gasBN.lte(MaxUint128), \"gas shouldn't be greater than MaxUint128\")\n        const valueBN = ethers.BigNumber.from(value)\n        invariant(valueBN.lte(MaxUint128), \"value shouldn't be greater than MaxUint128\")\n        this.addOption(WorkerId.Executor, {\n            type: ExecutorOptionType.lzReceive,\n            params: valueBN.eq(0)\n                ? ethers.utils.solidityPack(['uint128'], [gasBN])\n                : ethers.utils.solidityPack(['uint128', 'uint128'], [gasBN, valueBN]),\n        })\n        return this\n    }\n\n    addExecutorAirdropOption(amount: string | number, receiver: string): Options {\n        const amountBN = ethers.BigNumber.from(amount)\n        invariant(amountBN.lte(MaxUint128), \"amount shouldn't be greater than MaxUint128\")\n        this.addOption(WorkerId.Executor, {\n            type: ExecutorOptionType.airdrop,\n            params: ethers.utils.solidityPack(['uint128', 'bytes32'], [amountBN, hexZeroPadTo32(receiver)]),\n        })\n        return this\n    }\n\n    addExecutorComposeOption(gas: string | number, value: string | number = 0): Options {\n        const gasBN = ethers.BigNumber.from(gas)\n        invariant(gasBN.lte(MaxUint128), \"gas shouldn't be greater than MaxUint128\")\n        const valueBN = ethers.BigNumber.from(value)\n        invariant(valueBN.lte(MaxUint128), \"value shouldn't be greater than MaxUint128\")\n        this.addOption(WorkerId.Executor, {\n            type: ExecutorOptionType.compose,\n            params: ethers.utils.solidityPack(['uint128', 'uint128'], [gasBN, valueBN]),\n        })\n        return this\n    }\n\n    addExecutorOrderedExecutionOption(): Options {\n        this.addOption(WorkerId.Executor, {\n            type: ExecutorOptionType.ordered,\n            params: '0x',\n        })\n        return this\n    }\n\n    addVerifierPrecrimeOption(verifierIdx: number): Options {\n        this.addOption(WorkerId.Verifier, <VerifierOption>{\n            type: VerifierOptionType.precrime,\n            index: verifierIdx,\n            params: '0x',\n        })\n        return this\n    }\n\n    toHex(): string {\n        // output encoded hex, type(uint16)\n        let hex = ethers.utils.solidityPack(['uint16'], [TYPE_3])\n        this.workerOptions.forEach((w) => {\n            for (const option of w.options) {\n                if (w.workerId === WorkerId.Executor) {\n                    hex += trim0x(\n                        ethers.utils.solidityPack(\n                            ['uint8', 'uint16', 'uint8', 'bytes'],\n                            [w.workerId, trim0x(option.params).length / 2 + 1, option.type, option.params]\n                        )\n                    )\n                } else if (w.workerId === WorkerId.Verifier) {\n                    const verifierOption = option as VerifierOption\n                    hex += trim0x(\n                        ethers.utils.solidityPack(\n                            ['uint8', 'uint16', 'uint8', 'uint8', 'bytes'],\n                            [\n                                w.workerId,\n                                trim0x(option.params).length / 2 + 2,\n                                verifierOption.index,\n                                verifierOption.type,\n                                verifierOption.params,\n                            ]\n                        )\n                    )\n                }\n                // TODO other workerId\n            }\n        })\n        return hex\n    }\n\n    toBytes(): Uint8Array {\n        return ethers.utils.arrayify(this.toHex())\n    }\n\n    private addOption(workerId: number, option: Option): void {\n        const worker = this.workerOptions.find((w) => w.workerId === workerId)\n        if (worker) {\n            worker.options.push(option)\n        } else {\n            this.workerOptions.push({ workerId, options: [option] })\n        }\n    }\n\n    decodeExecutorLzReceiveOption(): { gas: ethers.BigNumber; value: ethers.BigNumber } | undefined {\n        const option = this.findOption(WorkerId.Executor, ExecutorOptionType.lzReceive)\n        if (!option) {\n            return\n        }\n        const buffer = Buffer.from(trim0x(option.params), 'hex')\n        const gas = ethers.BigNumber.from(buffer.slice(0, 16))\n        if (buffer.length === 16) {\n            return { gas, value: ethers.BigNumber.from(0) }\n        }\n        const value = ethers.BigNumber.from(buffer.slice(16, 32))\n        return { gas, value }\n    }\n\n    decodeExecutorAirdropOption(): { amount: ethers.BigNumber; receiver: string } | undefined {\n        const option = this.findOption(WorkerId.Executor, ExecutorOptionType.airdrop)\n        if (!option) {\n            return\n        }\n        const buffer = Buffer.from(trim0x(option.params), 'hex')\n        const amount = ethers.BigNumber.from(buffer.slice(0, 16))\n        const receiver = ethers.utils.hexlify(buffer.slice(16, 48))\n        return { amount, receiver }\n    }\n\n    decodeExecutorComposeOption(): { gas: ethers.BigNumber; value: ethers.BigNumber } | undefined {\n        const option = this.findOption(WorkerId.Executor, ExecutorOptionType.compose)\n        if (!option) {\n            return\n        }\n        const buffer = Buffer.from(trim0x(option.params), 'hex')\n        const gas = ethers.BigNumber.from(buffer.slice(0, 16))\n        const value = ethers.BigNumber.from(buffer.slice(16, 32))\n        return { gas, value }\n    }\n\n    decodeExecutorOrderedExecutionOption(): boolean {\n        const option = this.findOption(WorkerId.Executor, ExecutorOptionType.ordered)\n        return option !== undefined\n    }\n\n    private findOption(workerId: number, optionType: number): Option | undefined {\n        const worker = this.workerOptions.find((w) => w.workerId === workerId)\n        if (worker) {\n            return worker.options.find((o) => o.type === optionType)\n        }\n    }\n\n    findVerifierOption(verifierIdx: number, optionType: number): VerifierOption | undefined {\n        const worker = this.workerOptions.find((w) => w.workerId === WorkerId.Verifier)\n        if (worker) {\n            const opt = worker.options.find((o) => o.type === optionType && (o as VerifierOption).index === verifierIdx)\n            if (opt) {\n                return opt as VerifierOption\n            }\n        }\n    }\n}\n","// header (version + path + guid)\n// version\nimport { ethers } from 'ethers'\n\nimport { Packet, PacketHeader } from '../model'\nimport { addressToBytes32, bytes32ToEthAddress, trim0x } from '../utils'\n\nconst PACKET_VERSION_OFFSET = 0\n//    nonce\nconst NONCE_OFFSET = 1\n//    path\nconst SRC_CHAIN_OFFSET = 9\nconst SRC_ADDRESS_OFFSET = 13\nconst DST_CHAIN_OFFSET = 45\nconst DST_ADDRESS_OFFSET = 49\n// payload (guid + message)\nconst GUID_OFFSET = 81 // keccak256(nonce + path)\nconst MESSAGE_OFFSET = 113\n\nexport class PacketV1Codec {\n    buffer: Buffer\n\n    static from(payloadEncoded: string): PacketV1Codec {\n        return new PacketV1Codec(payloadEncoded)\n    }\n\n    static fromBytes(payload: Uint8Array): PacketV1Codec {\n        return new PacketV1Codec('0x' + Buffer.from(payload).toString('hex'))\n    }\n\n    protected constructor(payloadEncoded: string) {\n        this.buffer = Buffer.from(trim0x(payloadEncoded), 'hex')\n    }\n\n    /**\n     * encode packet to hex string\n     */\n    static encode(packet: Packet): string {\n        const message = trim0x(packet.message)\n        const buffer = Buffer.alloc(MESSAGE_OFFSET + message.length / 2)\n        buffer.writeUInt8(packet.version, PACKET_VERSION_OFFSET)\n        buffer.writeBigUInt64BE(BigInt(packet.nonce), NONCE_OFFSET)\n        buffer.writeUInt32BE(packet.srcEid, SRC_CHAIN_OFFSET)\n        buffer.write(trim0x(packet.sender), SRC_ADDRESS_OFFSET, 32, 'hex')\n        buffer.writeUInt32BE(packet.dstEid, DST_CHAIN_OFFSET)\n        buffer.write(trim0x(packet.receiver), DST_ADDRESS_OFFSET, 32, 'hex')\n        buffer.write(trim0x(packet.guid), GUID_OFFSET, 32, 'hex')\n        buffer.write(message, MESSAGE_OFFSET, message.length / 2, 'hex')\n        return '0x' + buffer.toString('hex')\n    }\n\n    version(): number {\n        return this.buffer.readUInt8(PACKET_VERSION_OFFSET)\n    }\n\n    nonce(): string {\n        return this.buffer.readBigUint64BE(NONCE_OFFSET).toString()\n    }\n\n    srcEid(): number {\n        return this.buffer.readUint32BE(SRC_CHAIN_OFFSET)\n    }\n\n    sender(): string {\n        return '0x' + this.buffer.slice(SRC_ADDRESS_OFFSET, DST_CHAIN_OFFSET).toString('hex')\n    }\n\n    senderAddressB20(): string {\n        return bytes32ToEthAddress(this.sender())\n    }\n\n    dstEid(): number {\n        return this.buffer.readUint32BE(DST_CHAIN_OFFSET)\n    }\n\n    receiver(): string {\n        return '0x' + this.buffer.slice(DST_ADDRESS_OFFSET, GUID_OFFSET).toString('hex')\n    }\n\n    receiverAddressB20(): string {\n        return bytes32ToEthAddress(this.receiver())\n    }\n\n    guid(): string {\n        return '0x' + this.buffer.slice(GUID_OFFSET, MESSAGE_OFFSET).toString('hex')\n    }\n\n    message(): string {\n        return '0x' + this.buffer.slice(MESSAGE_OFFSET).toString('hex')\n    }\n\n    payloadHash(): string {\n        return keccak256(this.payload())\n    }\n\n    payload(): string {\n        return '0x' + this.buffer.slice(GUID_OFFSET).toString('hex')\n    }\n\n    header(): string {\n        return '0x' + this.buffer.slice(0, GUID_OFFSET).toString('hex')\n    }\n\n    headerHash(): string {\n        return keccak256(this.header())\n    }\n\n    /**\n     * deserialize packet from hex string\n     * @deprecated use toPacket instead\n     */\n    decode(): Packet {\n        return this.toPacket()\n    }\n\n    toPacket(): Packet {\n        return {\n            version: this.version(),\n            nonce: this.nonce(),\n            srcEid: this.srcEid(),\n            sender: this.sender(),\n            dstEid: this.dstEid(),\n            receiver: this.receiver(),\n            guid: this.guid(),\n            message: this.message(),\n            // derived\n            payload: this.payload(),\n        }\n    }\n}\n\nexport function calculateGuid(packetHead: PacketHeader): string {\n    return keccak256(\n        ethers.utils.solidityPack(\n            ['uint64', 'uint32', 'bytes32', 'uint32', 'bytes32'],\n            [\n                ethers.BigNumber.from(packetHead.nonce),\n                packetHead.srcEid,\n                addressToBytes32(packetHead.sender),\n                packetHead.dstEid,\n                addressToBytes32(packetHead.receiver),\n            ]\n        )\n    )\n}\n\nexport function keccak256(message: string): string {\n    return ethers.utils.keccak256(message)\n}\n","import { PacketV1Codec } from '../codec'\n\nexport type PacketPath = {\n    srcEid: number\n    sender: string\n    dstEid: number\n    receiver: string\n}\n\nexport type PacketHeader = {\n    version: number\n    nonce: string\n} & PacketPath\n\nexport type Packet = PacketHeader & {\n    guid: string\n    message: string\n    // derived\n    payload: string // payload = guid + message\n}\n\n// message origin\nexport type MessageOrigin = {\n    srcEid: number\n    sender: string\n    nonce: string\n}\n\nexport class PacketSerializer {\n    static serialize(packet: Packet): string {\n        return PacketV1Codec.encode(packet)\n    }\n\n    static deserialize(bytesLike: Uint8Array | string): Packet {\n        let codec: PacketV1Codec\n        if (bytesLike instanceof Uint8Array) {\n            codec = PacketV1Codec.fromBytes(bytesLike)\n        } else {\n            codec = PacketV1Codec.from(bytesLike)\n        }\n        return codec.toPacket()\n    }\n}\n\nexport function packetToMessageOrigin(packet: Packet): MessageOrigin {\n    return {\n        srcEid: packet.srcEid,\n        sender: packet.sender,\n        nonce: packet.nonce,\n    }\n}\n","import { BigNumberish, BytesLike, Contract, PopulatedTransaction } from 'ethers'\n\nimport { EndpointV2__factory, IMessageLibManager } from '@layerzerolabs/lz-evm-sdk-v2'\nimport { IMessageOrigin } from '@layerzerolabs/lz-evm-sdk-v2/chaintypes/EndpointV2'\nimport { PromiseOrValue } from '@layerzerolabs/lz-evm-sdk-v2/chaintypes/common'\n\nexport async function populateSetEndpointConfig(oapp: Contract, configPayload: string): Promise<PopulatedTransaction> {\n    return { to: oapp.address, data: oapp.interface.encodeFunctionData('setEndpointConfig', [configPayload]) }\n}\n\nexport async function populateSnapshotConfig(\n    oapp: Contract,\n    messageLib: PromiseOrValue<string>,\n    eids: PromiseOrValue<BigNumberish>[]\n): Promise<PopulatedTransaction> {\n    const endpointIFace = EndpointV2__factory.createInterface()\n    const configPayload = endpointIFace.encodeFunctionData('snapshotConfig', [messageLib, eids])\n    return populateSetEndpointConfig(oapp, configPayload)\n}\n\nexport async function populateSetConfig(\n    oapp: Contract,\n    lib: PromiseOrValue<string>,\n    eid: PromiseOrValue<BigNumberish>,\n    params: IMessageLibManager.SetConfigParamStruct[]\n): Promise<PopulatedTransaction> {\n    const endpointIFace = EndpointV2__factory.createInterface()\n    const configPayload = endpointIFace.encodeFunctionData('setConfig', [lib, eid, params])\n    return populateSetEndpointConfig(oapp, configPayload)\n}\n\nexport async function populateSetSendMessageLib(\n    oapp: Contract,\n    eid: PromiseOrValue<BigNumberish>,\n    newLib: PromiseOrValue<string>\n): Promise<PopulatedTransaction> {\n    const endpointIFace = EndpointV2__factory.createInterface()\n    const configPayload = endpointIFace.encodeFunctionData('setSendLibrary', [eid, newLib])\n    return populateSetEndpointConfig(oapp, configPayload)\n}\n\nexport async function populateResetConfig(\n    oapp: Contract,\n    lib: PromiseOrValue<string>,\n    eids: PromiseOrValue<BigNumberish>[]\n): Promise<PopulatedTransaction> {\n    const endpointIFace = EndpointV2__factory.createInterface()\n    const configPayload = endpointIFace.encodeFunctionData('resetConfig', [lib, eids])\n    return populateSetEndpointConfig(oapp, configPayload)\n}\n\nexport async function populateSetReceiveLibrary(\n    oapp: Contract,\n    eid: PromiseOrValue<BigNumberish>,\n    newLib: PromiseOrValue<string>,\n    gracePeriod: PromiseOrValue<BigNumberish>\n): Promise<PopulatedTransaction> {\n    const endpointIFace = EndpointV2__factory.createInterface()\n    const configPayload = endpointIFace.encodeFunctionData('setReceiveLibrary', [eid, newLib, gracePeriod])\n    return populateSetEndpointConfig(oapp, configPayload)\n}\n\nexport async function populateSetReceiveLibraryTimeout(\n    oapp: Contract,\n    eid: PromiseOrValue<BigNumberish>,\n    lib: PromiseOrValue<string>,\n    expiry: PromiseOrValue<BigNumberish>\n): Promise<PopulatedTransaction> {\n    const endpointIFace = EndpointV2__factory.createInterface()\n    const configPayload = endpointIFace.encodeFunctionData('setReceiveLibraryTimeout', [eid, lib, expiry])\n    return populateSetEndpointConfig(oapp, configPayload)\n}\n\nexport async function populateClear(\n    oapp: Contract,\n    origin: IMessageOrigin.MessageOriginStruct,\n    guid: PromiseOrValue<BytesLike>,\n    message: PromiseOrValue<BytesLike>\n): Promise<PopulatedTransaction> {\n    const endpointIFace = EndpointV2__factory.createInterface()\n    const configPayload = endpointIFace.encodeFunctionData('clear', [origin, guid, message])\n    return populateSetEndpointConfig(oapp, configPayload)\n}\n\nexport async function populateSkip(\n    oapp: Contract,\n    srcEid: PromiseOrValue<BigNumberish>,\n    sender: PromiseOrValue<BytesLike>,\n    nonce: PromiseOrValue<BigNumberish>\n): Promise<PopulatedTransaction> {\n    const endpointIFace = EndpointV2__factory.createInterface()\n    const configPayload = endpointIFace.encodeFunctionData('skip', [srcEid, sender, nonce])\n    return populateSetEndpointConfig(oapp, configPayload)\n}\n"]}